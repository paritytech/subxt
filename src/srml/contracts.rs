//! Implements support for the srml_contracts module.
use crate::{
    codec::{
        compact,
        Encoded,
    },
    metadata::MetadataError,
    srml::{
        balances::Balances,
        system::System,
        ModuleCalls,
    },
    Valid,
    XtBuilder,
};
use parity_scale_codec::Codec;
use runtime_primitives::traits::StaticLookup;
use substrate_primitives::Pair;

/// Gas units are chosen to be represented by u64 so that gas metering
/// instructions can operate on them efficiently.
pub type Gas = u64;

/// The subset of the `srml_contracts::Trait` that a client must implement.
pub trait Contracts: System + Balances {}

/// The Contracts extension trait for the XtBuilder.
pub trait ContractsXt {
    /// Contracts type.
    type Contracts: Contracts;
    /// Key Pair Type
    type Pair: Pair;

    /// Create a call for the srml contracts module
    fn contracts<F>(
        &self,
        f: F,
    ) -> Result<XtBuilder<Self::Contracts, Self::Pair, Valid>, MetadataError>
    where
        F: FnOnce(
            ModuleCalls<Self::Contracts, Self::Pair>,
        ) -> Result<Encoded, MetadataError>;
}

impl<T: Contracts + 'static, P, V> ContractsXt for XtBuilder<T, P, V>
where
    P: Pair,
    P::Public: Into<<<T as System>::Lookup as StaticLookup>::Source>,
    P::Signature: Codec,
{
    type Contracts = T;
    type Pair = P;

    fn contracts<F>(&self, f: F) -> Result<XtBuilder<T, P, Valid>, MetadataError>
    where
        F: FnOnce(
            ModuleCalls<Self::Contracts, Self::Pair>,
        ) -> Result<Encoded, MetadataError>,
    {
        self.set_call("Contracts", f)
    }
}

impl<T: Contracts + 'static, P> ModuleCalls<T, P>
where
    P: Pair,
    P::Public: Into<<<T as System>::Lookup as StaticLookup>::Source>,
    P::Signature: Codec,
{
    /// Stores the given binary Wasm code into the chain's storage and returns
    /// its `codehash`.
    /// You can instantiate contracts only with stored code.
    pub fn put_code(
        &self,
        gas_limit: Gas,
        code: Vec<u8>,
    ) -> Result<Encoded, MetadataError> {
        self.module.call("put_code", (compact(gas_limit), code))
    }

    /// Creates a new contract from the `codehash` generated by `put_code`,
    /// optionally transferring some balance.
    ///
    /// Creation is executed as follows:
    ///
    /// - The destination address is computed based on the sender and hash of
    /// the code.
    /// - The smart-contract account is created at the computed address.
    /// - The `ctor_code` is executed in the context of the newly-created
    /// account. Buffer returned after the execution is saved as the `code`
    /// of the account. That code will be invoked upon any call received by
    /// this account.
    /// - The contract is initialized.
    pub fn create(
        &self,
        endowment: <T as Balances>::Balance,
        gas_limit: Gas,
        code_hash: <T as System>::Hash,
        data: Vec<u8>,
    ) -> Result<Encoded, MetadataError> {
        self.module.call(
            "create",
            (compact(endowment), compact(gas_limit), code_hash, data),
        )
    }

    /// Makes a call to an account, optionally transferring some balance.
    ///
    /// * If the account is a smart-contract account, the associated code will
    ///  be executed and any value will be transferred.
    /// * If the account is a regular account, any value will be transferred.
    /// * If no account exists and the call value is not less than
    /// `existential_deposit`, a regular account will be created and any value
    ///  will be transferred.
    pub fn call(
        &self,
        dest: <<T as System>::Lookup as StaticLookup>::Source,
        value: <T as Balances>::Balance,
        gas_limit: Gas,
        data: Vec<u8>,
    ) -> Result<Encoded, MetadataError> {
        self.module
            .call("call", (dest, compact(value), compact(gas_limit), data))
    }
}
