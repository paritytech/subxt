//! Implements support for the srml_contracts module.
use crate::{
    codec::{
        compact,
        Encoded,
    },
    metadata::{
        ModuleMetadata,
        MetadataError,
    },
    balances::Balances,
    system::System,
    Valid,
    XtBuilder,
};
use runtime_primitives::traits::StaticLookup;
use substrate_primitives::Pair;

/// Gas units are chosen to be represented by u64 so that gas metering
/// instructions can operate on them efficiently.
pub type Gas = u64;

/// The subset of the `srml_contracts::Trait` that a client must implement.
pub trait Contracts: System + Balances {}

/// The Contracts extension trait for the XtBuilder.
pub trait ContractsXt {
    /// Contracts type.
    type Contracts: Contracts;
    /// Key Pair Type
    type Pair: Pair;

    /// Create a call for the srml contracts module
    fn contracts<F>(&self, f: F) -> XtBuilder<Self::Contracts, Self::Pair, Valid>
    where
        F: FnOnce(
            &ModuleMetadata,
        ) -> Result<Encoded, MetadataError>;
}

impl<T: Contracts + 'static, P, V> ContractsXt for XtBuilder<T, P, V>
where
    P: Pair,
{
    type Contracts = T;
    type Pair = P;

    fn contracts<F>(&self, f: F) -> XtBuilder<T, P, Valid>
    where
        F: FnOnce(
            &ModuleMetadata,
        ) -> Result<Encoded, MetadataError>,
    {
        self.set_call("Contracts", f)
    }
}

/// Stores the given binary Wasm code into the chain's storage and returns
/// its `codehash`.
/// You can instantiate contracts only with stored code.
pub fn put_code(
    m: &ModuleMetadata,
    gas_limit: Gas,
    code: Vec<u8>,
    ) -> Result<Encoded, MetadataError> {
    m.call("put_code", (compact(gas_limit), code))
}

/// Creates a new contract from the `codehash` generated by `put_code`,
/// optionally transferring some balance.
///
/// Creation is executed as follows:
///
/// - The destination address is computed based on the sender and hash of
/// the code.
/// - The smart-contract account is created at the computed address.
/// - The `ctor_code` is executed in the context of the newly-created
/// account. Buffer returned after the execution is saved as the `code`
/// of the account. That code will be invoked upon any call received by
/// this account.
/// - The contract is initialized.
pub fn create<T: Contracts + 'static>(
    m: &ModuleMetadata,
    endowment: <T as Balances>::Balance,
    gas_limit: Gas,
    code_hash: <T as System>::Hash,
    data: Vec<u8>,
    ) -> Result<Encoded, MetadataError> {
    m.call(
        "create",
        (compact(endowment), compact(gas_limit), code_hash, data),
        )
}

/// Makes a call to an account, optionally transferring some balance.
///
/// * If the account is a smart-contract account, the associated code will
///  be executed and any value will be transferred.
/// * If the account is a regular account, any value will be transferred.
/// * If no account exists and the call value is not less than
/// `existential_deposit`, a regular account will be created and any value
///  will be transferred.
pub fn call<T: Contracts + 'static>(
    m: &ModuleMetadata,
    dest: <<T as System>::Lookup as StaticLookup>::Source,
    value: <T as Balances>::Balance,
    gas_limit: Gas,
    data: Vec<u8>,
    ) -> Result<Encoded, MetadataError> {
    m.call("call", (dest, compact(value), compact(gas_limit), data))
}

/// Exported trait for external Runtime
pub trait BasicContracts {}

impl<T: BasicContracts + Balances + System> Contracts for T {}

