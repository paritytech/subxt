// Copyright 2019-2024 Parity Technologies (UK) Ltd.
// This file is dual-licensed as Apache-2.0 or GPL-3.0.
// see LICENSE for license details.

//! Construct addresses to access storage entries with.

use alloc::borrow::Cow;
use frame_decode::storage::IntoEncodableValues;
use scale_decode::DecodeAsType;
use crate::utils::{Maybe, YesNoMaybe};

/// A storage address. This allows access to a given storage entry, which can then
/// be iterated over or fetched from by providing the relevant set of keys, or
/// otherwise inspected.
pub trait Address {
    /// All of the keys required to get to an individual value at this address.
    /// Keys must always impl [`IntoEncodableValues`], and for iteration must
    /// also impl [`frame_decode::storage::IntoDecodableValues`].
    type KeyParts: IntoEncodableValues;
    /// Type of the storage value at this location.
    type Value: DecodeAsType;
    /// Does the address have a default value defined for it.
    /// Set to [`crate::utils::Yes`] to enable APIs which require one,
    /// or [`crate::utils::Maybe`] to enable APIs which allow one
    type HasDefaultValue: YesNoMaybe;
    /// Does the address point to a map (as opposed to a plain value)? 
    /// Set to [`crate::utils::Yes`] to enable APIs which require a map,
    /// or [`crate::utils::Maybe`] to enable APIs which allow a map.
    type IsMap;

    /// The pallet containing this storage entry.
    fn pallet_name(&self) -> &str;

    /// The name of the storage entry.
    fn entry_name(&self) -> &str;

    /// Return a unique hash for this address which can be used to validate it against metadata.
    fn validation_hash(&self) -> Option<[u8; 32]>;
}

/// An address which is generated by the static APIs.
pub struct StaticAddress<KeyParts, Value, HasDefaultValue, IsMap> {
    pallet_name: Cow<'static, str>,
    entry_name: Cow<'static, str>,
    validation_hash: Option<[u8; 32]>,
    marker: core::marker::PhantomData<(KeyParts, Value, HasDefaultValue, IsMap)>,
}

impl<KeyParts, Value, HasDefaultValue, IsMap> StaticAddress<KeyParts, Value, HasDefaultValue, IsMap> {
    /// Create a new [`StaticAddress`] using static strings for the pallet and call name.
    /// This is only expected to be used from codegen.
    #[doc(hidden)]
    pub fn new_static(
        pallet_name: &'static str,
        entry_name: &'static str,
        hash: [u8; 32],
    ) -> Self {
        Self {
            pallet_name: Cow::Borrowed(pallet_name),
            entry_name: Cow::Borrowed(entry_name),
            validation_hash: Some(hash),
            marker: core::marker::PhantomData,
        }
    }

    /// Create a new address.
    pub fn new(
        pallet_name: impl Into<Cow<'static, str>>,
        entry_name: impl Into<Cow<'static, str>>,
    ) -> Self {
        Self {
            pallet_name: pallet_name.into(),
            entry_name: entry_name.into(),
            validation_hash: None,
            marker: core::marker::PhantomData
        }
    }

    /// Do not validate this storage entry prior to accessing it.
    pub fn unvalidated(mut self) -> Self {
        self.validation_hash = None;
        self
    }
}

impl<KeyParts, Value, HasDefaultValue, IsMap> Address
    for StaticAddress<KeyParts, Value, HasDefaultValue, IsMap>
where
    KeyParts: IntoEncodableValues,
    Value: DecodeAsType,
    HasDefaultValue: YesNoMaybe,
{
    type KeyParts = KeyParts;
    type Value = Value;
    type HasDefaultValue = HasDefaultValue;
    type IsMap = IsMap;

    fn pallet_name(&self) -> &str {
        &self.pallet_name
    }

    fn entry_name(&self) -> &str {
        &self.entry_name
    }

    fn validation_hash(&self) -> Option<[u8; 32]> {
        self.validation_hash
    }
}

/// A dynamic address is simply a [`StaticAddress`] which asserts that the
/// entry *might* be a map and *might* have a default value.
pub type DynamicAddress<KeyParts = Vec<scale_value::Value>, Value = scale_value::Value> = StaticAddress<KeyParts, Value, Maybe, Maybe>;

/// Construct a new dynamic storage address. You can define the type of the
/// storage keys and value yourself here, but have no guarantee that they will
/// be correct.
pub fn dynamic<KeyParts: IntoEncodableValues, Value: DecodeAsType>(
    pallet_name: impl Into<Cow<'static, str>>,
    entry_name: impl Into<Cow<'static, str>>,
) -> DynamicAddress<KeyParts, Value> {
    DynamicAddress::<KeyParts, Value>::new(pallet_name, entry_name)
}

