#![feature(prelude_import)]
//! Subxt is a library for interacting with Substrate based nodes. Using it looks something like this:
//!
//! ```rust,ignore
/*!#![allow(missing_docs)]
use subxt::{OnlineClient, PolkadotConfig};
use subxt_signer::sr25519::dev;

// Generate an interface that we can use from the node's metadata.
#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a new API client, configured to talk to Polkadot nodes.
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Build a balance transfer extrinsic.
    let dest = dev::bob().public_key().into();
    let balance_transfer_tx = polkadot::tx().balances().transfer_allow_death(dest, 10_000);

    // Submit the balance transfer extrinsic from Alice, and wait for it to be successful
    // and in a finalized block. We get back the extrinsic events if all is well.
    let from = dev::alice();
    let events = api
        .tx()
        .sign_and_submit_then_watch_default(&balance_transfer_tx, &from)
        .await?
        .wait_for_finalized_success()
        .await?;

    // Find a Transfer event and print it.
    let transfer_event = events.find_first::<polkadot::balances::events::Transfer>()?;
    if let Some(event) = transfer_event {
        println!("Balance transfer success: {event:?}");
    }

    Ok(())
}
*/
//! ```
//!
//! Take a look at [the Subxt guide](book) to learn more about how to use Subxt.
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod book {
    //! # The Subxt Guide
    //!
    //! Subxt is a library for interacting with Substrate based nodes. It has a focus on **sub**mitting
    //! e**xt**rinsics, hence the name, however it's also capable of reading blocks, storage, events and
    //! constants from a node. The aim of this guide is to explain key concepts and get you started with
    //! using Subxt.
    //!
    //! 1. [Features](#features-at-a-glance)
    //! 2. [Limitations](#limitations)
    //! 3. [Quick start](#quick-start)
    //! 4. [Usage](#usage)
    //!
    //! ## Features at a glance
    //!
    //! Here's a quick overview of the features that Subxt has to offer:
    //!
    //! - Subxt allows you to generate a static, type safe interface to a node given some metadata; this
    //!   allows you to catch many errors at compile time rather than runtime.
    //! - Subxt also makes heavy use of node metadata to encode/decode the data sent to/from it. This
    //!   allows it to target almost any node which can output the correct metadata, and allows it some
    //!   flexibility in encoding and decoding things to account for cross-node differences.
    //! - Subxt has a pallet-oriented interface, meaning that code you write to talk to some pallet on
    //!   one node will often "Just Work" when pointed at different nodes that use the same pallet.
    //! - Subxt can work offline; you can generate and sign transactions, access constants from node
    //!   metadata and more, without a network connection. This is all checked at compile time, so you
    //!   can be certain it won't try to establish a network connection if you don't want it to.
    //! - Subxt can forego the statically generated interface and build transactions, storage queries
    //!   and constant queries using data provided at runtime, rather than queries constructed
    //!   statically.
    //! - Subxt can be compiled to WASM to run in the browser, allowing it to back Rust based browser
    //!   apps, or even bind to JS apps.
    //!
    //! ## Limitations
    //!
    //! In various places, you can provide a block hash to access data at a particular block, for
    //! instance:
    //!
    //! - [`crate::storage::StorageClient::at`]
    //! - [`crate::events::EventsClient::at`]
    //! - [`crate::blocks::BlocksClient::at`]
    //! - [`crate::runtime_api::RuntimeApiClient::at`]
    //!
    //! However, Subxt is (by default) only capable of properly working with blocks that were produced
    //! after the most recent runtime update. This is because it uses the most recent metadata given
    //! back by a node to encode and decode things. It's possible to decode older blocks produced by a
    //! runtime that emits compatible (currently, V14) metadata by manually setting the metadata used by
    //! the client using [`crate::client::OnlineClient::set_metadata()`].
    //!
    //! Subxt does not support working with blocks produced prior to the runtime update that introduces
    //! V14 metadata. It may have some success decoding older blocks using newer metadata, but may also
    //! completely fail to do so.
    //!
    //! ## Quick start
    //!
    //! Here is a simple but complete example of using Subxt to transfer some tokens from the example
    //! accounts, Alice to Bob:
    //!
    //! ```rust,ignore
    /*!#![allow(missing_docs)]
use subxt::{OnlineClient, PolkadotConfig};
use subxt_signer::sr25519::dev;

// Generate an interface that we can use from the node's metadata.
#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a new API client, configured to talk to Polkadot nodes.
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Build a balance transfer extrinsic.
    let dest = dev::bob().public_key().into();
    let balance_transfer_tx = polkadot::tx().balances().transfer_allow_death(dest, 10_000);

    // Submit the balance transfer extrinsic from Alice, and wait for it to be successful
    // and in a finalized block. We get back the extrinsic events if all is well.
    let from = dev::alice();
    let events = api
        .tx()
        .sign_and_submit_then_watch_default(&balance_transfer_tx, &from)
        .await?
        .wait_for_finalized_success()
        .await?;

    // Find a Transfer event and print it.
    let transfer_event = events.find_first::<polkadot::balances::events::Transfer>()?;
    if let Some(event) = transfer_event {
        println!("Balance transfer success: {event:?}");
    }

    Ok(())
}
*/
    //! ```
    //!
    //! This example assumes that a Polkadot node is running locally (Subxt endeavors to support all
    //! recent releases). Typically, to use Subxt to talk to some custom Substrate node (for example a
    //! parachain node), you'll want to:
    //!
    //! 1. [Generate an interface](setup::codegen)
    //! 2. [Create a config](setup::config)
    //! 3. [Use the config to instantiate the client](setup::client)
    //!
    //! Follow the above links to learn more about each step.
    //!
    //! ## Usage
    //!
    //! Once Subxt is configured, the next step is interacting with a node. Follow the links
    //! below to learn more about how to use Subxt for each of the following things:
    //!
    //! - [Transactions](usage::transactions): Subxt can build and submit transactions, wait until they are in
    //!   blocks, and retrieve the associated events.
    //! - [Storage](usage::storage): Subxt can query the node storage.
    //! - [Events](usage::events): Subxt can read the events emitted for recent blocks.
    //! - [Constants](usage::constants): Subxt can access the constant values stored in a node, which
    //!   remain the same for a given runtime version.
    //! - [Blocks](usage::blocks): Subxt can load recent blocks or subscribe to new/finalized blocks,
    //!   reading the extrinsics, events and storage at these blocks.
    //! - [Runtime APIs](usage::runtime_apis): Subxt can make calls into pallet runtime APIs to retrieve
    //!   data.
    //! - [Custom values](usage::custom_values): Subxt can access "custom values" stored in the metadata.
    //! - [Raw RPC calls](usage::rpc): Subxt can be used to make raw RPC requests to compatible nodes.
    //!
    //! ## Examples
    //!
    //! Some complete, self contained examples which are not a part of this guide:
    //!
    //! - [`parachain-example`](https://github.com/paritytech/subxt/tree/master/examples/parachain-example) is an example
    //!   which uses Zombienet to spawn a parachain locally, and then connects to it using Subxt.
    //! - [`wasm-example`](https://github.com/paritytech/subxt/tree/master/examples/wasm-example) is an example of writing
    //!   a Rust app that contains a Yew based UI, uses Subxt to interact with a chain, and compiles to WASM in order to
    //!   run entirely in the browser.
    pub mod setup {
        //! This modules contains details on setting up Subxt:
        //!
        //! - [Codegen](codegen)
        //! - [Client](client)
        //!
        //! Alternately, [go back](super).
        pub mod client {
            //! # The Subxt client.
            //!
            //! The client forms the entry point to all of the Subxt APIs. Every client implements one or
            //! both of [`crate::client::OfflineClientT`] and [`crate::client::OnlineClientT`].
            //!
            //! Subxt ships with three clients which implement one or both of traits:
            //! - An [online client](crate::client::OnlineClient).
            //! - An [offline client](crate::client::OfflineClient).
            //! - A light client (which is currently still unstable).
            //!
            //! In theory it's possible for users to implement their own clients, although this isn't generally
            //! expected.
            //!
            //! The provided clients are all generic over the [`crate::config::Config`] that they accept, which
            //! determines how they will interact with the chain.
            //!
            //! In the case of the [`crate::OnlineClient`], we have various ways to instantiate it:
            //!
            //! - [`crate::OnlineClient::new()`] to connect to a node running locally. This uses the default Subxt
            //!   backend, and the default RPC client.
            //! - [`crate::OnlineClient::from_url()`] to connect to a node at a specific URL. This uses the default Subxt
            //!   backend, and the default RPC client.
            //! - [`crate::OnlineClient::from_rpc_client()`] to instantiate the client with a [`crate::backend::rpc::RpcClient`].
            //! - [`crate::OnlineClient::from_backend()`] to instantiate Subxt using a custom backend. Currently there
            //!   is just one backend, [`crate::backend::legacy::LegacyBackend`]. This backend can be instantiated from
            //!   a [`crate::backend::rpc::RpcClient`].
            //!
            //! [`crate::backend::rpc::RpcClient`] can itself be instantiated from anything that implements the low level
            //! [`crate::backend::rpc::RpcClientT`] trait; this allows you to decide how Subxt will attempt to talk to a node
            //! if you'd prefer something other default client. We use this approach under the hood to implement the light client.
            //!
            //! ## Examples
            //!
            //! Most of the other examples will instantiate a client. Here are a couple of examples for less common
            //! cases.
            //!
            //! ### Writing a custom [`crate::backend::rpc::RpcClientT`] implementation:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use std::{
    fmt::Write,
    pin::Pin,
    sync::{Arc, Mutex},
};
use subxt::{
    backend::rpc::{RawRpcFuture, RawRpcSubscription, RawValue, RpcClient, RpcClientT},
    OnlineClient, PolkadotConfig,
};

// A dummy RPC client that doesn't actually handle requests properly
// at all, but instead just logs what requests to it were made.
struct MyLoggingClient {
    log: Arc<Mutex<String>>,
}

// We have to implement this fairly low level trait to turn [`MyLoggingClient`]
// into an RPC client that we can make use of in Subxt. Here we just log the requests
// made but don't forward them to any real node, and instead just return nonsense.
impl RpcClientT for MyLoggingClient {
    fn request_raw<'a>(
        &'a self,
        method: &'a str,
        params: Option<Box<RawValue>>,
    ) -> RawRpcFuture<'a, Box<RawValue>> {
        writeln!(
            self.log.lock().unwrap(),
            "{method}({})",
            params.as_ref().map(|p| p.get()).unwrap_or("[]")
        )
        .unwrap();

        // We've logged the request; just return garbage. Because a boxed future is returned,
        // you're able to run whatever async code you'd need to actually talk to a node.
        let res = RawValue::from_string("[]".to_string()).unwrap();
        Box::pin(std::future::ready(Ok(res)))
    }

    fn subscribe_raw<'a>(
        &'a self,
        sub: &'a str,
        params: Option<Box<RawValue>>,
        unsub: &'a str,
    ) -> RawRpcFuture<'a, RawRpcSubscription> {
        writeln!(
            self.log.lock().unwrap(),
            "{sub}({}) (unsub: {unsub})",
            params.as_ref().map(|p| p.get()).unwrap_or("[]")
        )
        .unwrap();

        // We've logged the request; just return garbage. Because a boxed future is returned,
        // and that will return a boxed Stream impl, you have a bunch of flexibility to build
        // and return whatever type of Stream you see fit.
        let res = RawValue::from_string("[]".to_string()).unwrap();
        let stream = futures::stream::once(async move { Ok(res) });
        let stream: Pin<Box<dyn futures::Stream<Item = _> + Send>> = Box::pin(stream);
        // This subscription does not provide an ID.
        Box::pin(std::future::ready(Ok(RawRpcSubscription {
            stream,
            id: None,
        })))
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Instantiate our replacement RPC client.
    let log = Arc::default();
    let rpc_client = {
        let inner = MyLoggingClient {
            log: Arc::clone(&log),
        };
        RpcClient::new(inner)
    };

    // Pass this into our OnlineClient to instantiate it. This will lead to some
    // RPC calls being made to fetch chain details/metadata, which will immediately
    // fail..
    let _ = OnlineClient::<PolkadotConfig>::from_rpc_client(rpc_client).await;

    // But, we can see that the calls were made via our custom RPC client:
    println!("Log of calls made:\n\n{}", log.lock().unwrap().as_str());
    Ok(())
}
*/
            //! ```
            //!
            //! ### Creating an [`crate::OfflineClient`]:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::ext::codec::Decode;
use subxt::metadata::Metadata;
use subxt::utils::H256;
use subxt::{config::PolkadotConfig, OfflineClient};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // We need to obtain the following details for an OfflineClient to be instantiated:

    // 1. Genesis hash (RPC call: chain_getBlockHash(0)):
    let genesis_hash = {
        let h = "91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3";
        let bytes = hex::decode(h).unwrap();
        H256::from_slice(&bytes)
    };

    // 2. A runtime version (system_version constant on a Substrate node has these):
    let runtime_version = subxt::backend::RuntimeVersion {
        spec_version: 9370,
        transaction_version: 20,
    };

    // 3. Metadata (I'll load it from the downloaded metadata, but you can use
    //    `subxt metadata > file.scale` to download it):
    let metadata = {
        let bytes = std::fs::read("./artifacts/polkadot_metadata_small.scale").unwrap();
        Metadata::decode(&mut &*bytes).unwrap()
    };

    // Create an offline client using the details obtained above:
    let _api = OfflineClient::<PolkadotConfig>::new(genesis_hash, runtime_version, metadata);

    Ok(())
}
*/
            //! ```
            //!
        }
        pub mod codegen {
            //! # Generating an interface
            //!
            //! The simplest way to use Subxt is to generate an interface to a chain that you'd like to interact
            //! with. This generated interface allows you to build transactions and construct queries to access
            //! data while leveraging the full type safety of the Rust compiler.
            //!
            //! ## The `#[subxt]` macro
            //!
            //! The most common way to generate the interface is to use the [`#[subxt]`](crate::subxt) macro.
            //! Using this macro looks something like:
            //!
            //! ```rust,no_run
            //! #[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_tiny.scale")]
            //! pub mod polkadot {}
            //! ```
            //!
            //! The macro takes a path to some node metadata, and uses that to generate the interface you'll use
            //! to talk to it. [Go here](crate::subxt) to learn more about the options available to the macro.
            //!
            //! To obtain this metadata you'll need for the above, you can use the `subxt` CLI tool to download it
            //! from a node. The tool can be installed via `cargo`:
            //!
            //! ```shell
            //! cargo install subxt-cli
            //! ```
            //!
            //! And then it can be used to fetch metadata and save it to a file:
            //!
            //! ```shell
            //! # Download and save all of the metadata:
            //! subxt metadata > metadata.scale
            //! # Download and save only the pallets you want to generate an interface for:
            //! subxt metadata --pallets Balances,System > metadata.scale
            //! ```
            //!
            //! Explicitly specifying pallets will cause the tool to strip out all unnecessary metadata and type
            //! information, making the bundle much smaller in the event that you only need to generate an
            //! interface for a subset of the available pallets on the node.
            //!
            //! ## The CLI tool
            //!
            //! Using the [`#[subxt]`](crate::subxt) macro carries some downsides:
            //!
            //! - Using it to generate an interface will have a small impact on compile times (though much less of
            //! one if you only need a few pallets).
            //! - IDE support for autocompletion and documentation when using the macro interface can be poor.
            //! - It's impossible to manually look at the generated code to understand and debug things.
            //!
            //! If these are an issue, you can manually generate the same code that the macro generates under the hood
            //! by using the `subxt codegen` command:
            //!
            //! ```shell
            //! # Install the CLI tool if you haven't already:
            //! cargo install subxt-cli
            //! # Generate and format rust code, saving it to `interface.rs`:
            //! subxt codegen | rustfmt > interface.rs
            //! ```
            //!
            //! Use `subxt codegen --help` for more options; many of the options available via the macro are
            //! also available via the CLI tool, such as the ability to substitute generated types for others,
            //! or strip out docs from the generated code.
            //!
        }
        pub mod config {
            //! # Creating a Config
            //!
            //! Subxt requires you to provide a type implementing [`crate::config::Config`] in order to connect to a node.
            //! The [`crate::config::Config`] trait for the most part mimics the `frame_system::Config` trait.
            //! For most use cases, you can just use one of the following Configs shipped with Subxt:
            //!
            //! - [`PolkadotConfig`](crate::config::PolkadotConfig) for talking to Polkadot nodes, and
            //! - [`SubstrateConfig`](crate::config::SubstrateConfig) for talking to generic nodes built with Substrate.
            //!
            //! # How to create a Config for a custom chain?
            //!
            //! Some chains may use config that is not compatible with our [`PolkadotConfig`](crate::config::PolkadotConfig) or
            //! [`SubstrateConfig`](crate::config::SubstrateConfig).
            //!
            //! We now walk through creating a custom [`crate::config::Config`] for a parachain, using the
            //! ["Statemint"](https://parachains.info/details/statemint) parachain, also known as "Asset Hub", as an example. It
            //! is currently (as of 2023-06-26) deployed on Polkadot and [Kusama (as "Statemine")](https://parachains.info/details/statemine).
            //!
            //! To construct a valid [`crate::config::Config`] implementation, we need to find out which types to use for `AccountId`, `Hasher`, etc.
            //! For this, we need to take a look at the source code of Statemint, which is currently a part of the [Cumulus Github repository](https://github.com/paritytech/cumulus).
            //! The crate defining the asset hub runtime can be found [here](https://github.com/paritytech/cumulus/tree/master/parachains/runtimes/assets/asset-hub-polkadot).
            //!
            //! ## `AccountId`, `Hash`, `Hasher` and `Header`
            //!
            //! For these config types, we need to find out where the parachain runtime implements the `frame_system::Config` trait.
            //! Look for a code fragment like `impl frame_system::Config for Runtime { ... }` In the source code.
            //! For Statemint it looks like [this](https://github.com/paritytech/cumulus/blob/e2b7ad2061824f490c08df27a922c64f50accd6b/parachains/runtimes/assets/asset-hub-polkadot/src/lib.rs#L179)
            //! at the time of writing. The `AccountId`, `Hash` and `Header` types of the [frame_system::pallet::Config](https://docs.rs/frame-system/latest/frame_system/pallet/trait.Config.html)
            //! correspond to the ones we want to use in our Subxt [crate::Config]. In the Case of Statemint (Asset Hub) they are:
            //!
            //! - AccountId: `sp_core::crypto::AccountId32`
            //! - Hash: `sp_core::H256`
            //! - Hasher (type `Hashing` in [frame_system::pallet::Config](https://docs.rs/frame-system/latest/frame_system/pallet/trait.Config.html)): `sp_runtime::traits::BlakeTwo256`
            //! - Header: `sp_runtime::generic::Header<u32, sp_runtime::traits::BlakeTwo256>`
            //!
            //! Subxt has its own versions of some of these types in order to avoid needing to pull in Substrate dependencies:
            //!
            //! - `sp_core::crypto::AccountId32` can be swapped with [`crate::utils::AccountId32`].
            //! - `sp_core::H256` is a re-export which subxt also provides as [`crate::config::substrate::H256`].
            //! - `sp_runtime::traits::BlakeTwo256` can be swapped with [`crate::config::substrate::BlakeTwo256`].
            //! - `sp_runtime::generic::Header` can be swapped with [`crate::config::substrate::SubstrateHeader`].
            //!
            //! Having a look at how those types are implemented can give some clues as to how to implement other custom types that
            //! you may need to use as part of your config.
            //!
            //! ## `Address`, `Signature`
            //!
            //! A Substrate runtime is typically constructed by using the [frame_support::construct_runtime](https://docs.rs/frame-support/latest/frame_support/macro.construct_runtime.html) macro.
            //! In this macro, we need to specify the type of an `UncheckedExtrinsic`. Most of the time, the `UncheckedExtrinsic` will be of the type
            //! `sp_runtime::generic::UncheckedExtrinsic<Address, RuntimeCall, Signature, SignedExtra>`.
            //! The generic parameters `Address` and `Signature` specified when declaring the `UncheckedExtrinsic` type
            //! are the types for `Address` and `Signature` we should use with our [crate::Config] implementation. This information can
            //! also be obtained from the metadata (see [`frame_metadata::v15::ExtrinsicMetadata`]). In case of Statemint (Polkadot Asset Hub)
            //! we see the following types being used in `UncheckedExtrinsic`:
            //!
            //! - Address: `sp_runtime::MultiAddress<Self::AccountId, ()>`
            //! - Signature: `sp_runtime::MultiSignature`
            //!
            //! As above, Subxt has its own versions of these types that can be used instead to avoid pulling in Substrate dependencies.
            //! Using the Subxt versions also makes interacting with generated code (which uses them in some places) a little nicer:
            //!
            //! - `sp_runtime::MultiAddress` can be swapped with [`crate::utils::MultiAddress`].
            //! - `sp_runtime::MultiSignature` can be swapped with [`crate::utils::MultiSignature`].
            //!
            //! ## ExtrinsicParams
            //!
            //! Chains each have a set of "signed extensions" configured. Signed extensions provide a means to extend how transactions
            //! work. Each signed extension can potentially encode some "extra" data which is sent along with a transaction, as well as some
            //! "additional" data which is included in the transaction signer payload, but not transmitted along with the transaction. On
            //! a node, signed extensions can then perform additional checks on the submitted transactions to ensure their validity.
            //!
            //! The `ExtrinsicParams` config type expects to be given an implementation of the [`crate::config::ExtrinsicParams`] trait.
            //! Implementations of the [`crate::config::ExtrinsicParams`] trait are handed some parameters from Subxt itself, and can
            //! accept arbitrary `OtherParams` from users, and are then expected to provide this "extra" and "additional" data when asked
            //! via the required [`crate::config::ExtrinsicParamsEncoder`] impl.
            //!
            //! **In most cases, the default [crate::config::DefaultExtrinsicParams] type will work**: it understands the "standard"
            //! signed extensions that are in use, and allows the user to provide things like a tip, and set the extrinsic mortality via
            //! [`crate::config::DefaultExtrinsicParamsBuilder`]. It will use the chain metadata to decide which signed extensions to use
            //! and in which order. It will return an error if the chain uses a signed extension which it doesn't know how to handle.
            //!
            //! If the chain uses novel signed extensions (or if you just wish to provide a different interface for users to configure
            //! transactions), you can either:
            //!
            //! 1. Implement a new signed extension and add it to the list.
            //! 2. Implement [`crate::config::DefaultExtrinsicParams`] from scratch.
            //!
            //! See below for examples of each.
            //!
            //! ### Finding out which signed extensions a chain is using.
            //!
            //! In either case, you'll want to find out which signed extensions a chain is using. This information can be obtained from
            //! the `SignedExtra` parameter of the `UncheckedExtrinsic` of your parachain, which will be a tuple of signed extensions.
            //! It can also be obtained from the metadata (see [`frame_metadata::v15::SignedExtensionMetadata`]).
            //!
            //! For statemint, the signed extensions look like
            //! [this](https://github.com/paritytech/cumulus/tree/master/parachains/runtimes/assets/asset-hub-polkadot/src/lib.rs#L779):
            //!
            //! ```rs
            //! pub type SignedExtra = (
            //!     frame_system::CheckNonZeroSender<Runtime>,
            //!     frame_system::CheckSpecVersion<Runtime>,
            //!     frame_system::CheckTxVersion<Runtime>,
            //!     frame_system::CheckGenesis<Runtime>,
            //!     frame_system::CheckEra<Runtime>,
            //!     frame_system::CheckNonce<Runtime>,
            //!     frame_system::CheckWeight<Runtime>,
            //!     pallet_asset_tx_payment::ChargeAssetTxPayment<Runtime>,
            //! );
            //! ```
            //!
            //! Each element of the `SignedExtra` tuple implements [codec::Encode] and `sp_runtime::traits::SignedExtension`
            //! which has an associated type `AdditionalSigned` that also implements [codec::Encode]. Let's look at the underlying types
            //! for each tuple element. All zero-sized types have been replaced by `()` for simplicity.
            //!
            //! | tuple element                                                                                                             | struct type                                                                                                                                              | `AdditionalSigned` type          |
            //! | ------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------- |
            //! | [`frame_system::CheckNonZeroSender`](https://docs.rs/frame-system/latest/frame_system/struct.CheckNonZeroSender.html)     | ()                                                                                                                                                       | ()                               |
            //! | [`frame_system::CheckSpecVersion`](https://docs.rs/frame-system/latest/frame_system/struct.CheckSpecVersion.html)         | ()                                                                                                                                                       | [u32]                            |
            //! | [`frame_system::CheckTxVersion`](https://docs.rs/frame-system/latest/frame_system/struct.CheckTxVersion.html)             | ()                                                                                                                                                       | [u32]                            |
            //! | [`frame_system::CheckGenesis`](https://docs.rs/frame-system/latest/frame_system/struct.CheckGenesis.html)                 | ()                                                                                                                                                       | `Config::Hash` = `sp_core::H256` |
            //! | [`frame_system::CheckMortality`](https://docs.rs/frame-system/latest/frame_system/struct.CheckMortality.html)             | `sp_runtime::generic::Era`                                                                                                                               | `Config::Hash` = `sp_core::H256` |
            //! | [`frame_system::CheckNonce`](https://docs.rs/frame-system/latest/frame_system/struct.CheckNonce.html)                     | `frame_system::pallet::Config::Index` = u32                                                                                                              | ()                               |
            //! | [`frame_system::CheckWeight`](https://docs.rs/frame-system/latest/frame_system/struct.CheckWeight.html)                   | ()                                                                                                                                                       | ()                               |
            //! | [`frame_system::ChargeAssetTxPayment`](https://docs.rs/frame-system/latest/frame_system/struct.ChargeAssetTxPayment.html) | [pallet_asset_tx_payment::ChargeAssetTxPayment](https://docs.rs/pallet-asset-tx-payment/latest/pallet_asset_tx_payment/struct.ChargeAssetTxPayment.html) | ()                               |
            //!
            //! All types in the `struct type` column make up the "extra" data that we're expected to provide. All types in the
            //! `AdditionalSigned` column make up the "additional" data that we're expected to provide. This information will be useful
            //! whether we want to implement [`crate::config::SignedExtension`] for a signed extension, or implement
            //! [`crate::config::ExtrinsicParams`] from scratch.
            //!
            //! As it happens, all of the signed extensions in the table are either already exported in [`crate::config::signed_extensions`],
            //! or they hand back no "additional" or "extra" data. In both of these cases, the default `ExtrinsicParams` configuration will
            //! work out of the box.
            //!
            //! ### Implementing and adding new signed extensions to the config
            //!
            //! If you do need to implement a novel signed extension, then you can implement [`crate::config::signed_extensions::SignedExtension`]
            //! on a custom type and place it into a new set of signed extensions, like so:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use codec::Encode;
use scale_encode::EncodeAsType;
use scale_info::PortableRegistry;
use subxt::client::OfflineClientT;
use subxt::config::signed_extensions;
use subxt::config::{
    Config, DefaultExtrinsicParamsBuilder, ExtrinsicParams, ExtrinsicParamsEncoder,
    ExtrinsicParamsError,
};
use subxt_signer::sr25519::dev;

#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod runtime {}

// We don't need to construct this at runtime,
// so an empty enum is appropriate:
#[derive(EncodeAsType)]
pub enum CustomConfig {}

impl Config for CustomConfig {
    type Hash = subxt::utils::H256;
    type AccountId = subxt::utils::AccountId32;
    type Address = subxt::utils::MultiAddress<Self::AccountId, ()>;
    type Signature = subxt::utils::MultiSignature;
    type Hasher = subxt::config::substrate::BlakeTwo256;
    type Header = subxt::config::substrate::SubstrateHeader<u32, Self::Hasher>;
    type ExtrinsicParams = signed_extensions::AnyOf<
        Self,
        (
            // Load in the existing signed extensions we're interested in
            // (if the extension isn't actually needed it'll just be ignored):
            signed_extensions::CheckSpecVersion,
            signed_extensions::CheckTxVersion,
            signed_extensions::CheckNonce,
            signed_extensions::CheckGenesis<Self>,
            signed_extensions::CheckMortality<Self>,
            signed_extensions::ChargeAssetTxPayment<Self>,
            signed_extensions::ChargeTransactionPayment,
            // And add a new one of our own:
            CustomSignedExtension,
        ),
    >;
    type AssetId = u32;
}

// Our custom signed extension doesn't do much:
pub struct CustomSignedExtension;

// Give the extension a name; this allows `AnyOf` to look it
// up in the chain metadata in order to know when and if to use it.
impl<T: Config> signed_extensions::SignedExtension<T> for CustomSignedExtension {
    type Decoded = ();
    fn matches(identifier: &str, _type_id: u32, _types: &PortableRegistry) -> bool {
        identifier == "CustomSignedExtension"
    }
}

// Gather together any params we need for our signed extension, here none.
impl<T: Config> ExtrinsicParams<T> for CustomSignedExtension {
    type OtherParams = ();

    fn new<Client: OfflineClientT<T>>(
        _nonce: u64,
        _client: Client,
        _other_params: Self::OtherParams,
    ) -> Result<Self, ExtrinsicParamsError> {
        Ok(CustomSignedExtension)
    }
}

// Encode whatever the extension needs to provide when asked:
impl ExtrinsicParamsEncoder for CustomSignedExtension {
    fn encode_extra_to(&self, v: &mut Vec<u8>) {
        "Hello".encode_to(v);
    }
    fn encode_additional_to(&self, v: &mut Vec<u8>) {
        true.encode_to(v)
    }
}

// When composing a tuple of signed extensions, the user parameters we need must
// be able to convert `Into` a tuple of corresponding `OtherParams`. Here, we just
// "hijack" the default param builder, but add the `OtherParams` (`()`) for our
// new signed extension at the end, to make the types line up. IN reality you may wish
// to construct an entirely new interface to provide the relevant `OtherParams`.
pub fn custom(
    params: DefaultExtrinsicParamsBuilder<CustomConfig>,
) -> <<CustomConfig as Config>::ExtrinsicParams as ExtrinsicParams<CustomConfig>>::OtherParams {
    let (a, b, c, d, e, f, g) = params.build();
    (a, b, c, d, e, f, g, ())
}

#[tokio::main]
async fn main() {
    // With the config defined, it can be handed to Subxt as follows:
    let client = subxt::OnlineClient::<CustomConfig>::new().await.unwrap();

    let tx_payload = runtime::tx().system().remark(b"Hello".to_vec());

    // Configure the tx params:
    let tx_config = DefaultExtrinsicParamsBuilder::new().tip(1234);

    // And provide them when submitting a transaction:
    let _ = client
        .tx()
        .sign_and_submit_then_watch(&tx_payload, &dev::alice(), custom(tx_config))
        .await;
}
*/
            //! ```
            //!
            //! ### Implementing [`crate::config::ExtrinsicParams`] from scratch
            //!
            //! Alternately, you are free to implement [`crate::config::ExtrinsicParams`] entirely from scratch if you know exactly what "extra" and`
            //! "additional" data your node needs and would prefer to craft your own interface.
            //!
            //! Let's see what this looks like (this config won't work on any real node):
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use codec::Encode;
use subxt::client::OfflineClientT;
use subxt::config::{Config, ExtrinsicParams, ExtrinsicParamsEncoder, ExtrinsicParamsError};
use subxt_signer::sr25519::dev;

#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale")]
pub mod runtime {}

// We don't need to construct this at runtime,
// so an empty enum is appropriate:
pub enum CustomConfig {}

impl Config for CustomConfig {
    type Hash = subxt::utils::H256;
    type AccountId = subxt::utils::AccountId32;
    type Address = subxt::utils::MultiAddress<Self::AccountId, ()>;
    type Signature = subxt::utils::MultiSignature;
    type Hasher = subxt::config::substrate::BlakeTwo256;
    type Header = subxt::config::substrate::SubstrateHeader<u32, Self::Hasher>;
    type ExtrinsicParams = CustomExtrinsicParams<Self>;
    type AssetId = u32;
}

// This represents some arbitrary (and nonsensical) custom parameters that
// will be attached to transaction extra and additional payloads:
pub struct CustomExtrinsicParams<T: Config> {
    genesis_hash: T::Hash,
    tip: u128,
    foo: bool,
}

// We can provide a "pretty" interface to allow users to provide these:
#[derive(Default)]
pub struct CustomExtrinsicParamsBuilder {
    tip: u128,
    foo: bool,
}

impl CustomExtrinsicParamsBuilder {
    pub fn new() -> Self {
        Default::default()
    }
    pub fn tip(mut self, value: u128) -> Self {
        self.tip = value;
        self
    }
    pub fn enable_foo(mut self) -> Self {
        self.foo = true;
        self
    }
}

// Describe how to fetch and then encode the params:
impl<T: Config> ExtrinsicParams<T> for CustomExtrinsicParams<T> {
    type OtherParams = CustomExtrinsicParamsBuilder;

    // Gather together all of the params we will need to encode:
    fn new<Client: OfflineClientT<T>>(
        _nonce: u64,
        client: Client,
        other_params: Self::OtherParams,
    ) -> Result<Self, ExtrinsicParamsError> {
        Ok(Self {
            genesis_hash: client.genesis_hash(),
            tip: other_params.tip,
            foo: other_params.foo,
        })
    }
}

// Encode the relevant params when asked:
impl<T: Config> ExtrinsicParamsEncoder for CustomExtrinsicParams<T> {
    fn encode_extra_to(&self, v: &mut Vec<u8>) {
        (self.tip, self.foo).encode_to(v);
    }
    fn encode_additional_to(&self, v: &mut Vec<u8>) {
        self.genesis_hash.encode_to(v)
    }
}

#[tokio::main]
async fn main() {
    // With the config defined, it can be handed to Subxt as follows:
    let client = subxt::OnlineClient::<CustomConfig>::new().await.unwrap();

    let tx_payload = runtime::tx().system().remark(b"Hello".to_vec());

    // Build your custom "OtherParams":
    let tx_config = CustomExtrinsicParamsBuilder::new().tip(1234).enable_foo();

    // And provide them when submitting a transaction:
    let _ = client
        .tx()
        .sign_and_submit_then_watch(&tx_payload, &dev::alice(), tx_config)
        .await;
}
*/
            //! ```
            //!
            //! ### Using a type from the metadata as a config parameter
            //!
            //! You can also use types that are generated from chain metadata as type parameters of the Config trait.
            //! Just make sure all trait bounds are satisfied. This can often be achieved by using custom derives with the subxt macro.
            //! For example, the AssetHub Parachain expects tips to include a `MultiLocation`, which is a type we can draw from the metadata.
            //!
            //! This example shows what using the `MultiLocation` struct as part of your config would look like in subxt:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::config::{
    Config, DefaultExtrinsicParams, DefaultExtrinsicParamsBuilder, PolkadotConfig, SubstrateConfig,
};
use subxt_signer::sr25519::dev;

#[subxt::subxt(
    runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale",
    derive_for_type(
        path = "xcm::v2::multilocation::MultiLocation",
        derive = "Clone",
        recursive
    )
)]
pub mod runtime {}
use runtime::runtime_types::xcm::v2::multilocation::{Junctions, MultiLocation};

// We don't need to construct this at runtime, so an empty enum is appropriate.
pub enum AssetHubConfig {}

impl Config for AssetHubConfig {
    type Hash = <SubstrateConfig as Config>::Hash;
    type AccountId = <SubstrateConfig as Config>::AccountId;
    type Address = <PolkadotConfig as Config>::Address;
    type Signature = <SubstrateConfig as Config>::Signature;
    type Hasher = <SubstrateConfig as Config>::Hasher;
    type Header = <SubstrateConfig as Config>::Header;
    type ExtrinsicParams = DefaultExtrinsicParams<AssetHubConfig>;
    // Here we use the MultiLocation from the metadata as a part of the config:
    // The `ChargeAssetTxPayment` signed extension that is part of the ExtrinsicParams above, now uses the type:
    type AssetId = MultiLocation;
}

#[tokio::main]
async fn main() {
    // With the config defined, we can create an extrinsic with subxt:
    let client = subxt::OnlineClient::<AssetHubConfig>::new().await.unwrap();
    let tx_payload = runtime::tx().system().remark(b"Hello".to_vec());

    // Build extrinsic params using an asset at this location as a tip:
    let location: MultiLocation = MultiLocation {
        parents: 3,
        interior: Junctions::Here,
    };
    let tx_config = DefaultExtrinsicParamsBuilder::<AssetHubConfig>::new()
        .tip_of(1234, location)
        .build();

    // And provide the extrinsic params including the tip when submitting a transaction:
    let _ = client
        .tx()
        .sign_and_submit_then_watch(&tx_payload, &dev::alice(), tx_config)
        .await;
}
*/
            //! ```
        }
    }
    pub mod usage {
        //! This modules contains examples of using Subxt; follow the links for more:
        //!
        //! - [Transactions](transactions)
        //! - [Storage](storage)
        //! - [Events](events)
        //! - [Constants](constants)
        //! - [Blocks](blocks)
        //! - [Runtime APIs](runtime_apis)
        //! - [Unstable Light Client](light_client)
        //! - [Custom Values](custom_values)
        //! - [RPC calls](rpc)
        //!
        //! Alternately, [go back](super).
        pub mod blocks {
            //! # Blocks
            //!
            //! The [blocks API](crate::blocks::BlocksClient) in Subxt unifies many of the other interfaces, and
            //! allows you to:
            //!
            //! - Access information about specific blocks (see [`crate::blocks::BlocksClient::at()`] and
            //!   [`crate::blocks::BlocksClient::at_latest()`]).
            //! - Subscribe to [all](crate::blocks::BlocksClient::subscribe_all()),
            //!   [best](crate::blocks::BlocksClient::subscribe_best()) or
            //!   [finalized](crate::blocks::BlocksClient::subscribe_finalized()) blocks as they are produced.
            //!   Prefer to subscribe to finalized blocks unless you know what you're doing.
            //!
            //! In either case, you'll end up with [`crate::blocks::Block`]'s, from which you can access various
            //! information about the block, such a the [header](crate::blocks::Block::header()), [block
            //! number](crate::blocks::Block::number()) and [body (the extrinsics)](crate::blocks::Block::extrinsics()).
            //! [`crate::blocks::Block`]'s also provide shortcuts to other Subxt APIs that will operate at the
            //! given block:
            //!
            //! - [storage](crate::blocks::Block::storage()),
            //! - [events](crate::blocks::Block::events())
            //! - [runtime APIs](crate::blocks::Block::runtime_api())
            //!
            //! Aside from these links to other Subxt APIs, the main thing that we can do here is iterate over and
            //! decode the extrinsics in a block body.
            //!
            //! ## Decoding Extrinsics
            //!
            //! Given a block, you can [download the block body](crate::blocks::Block::extrinsics()) and [iterate over
            //! the extrinsics](crate::blocks::Extrinsics::iter()) stored within it. The extrinsics yielded are of type
            //! [ExtrinsicDetails](crate::blocks::ExtrinsicDetails), which is just a blob of bytes that also stores which
            //! pallet and call in that pallet it belongs to. It also contains information about signed extensions that
            //! have been used for submitting this extrinsic.
            //!
            //! To use the extrinsic, you probably want to decode it into a concrete Rust type. These Rust types representing
            //! extrinsics from different pallets can be generated from metadata using the subxt macro or the CLI tool.
            //!
            //! When decoding the extrinsic into a static type you have two options:
            //!
            //! ### Statically decode the extrinsics into [the root extrinsic type](crate::blocks::ExtrinsicDetails::as_root_extrinsic())
            //!
            //! The root extrinsic type generated by subxt is a Rust enum with one variant for each pallet. Each of these
            //! variants has a field that is another enum whose variants cover all calls of the respective pallet.
            //! If the extrinsic bytes are valid and your metadata matches the chain's metadata, decoding the bytes of an extrinsic into
            //! this root extrinsic type should always succeed.
            //!
            //! This example shows how to subscribe to blocks and decode the extrinsics in each block into the root extrinsic type.
            //! Once we get hold of the [ExtrinsicDetails](crate::blocks::ExtrinsicDetails), we can decode it statically or dynamically.
            //! We can also access details about the extrinsic, including the associated events and signed extensions.
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{OnlineClient, PolkadotConfig};

#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a client to use:
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Subscribe to all finalized blocks:
    let mut blocks_sub = api.blocks().subscribe_finalized().await?;

    // For each block, print a bunch of information about it:
    while let Some(block) = blocks_sub.next().await {
        let block = block?;

        let block_number = block.header().number;
        let block_hash = block.hash();

        println!("Block #{block_number}:");
        println!("  Hash: {block_hash}");
        println!("  Extrinsics:");

        // Log each of the extrinsic with it's associated events:
        let extrinsics = block.extrinsics().await?;
        for ext in extrinsics.iter() {
            let ext = ext?;
            let idx = ext.index();
            let events = ext.events().await?;
            let bytes_hex = format!("0x{}", hex::encode(ext.bytes()));

            // See the API docs for more ways to decode extrinsics:
            let decoded_ext = ext.as_root_extrinsic::<polkadot::Call>();

            println!("    Extrinsic #{idx}:");
            println!("      Bytes: {bytes_hex}");
            println!("      Decoded: {decoded_ext:?}");

            println!("      Events:");
            for evt in events.iter() {
                let evt = evt?;
                let pallet_name = evt.pallet_name();
                let event_name = evt.variant_name();
                let event_values = evt.field_values()?;

                println!("        {pallet_name}_{event_name}");
                println!("          {}", event_values);
            }

            println!("      Signed Extensions:");
            if let Some(signed_extensions) = ext.signed_extensions() {
                for signed_extension in signed_extensions.iter() {
                    let signed_extension = signed_extension?;
                    let name = signed_extension.name();
                    let value = signed_extension.value()?.to_string();
                    println!("        {name}: {value}");
                }
            }
        }
    }

    Ok(())
}
*/
            //! ```
            //!
            //! ### Statically decode the extrinsic into [a specific pallet call](crate::blocks::ExtrinsicDetails::as_extrinsic())
            //!
            //! This is useful if you are expecting a specific extrinsic to be part of some block. If the extrinsic you try to decode
            //! is a different extrinsic, an `Ok(None)` value is returned from [`as_extrinsic::<T>()`](crate::blocks::ExtrinsicDetails::as_extrinsic());
            //!
            //! If you are only interested in finding specific extrinsics in a block, you can also [iterate over all of them](crate::blocks::Extrinsics::find),
            //! get only [the first one](crate::blocks::Extrinsics::find_first), or [the last one](crate::blocks::Extrinsics::find_last).
            //!
            //! The following example monitors `TransferKeepAlive` extrinsics on the Polkadot network.
            //! We statically decode them and access the [tip](crate::blocks::ExtrinsicSignedExtensions::tip()) and [account nonce](crate::blocks::ExtrinsicSignedExtensions::nonce()) signed extensions.
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{
    utils::{AccountId32, MultiAddress},
    OnlineClient, PolkadotConfig,
};

use codec::Decode;

#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

use polkadot::balances::calls::types::TransferKeepAlive;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a client that subscribes to blocks of the Polkadot network.
    let api = OnlineClient::<PolkadotConfig>::from_url("wss://rpc.polkadot.io:443").await?;

    // Subscribe to all finalized blocks:
    let mut blocks_sub = api.blocks().subscribe_finalized().await?;

    // For each block, print details about the `TransferKeepAlive` transactions we are interested in.
    while let Some(block) = blocks_sub.next().await {
        let block = block?;
        let block_number = block.header().number;
        let block_hash = block.hash();
        println!("Block #{block_number}  ({block_hash}):");

        let extrinsics = block.extrinsics().await?;
        for transfer in extrinsics.find::<TransferKeepAlive>() {
            let transfer = transfer?;

            let Some(extensions) = transfer.details.signed_extensions() else {
                panic!("TransferKeepAlive should be signed")
            };

            let addr_bytes = transfer
                .details
                .address_bytes()
                .expect("TransferKeepAlive should be signed");
            let sender = MultiAddress::<AccountId32, ()>::decode(&mut &addr_bytes[..])
                .expect("Decoding should work");
            let sender = display_address(&sender);
            let receiver = display_address(&transfer.value.dest);
            let value = transfer.value.value;
            let tip = extensions.tip().expect("Should have tip");
            let nonce = extensions.nonce().expect("Should have nonce");

            println!(
                    "    Transfer of {value} DOT:\n        {sender} (Tip: {tip}, Nonce: {nonce}) ---> {receiver}",
                );
        }
    }

    Ok(())
}

fn display_address(addr: &MultiAddress<AccountId32, ()>) -> String {
    if let MultiAddress::Id(id32) = addr {
        format!("{id32}")
    } else {
        "MultiAddress::...".into()
    }
}
*/
            //! ```
            //!
            //! ### Dynamically decode the extrinsic
            //!
            //! Sometimes you might use subxt with metadata that is not known at compile time. In this case, you do not have access to a statically generated
            //! interface module that contains the relevant Rust types. You can [decode ExtrinsicDetails dynamically](crate::blocks::ExtrinsicDetails::field_values()),
            //! which gives you access to it's fields as a [scale value composite](scale_value::Composite).
            //! The following example looks for signed extrinsics on the Polkadot network and retrieves their pallet name, variant name, data fields and signed extensions dynamically.
            //! Notice how we do not need to use code generation via the subxt macro. The only fixed component we provide is the [PolkadotConfig](crate::config::PolkadotConfig).
            //! Other than that it works in a chain-agnostic way:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{OnlineClient, PolkadotConfig};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a client that subscribes to blocks of the Polkadot network.
    let api = OnlineClient::<PolkadotConfig>::from_url("wss://rpc.polkadot.io:443").await?;

    // Subscribe to all finalized blocks:
    let mut blocks_sub = api.blocks().subscribe_finalized().await?;
    while let Some(block) = blocks_sub.next().await {
        let block = block?;
        let block_number = block.header().number;
        let block_hash = block.hash();
        println!("Block #{block_number}  ({block_hash})");

        // Decode each signed extrinsic in the block dynamically
        let extrinsics = block.extrinsics().await?;
        for ext in extrinsics.iter() {
            let ext = ext?;

            let Some(signed_extensions) = ext.signed_extensions() else {
                continue; // we do not look at inherents in this example
            };

            let meta = ext.extrinsic_metadata()?;
            let fields = ext.field_values()?;

            println!("  {}/{}", meta.pallet.name(), meta.variant.name);
            println!("    Signed Extensions:");
            for signed_ext in signed_extensions.iter() {
                let signed_ext = signed_ext?;
                // We only want to take a look at these 3 signed extensions, because the others all just have unit fields.
                if ["CheckMortality", "CheckNonce", "ChargeTransactionPayment"]
                    .contains(&signed_ext.name())
                {
                    println!("      {}: {}", signed_ext.name(), signed_ext.value()?);
                }
            }
            println!("    Fields:");
            println!("      {}\n", fields);
        }
    }

    Ok(())
}
*/
            //! ```
            //!
            //! ##  Decoding signed extensions
            //!
            //! Extrinsics can contain signed extensions. The signed extensions can be different across chains.
            //! The [Config](crate::Config) implementation for your chain defines which signed extensions you expect.
            //! Once you get hold of the [ExtrinsicDetails](crate::blocks::ExtrinsicDetails) for an extrinsic you are interested in,
            //! you can try to [get its signed extensions](crate::blocks::ExtrinsicDetails::signed_extensions()).
            //! These are only available on signed extrinsics. You can try to [find a specific signed extension](crate::blocks::ExtrinsicSignedExtensions::find),
            //! in the returned [signed extensions](crate::blocks::ExtrinsicSignedExtensions).
            //!
            //! Subxt also provides utility functions to get the [tip](crate::blocks::ExtrinsicSignedExtensions::tip()) and the
            //! [account nonce](crate::blocks::ExtrinsicSignedExtensions::tip()) associated with an extrinsic, given its signed extensions.
            //! If you prefer to do things dynamically you can get the data of the signed extension as a [scale value](crate::blocks::ExtrinsicSignedExtension::value()).
            //!
        }
        pub mod constants {
            //! # Constants
            //!
            //! There are various constants stored in a node; the types and values of these are defined in a
            //! runtime, and can only change when the runtime is updated. Much like [`super::storage`], we can
            //! query these using Subxt by taking the following steps:
            //!
            //! 1. [Constructing a constant query](#constructing-a-query).
            //! 2. [Submitting the query to get back the associated value](#submitting-it).
            //!
            //! ## Constructing a constant query
            //!
            //! We can use the statically generated interface to build constant queries:
            //!
            //! ```rust,no_run
            //! #[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale")]
            //! pub mod polkadot {}
            //!
            //! let constant_query = polkadot::constants().system().block_length();
            //! ```
            //!
            //! Alternately, we can dynamically construct a constant query:
            //!
            //! ```rust,no_run
            //! use subxt::dynamic::Value;
            //!
            //! let storage_query = subxt::dynamic::constant("System", "BlockLength");
            //! ```
            //!
            //! Static queries also have a static return type, so the constant is decoded appropriately. In
            //! addition, they are validated at runtime to ensure that they align with the current node state.
            //! Dynamic queries must be decoded into some static type manually, or into the dynamic
            //! [`crate::dynamic::Value`] type.
            //!
            //! ## Submitting it
            //!
            //! Constant queries are handed to Subxt via [`crate::constants::ConstantsClient::at()`]. It's worth
            //! noting that constant values are pulled directly out of the node metadata which Subxt has
            //! already acquired, and so this function requires no network access and is available from a
            //! [`crate::OfflineClient`].
            //!
            //! Here's an example using a static query:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{OnlineClient, PolkadotConfig};

#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a client to use:
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // A query to obtain some contant:
    let constant_query = polkadot::constants().system().block_length();

    // Obtain the value:
    let value = api.constants().at(&constant_query)?;

    println!("Block length: {value:?}");
    Ok(())
}
*/
            //! ```
            //!
            //! And here's one using a dynamic query:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{OnlineClient, PolkadotConfig};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a client to use:
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // A dynamic query to obtain some contant:
    let constant_query = subxt::dynamic::constant("System", "BlockLength");

    // Obtain the value:
    let value = api.constants().at(&constant_query)?;

    println!("Constant bytes: {:?}", value.encoded());
    println!("Constant value: {}", value.to_value()?);
    Ok(())
}
*/
            //! ```
            //!
        }
        pub mod custom_values {
            //! # Custom Values
            //!
            //! Substrate-based chains can expose custom values in their metadata.
            //! Each of these values:
            //!
            //! - can be accessed by a unique __name__.
            //! - refers to a concrete __type__ stored in the metadata.
            //! - contains a scale encoded __value__ of that type.
            //!
            //! ## Getting a custom value
            //!
            //! Custom values can be accessed via a [`CustomValuesClient`](crate::custom_values::CustomValuesClient).
            //! The client exposes an `at` function by which a custom value can be fetched, given an address to this custom value.
            //! An address can be as simple as the aforementioned __name__ as a [str]. This will return a dynamic value, that you can manually decode into the type you want.
            //! Suppose, the custom types contain a value of type `Foo` under the name `"foo"` you can access it like in this example:
            //!
            //! ```rust,ignore
            //! use subxt::{OnlineClient, PolkadotConfig, ext::{codec::Decode, scale_decode::DecodeAsType}};
            //!
            //! #[derive(Decode, DecodeAsType, Debug)]
            //! struct Foo {
            //!     n: u8,
            //!     b: bool,
            //! }
            //!
            //! let api = OnlineClient::<PolkadotConfig>::new().await?;
            //! let custom_value_client = api.custom_values();
            //! let foo_dynamic = custom_value_client.at("foo")?;
            //! let foo: Foo = foo_dynamic.as_type()?;
            //!
            //! ```
            //!
            //! Alternatively we also provide a statically generated api for custom values:
            //!
            //! ```rust,ignore
            //! #[subxt::subxt(runtime_metadata_path = "some_metadata.scale")]
            //! pub mod interface {}
            //!
            //! let static_address = interface::custom().foo();
            //!
            //! let api = OnlineClient::<PolkadotConfig>::new().await?;
            //! let custom_value_client = api.custom_values();
            //!
            //! // Now the `at()` function already decodes the value into the Foo type:
            //! let foo = custom_value_client.at(&static_address)?;
            //! ```
            //!
            //! Note: Names of custom values are converted to __snake_case__ to produce a valid function name during code generation.
            //! If there are multiple values where the names would be equal when converted to __snake_case__, functions might not be statically generated for some of them, because of naming conflicts.
            //! Make sure names in the custom values of your metadata differ significantly.
        }
        pub mod events {
            //! # Events
            //!
            //! In the process of adding extrinsics to a block, they are executed. When extrinsics are executed,
            //! they normally produce events describing what's happening (at the very least, an event dictating whether
            //! the extrinsic has succeeded or failed). The node may also emit some events of its own as the block is
            //! processed.
            //!
            //! Events live in a single location in node storage which is overwritten at each block. Normal nodes tend to
            //! keep a snapshot of the state at a small number of previous blocks, so you can sometimes access
            //! older events by using [`crate::events::EventsClient::at()`] and providing an older block hash.
            //!
            //! When we submit transactions using Subxt, methods like [`crate::tx::TxProgress::wait_for_finalized_success()`]
            //! return [`crate::blocks::ExtrinsicEvents`], which can be used to iterate and inspect the events produced
            //! by that transaction being executed. We can also access _all_ of the events produced in a single block using one
            //! of these two interfaces:
            //!
            //! ```rust,no_run
            //! # #[tokio::main]
            //! # async fn main() -> Result<(), Box<dyn std::error::Error>> {
            //! use subxt::client::OnlineClient;
            //! use subxt::config::PolkadotConfig;
            //!
            //! // Create client:
            //! let client = OnlineClient::<PolkadotConfig>::new().await?;
            //!
            //! // Get events from the latest block (use .at() to specify a block hash):
            //! let events = client.blocks().at_latest().await?.events().await?;
            //! // We can use this shorthand too:
            //! let events = client.events().at_latest().await?;
            //! # Ok(())
            //! # }
            //! ```
            //!
            //! Once we've loaded our events, we can iterate all events or search for specific events via
            //! methods like [`crate::events::Events::iter()`] and [`crate::events::Events::find()`]. See
            //! [`crate::events::Events`] and [`crate::events::EventDetails`] for more information.
            //!
            //! ## Example
            //!
            //! Here's an example which puts this all together:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{OnlineClient, PolkadotConfig};

#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a client to use:
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Get events for the latest block:
    let events = api.events().at_latest().await?;

    // We can dynamically decode events:
    println!("Dynamic event details:");
    for event in events.iter() {
        let event = event?;

        let pallet = event.pallet_name();
        let variant = event.variant_name();
        let field_values = event.field_values()?;

        println!("{pallet}::{variant}: {field_values}");
    }

    // Or we can attempt to statically decode them into the root Event type:
    println!("Static event details:");
    for event in events.iter() {
        let event = event?;

        if let Ok(ev) = event.as_root_event::<polkadot::Event>() {
            println!("{ev:?}");
        } else {
            println!("<Cannot decode event>");
        }
    }

    // Or we can look for specific events which match our statically defined ones:
    let transfer_event = events.find_first::<polkadot::balances::events::Transfer>()?;
    if let Some(ev) = transfer_event {
        println!("  - Balance transfer success: value: {:?}", ev.amount);
    } else {
        println!("  - No balance transfer event found in this block");
    }

    Ok(())
}
*/
            //! ```
            //!
        }
        pub mod light_client {
            //! # Light Client
            //!
            //! The light client based interface uses _Smoldot_ to connect to a _chain_, rather than an individual
            //! node. This means that you don't have to trust a specific node when interacting with some chain.
            //!
            //! This feature is currently unstable. Use the `unstable-light-client` feature flag to enable it.
            //! To use this in WASM environments, also enable the `web` feature flag.
            //!
            //! To connect to a blockchain network, the Light Client requires a trusted sync state of the network,
            //! known as a _chain spec_. One way to obtain this is by making a `sync_state_genSyncSpec` RPC call to a
            //! trusted node belonging to the chain that you wish to interact with.
            //!
            //! The following is an example of fetching the chain spec from a local running node on port 9933:
            //!
            //! ```bash
            //! curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "sync_state_genSyncSpec", "params":[true]}' http://localhost:9933/ | jq .result > chain_spec.json
            //! ```
            //!
            //! Alternately, you can have the `LightClient` download the chain spec from a trusted node when it
            //! initializes, which is not recommended in production but is useful for examples and testing, as below.
            //!
            //! ## Examples
            //!
            //! ### Basic Example
            //!
            //! This example connects to a local chain and submits a transaction. To run this, you first need
            //! to have a local polkadot node running using the following command:
            //!
            //! ```text
            //! polkadot --dev --node-key 0000000000000000000000000000000000000000000000000000000000000001
            //! ```
            //!
            //! Leave that running for a minute, and then you can run the example using the following command
            //! in the `subxt` crate:
            //!
            //! ```bash
            //! cargo run --example light_client_tx_basic --features=unstable-light-client
            //! ```
            //!
            //! This is the code that will be executed:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{client::LightClient, PolkadotConfig};
use subxt_signer::sr25519::dev;

// Generate an interface that we can use from the node's metadata.
#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // The smoldot logs are informative:
    tracing_subscriber::fmt::init();

    // Create a light client by fetching the chain spec of a local running node.
    // In this case, because we start one single node, the bootnodes must be overwritten
    // for the light client to connect to the local node.
    //
    // The `12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp` is the P2P address
    // from a local polkadot node starting with
    // `--node-key 0000000000000000000000000000000000000000000000000000000000000001`
    let api = LightClient::<PolkadotConfig>::builder()
        .bootnodes([
            "/ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp",
        ])
        .build_from_url("ws://127.0.0.1:9944")
        .await?;

    // Build a balance transfer extrinsic.
    let dest = dev::bob().public_key().into();
    let balance_transfer_tx = polkadot::tx().balances().transfer_allow_death(dest, 10_000);

    // Submit the balance transfer extrinsic from Alice, and wait for it to be successful
    // and in a finalized block. We get back the extrinsic events if all is well.
    let from = dev::alice();
    let events = api
        .tx()
        .sign_and_submit_then_watch_default(&balance_transfer_tx, &from)
        .await?
        .wait_for_finalized_success()
        .await?;

    // Find a Transfer event and print it.
    let transfer_event = events.find_first::<polkadot::balances::events::Transfer>()?;
    if let Some(event) = transfer_event {
        println!("Balance transfer success: {event:?}");
    }

    Ok(())
}
*/
            //! ```
            //!
            //! ### Connecting to a parachain
            //!
            //! This example connects to a parachain using the light client. Currently, it's quite verbose to do this.
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use futures::StreamExt;
use std::{iter, num::NonZeroU32};
use subxt::{
    client::{LightClient, RawLightClient},
    PolkadotConfig,
};

// Generate an interface that we can use from the node's metadata.
#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

const POLKADOT_SPEC: &str = include_str!("../../artifacts/demo_chain_specs/polkadot.json");
const ASSET_HUB_SPEC: &str =
    include_str!("../../artifacts/demo_chain_specs/polkadot_asset_hub.json");

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // The smoldot logs are informative:
    tracing_subscriber::fmt::init();

    // Connecting to a parachain is a multi step process.

    // Step 1. Construct a new smoldot client.
    let mut client =
        subxt_lightclient::smoldot::Client::new(subxt_lightclient::smoldot::DefaultPlatform::new(
            "subxt-example-light-client".into(),
            "version-0".into(),
        ));

    // Step 2. Connect to the relay chain of the parachain. For this example, the Polkadot relay chain.
    let polkadot_connection = client
        .add_chain(subxt_lightclient::smoldot::AddChainConfig {
            specification: POLKADOT_SPEC,
            json_rpc: subxt_lightclient::smoldot::AddChainConfigJsonRpc::Enabled {
                max_pending_requests: NonZeroU32::new(128).unwrap(),
                max_subscriptions: 1024,
            },
            potential_relay_chains: iter::empty(),
            database_content: "",
            user_data: (),
        })
        .expect("Light client chain added with valid spec; qed");
    let polkadot_json_rpc_responses = polkadot_connection
        .json_rpc_responses
        .expect("Light client configured with json rpc enabled; qed");
    let polkadot_chain_id = polkadot_connection.chain_id;

    // Step 3. Connect to the parachain. For this example, the Asset hub parachain.
    let assethub_connection = client
        .add_chain(subxt_lightclient::smoldot::AddChainConfig {
            specification: ASSET_HUB_SPEC,
            json_rpc: subxt_lightclient::smoldot::AddChainConfigJsonRpc::Enabled {
                max_pending_requests: NonZeroU32::new(128).unwrap(),
                max_subscriptions: 1024,
            },
            // The chain specification of the asset hub parachain mentions that the identifier
            // of its relay chain is `polkadot`.
            potential_relay_chains: [polkadot_chain_id].into_iter(),
            database_content: "",
            user_data: (),
        })
        .expect("Light client chain added with valid spec; qed");
    let parachain_json_rpc_responses = assethub_connection
        .json_rpc_responses
        .expect("Light client configured with json rpc enabled; qed");
    let parachain_chain_id = assethub_connection.chain_id;

    // Step 4. Turn the smoldot client into a raw client.
    let raw_light_client = RawLightClient::builder()
        .add_chain(polkadot_chain_id, polkadot_json_rpc_responses)
        .add_chain(parachain_chain_id, parachain_json_rpc_responses)
        .build(client)
        .await?;

    // Step 5. Obtain a client to target the relay chain and the parachain.
    let polkadot_api: LightClient<PolkadotConfig> =
        raw_light_client.for_chain(polkadot_chain_id).await?;
    let parachain_api: LightClient<PolkadotConfig> =
        raw_light_client.for_chain(parachain_chain_id).await?;

    // Step 6. Subscribe to the finalized blocks of the chains.
    let polkadot_sub = polkadot_api
        .blocks()
        .subscribe_finalized()
        .await?
        .map(|block| ("Polkadot", block));
    let parachain_sub = parachain_api
        .blocks()
        .subscribe_finalized()
        .await?
        .map(|block| ("AssetHub", block));
    let mut stream_combinator = futures::stream::select(polkadot_sub, parachain_sub);

    while let Some((chain, block)) = stream_combinator.next().await {
        let block = block?;

        println!("     Chain {:?} hash={:?}", chain, block.hash());
    }

    Ok(())
}
*/
            //! ```
        }
        pub mod rpc {
            //! # RPC calls
            //!
            //! Subxt exposes low level interfaces that can be used to make RPC requests; [`crate::backend::legacy::rpc_methods`]
            //! and [`crate::backend::unstable::rpc_methods`].
            //!
            //! These interfaces cannot be accessed directly through an [`crate::OnlineClient`]; this is so that the high level
            //! Subxt APIs can target either the "legacy" or the more modern "unstable" sets of RPC methods by selecting an appropriate
            //! [`crate::backend::Backend`]. It also means that there could exist a backend in the future that doesn't use JSON-RPC at all.
            //!
            //! # Example
            //!
            //! Here's an example which calls some legacy JSON-RPC methods, and reuses the same connection to run a full Subxt client
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::backend::{legacy::LegacyRpcMethods, rpc::RpcClient};
use subxt::config::DefaultExtrinsicParamsBuilder as Params;
use subxt::{OnlineClient, PolkadotConfig};
use subxt_signer::sr25519::dev;

#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // First, create a raw RPC client:
    let rpc_client = RpcClient::from_url("ws://127.0.0.1:9944").await?;

    // Use this to construct our RPC methods:
    let rpc = LegacyRpcMethods::<PolkadotConfig>::new(rpc_client.clone());

    // We can use the same client to drive our full Subxt interface too:
    let api = OnlineClient::<PolkadotConfig>::from_rpc_client(rpc_client.clone()).await?;

    // Now, we can make some RPC calls using some legacy RPC methods.
    println!(
        " System Name: {:?}\n Health: {:?}\n Properties: {:?}\n Chain: {:?}\n",
        rpc.system_name().await?,
        rpc.system_health().await?,
        rpc.system_properties().await?,
        rpc.system_chain().await?
    );

    // We can also interleave RPC calls and using the full Subxt client, here to submit multiple
    // transactions using the legacy `system_account_next_index` RPC call, which returns a nonce
    // that is adjusted for any transactions already in the pool:

    let alice = dev::alice();
    let bob = dev::bob();

    loop {
        let current_nonce = rpc
            .system_account_next_index(&alice.public_key().into())
            .await?;
        let current_header = rpc.chain_get_header(None).await?.unwrap();

        let ext_params = Params::new().mortal(&current_header, 8).build();

        let balance_transfer = polkadot::tx()
            .balances()
            .transfer_allow_death(bob.public_key().into(), 1_000_000);

        let ext_hash = api
            .tx()
            .create_signed_with_nonce(&balance_transfer, &alice, current_nonce, ext_params)?
            .submit()
            .await?;

        println!("Submitted ext {ext_hash} with nonce {current_nonce}");

        // Sleep less than block time, but long enough to ensure
        // not all transactions end up in the same block.
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    }
}
*/
            //! ```
        }
        pub mod runtime_apis {
            //! # Runtime API interface
            //!
            //! The Runtime API interface allows Subxt to call runtime APIs exposed by certain pallets in order
            //! to obtain information. Much like [`super::storage`] and [`super::transactions`], Making a runtime
            //! call to a node and getting the response back takes the following steps:
            //!
            //! 1. [Constructing a runtime call](#constructing-a-runtime-call)
            //! 2. [Submitting it to get back the response](#submitting-it)
            //!
            //! **Note:** Runtime APIs are only available when using V15 metadata, which is currently unstable.
            //! You'll need to use `subxt metadata --version unstable` command to download the unstable V15 metadata,
            //! and activate the `unstable-metadata` feature in Subxt for it to also use this metadata from a node. The
            //! metadata format is unstable because it may change and break compatibility with Subxt at any moment, so
            //! use at your own risk.
            //!
            //! ## Constructing a runtime call
            //!
            //! We can use the statically generated interface to build runtime calls:
            //!
            //! ```rust,no_run
            //! #[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
            //! pub mod polkadot {}
            //!
            //! let runtime_call = polkadot::apis().metadata().metadata_versions();
            //! ```
            //!
            //! Alternately, we can dynamically construct a runtime call:
            //!
            //! ```rust,no_run
            //! use subxt::dynamic::Value;
            //!
            //! let runtime_call = subxt::dynamic::runtime_api_call(
            //!     "Metadata",
            //!     "metadata_versions",
            //!     Vec::<Value<()>>::new()
            //! );
            //! ```
            //!
            //! All valid runtime calls implement [`crate::runtime_api::RuntimeApiPayload`], a trait which
            //! describes how to encode the runtime call arguments and what return type to decode from the
            //! response.
            //!
            //! ## Submitting it
            //!
            //! Runtime calls can be handed to [`crate::runtime_api::RuntimeApi::call()`], which will submit
            //! them and hand back the associated response.
            //!
            //! ### Making a static Runtime API call
            //!
            //! The easiest way to make a runtime API call is to use the statically generated interface.
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{config::PolkadotConfig, OnlineClient};
use subxt_signer::sr25519::dev;

#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a client to use:
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Create a runtime API payload that calls into
    // `AccountNonceApi_account_nonce` function.
    let account = dev::alice().public_key().into();
    let runtime_api_call = polkadot::apis().account_nonce_api().account_nonce(account);

    // Submit the call and get back a result.
    let nonce = api
        .runtime_api()
        .at_latest()
        .await?
        .call(runtime_api_call)
        .await;

    println!("AccountNonceApi_account_nonce for Alice: {:?}", nonce);
    Ok(())
}
*/
            //! ```
            //!
            //! ### Making a dynamic Runtime API call
            //!
            //! If you'd prefer to construct the call at runtime, you can do this using the
            //! [`crate::dynamic::runtime_api_call`] method.
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::dynamic::Value;
use subxt::{config::PolkadotConfig, OnlineClient};
use subxt_signer::sr25519::dev;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a client to use:
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Create a dynamically runtime API payload that calls the
    // `AccountNonceApi_account_nonce` function.
    let account = dev::alice().public_key();
    let runtime_api_call = subxt::dynamic::runtime_api_call(
        "AccountNonceApi",
        "account_nonce",
        vec![Value::from_bytes(account)],
    );

    // Submit the call to get back a result.
    let nonce = api
        .runtime_api()
        .at_latest()
        .await?
        .call(runtime_api_call)
        .await?;

    println!("Account nonce: {:#?}", nonce.to_value());
    Ok(())
}
*/
            //! ```
            //!
            //! ### Making a raw call
            //!
            //! This is generally discouraged in favour of one of the above, but may be necessary (especially if
            //! the node you're talking to does not yet serve V15 metadata). Here, you must manually encode
            //! the argument bytes and manually provide a type for the response bytes to be decoded into.
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::ext::codec::Compact;
use subxt::ext::frame_metadata::RuntimeMetadataPrefixed;
use subxt::{OnlineClient, PolkadotConfig};

#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a client to use:
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Use runtime APIs at the latest block:
    let runtime_apis = api.runtime_api().at_latest().await?;

    // Ask for metadata and decode it:
    let (_, meta): (Compact<u32>, RuntimeMetadataPrefixed) =
        runtime_apis.call_raw("Metadata_metadata", None).await?;

    println!("{meta:?}");
    Ok(())
}
*/
            //! ```
            //!
        }
        pub mod storage {
            //! # Storage
            //!
            //! A Substrate based chain can be seen as a key/value database which starts off at some initial
            //! state, and is modified by the extrinsics in each block. This database is referred to as the
            //! node storage. With Subxt, you can query this key/value storage with the following steps:
            //!
            //! 1. [Constructing a storage query](#constructing-a-storage-query).
            //! 2. [Submitting the query to get back the associated values](#submitting-it).
            //!
            //! ## Constructing a storage query
            //!
            //! We can use the statically generated interface to build storage queries:
            //!
            //! ```rust,no_run
            //! use subxt_signer::sr25519::dev;
            //!
            //! #[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
            //! pub mod polkadot {}
            //!
            //! let account = dev::alice().public_key().into();
            //! let storage_query = polkadot::storage().system().account(&account);
            //! ```
            //!
            //! Alternately, we can dynamically construct a storage query. This will not be type checked or
            //! validated until it's submitted:
            //!
            //! ```rust,no_run
            //! use subxt_signer::sr25519::dev;
            //! use subxt::dynamic::Value;
            //!
            //! let account = dev::alice().public_key();
            //! let storage_query = subxt::dynamic::storage("System", "Account", vec![
            //!     Value::from_bytes(account)
            //! ]);
            //! ```
            //!
            //! As well as accessing specific entries, some storage locations can also be iterated over (such as
            //! the map of account information). To do this, suffix `_iter` onto the query constructor (this
            //! will only be available on static constructors when iteration is actually possible):
            //!
            //! ```rust,no_run
            //! #[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
            //! pub mod polkadot {}
            //!
            //! // A static query capable of iterating over accounts:
            //! let storage_query = polkadot::storage().system().account_iter();
            //! // A dynamic query to do the same:
            //! let storage_query = subxt::dynamic::storage("System", "Account", ());
            //! ```
            //!
            //! Some storage entries are maps with multiple keys. As an example, we might end up with
            //! an API like `runtime::storage().foo().bar(u8, bool, u16, String)` to fetch some entry "bar".
            //! When this is the case, the codegen will generate multiple iterator query functions alongside
            //! the function to fetch an individual value:
            //!
            //! - `runtime::storage().foo().bar(u8, bool, u16, String)`: fetch a single entry from the "bar" map.
            //! - `runtime::storage().foo().bar_iter()`: iterate over all of the entries in the "bar" map.
            //! - `runtime::storage().foo().bar_iter1(u8)`: iterate over all of the entries in the "bar" map under
            //!   a given `u8`.
            //! - `runtime::storage().foo().bar_iter2(u8, bool)`: iterate over all of the entries in the "bar" map under
            //!   a given `u8` and `bool` value.
            //! - `runtime::storage().foo().bar_iter3(u8, bool, u16)`: iterate over all of the entries in the "bar" map under
            //!   a given `u8`, `bool` and `u16` value.
            //!
            //! All valid storage queries implement [`crate::storage::StorageAddress`]. As well as describing
            //! how to build a valid storage query, this trait also has some associated types that determine the
            //! shape of the result you'll get back, and determine what you can do with it (ie, can you iterate
            //! over storage entries using it).
            //!
            //! Static queries set appropriate values for these associated types, and can therefore only be used
            //! where it makes sense. Dynamic queries don't know any better and can be used in more places, but
            //! may fail at runtime instead if they are invalid in those places.
            //!
            //! ## Submitting it
            //!
            //! Storage queries can be handed to various functions in [`crate::storage::Storage`] in order to
            //! obtain the associated values (also referred to as storage entries) back.
            //!
            //! ### Fetching storage entries
            //!
            //! The simplest way to access storage entries is to construct a query and then call either
            //! [`crate::storage::Storage::fetch()`] or [`crate::storage::Storage::fetch_or_default()`] (the
            //! latter will only work for storage queries that have a default value when empty):
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{OnlineClient, PolkadotConfig};
use subxt_signer::sr25519::dev;

// Generate an interface that we can use from the node's metadata.
#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a new API client, configured to talk to Polkadot nodes.
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Build a storage query to access account information.
    let account = dev::alice().public_key().into();
    let storage_query = polkadot::storage().system().account(&account);

    // Use that query to `fetch` a result. This returns an `Option<_>`, which will be
    // `None` if no value exists at the given address. You can also use `fetch_default`
    // where applicable, which will return the default value if none exists.
    let result = api
        .storage()
        .at_latest()
        .await?
        .fetch(&storage_query)
        .await?;

    println!("Alice has free balance: {}", result.unwrap().data.free);
    Ok(())
}
*/
            //! ```
            //!
            //! For completeness, below is an example using a dynamic query instead. The return type from a
            //! dynamic query is a [`crate::dynamic::DecodedValueThunk`], which can be decoded into a
            //! [`crate::dynamic::Value`], or else the raw bytes can be accessed instead.
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::dynamic::{At, Value};
use subxt::{OnlineClient, PolkadotConfig};
use subxt_signer::sr25519::dev;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a new API client, configured to talk to Polkadot nodes.
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Build a dynamic storage query to access account information.
    let account = dev::alice().public_key();
    let storage_query =
        subxt::dynamic::storage("System", "Account", vec![Value::from_bytes(account)]);

    // Use that query to `fetch` a result. Because the query is dynamic, we don't know what the result
    // type will be either, and so we get a type back that can be decoded into a dynamic Value type.
    let result = api
        .storage()
        .at_latest()
        .await?
        .fetch(&storage_query)
        .await?;
    let value = result.unwrap().to_value()?;

    println!("Alice has free balance: {:?}", value.at("data").at("free"));
    Ok(())
}
*/
            //! ```
            //!
            //! ### Iterating storage entries
            //!
            //! Many storage entries are maps of values; as well as fetching individual values, it's possible to
            //! iterate over all of the values stored at that location:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{OnlineClient, PolkadotConfig};

#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a new API client, configured to talk to Polkadot nodes.
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Build a storage query to iterate over account information.
    let storage_query = polkadot::storage().system().account_iter();

    // Get back an iterator of results (here, we are fetching 10 items at
    // a time from the node, but we always iterate over one at a time).
    let mut results = api.storage().at_latest().await?.iter(storage_query).await?;

    while let Some(Ok(kv)) = results.next().await {
        println!("Keys decoded: {:?}", kv.keys);
        println!("Key: 0x{}", hex::encode(&kv.key_bytes));
        println!("Value: {:?}", kv.value);
    }

    Ok(())
}
*/
            //! ```
            //!
            //! Here's the same logic but using dynamically constructed values instead:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{OnlineClient, PolkadotConfig};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a new API client, configured to talk to Polkadot nodes.
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Build a dynamic storage query to iterate account information.
    // With a dynamic query, we can just provide an empty vector as the keys to iterate over all entries.
    let keys: Vec<scale_value::Value> = vec![];
    let storage_query = subxt::dynamic::storage("System", "Account", keys);

    // Use that query to return an iterator over the results.
    let mut results = api.storage().at_latest().await?.iter(storage_query).await?;

    while let Some(Ok(kv)) = results.next().await {
        println!("Keys decoded: {:?}", kv.keys);
        println!("Key: 0x{}", hex::encode(&kv.key_bytes));
        println!("Value: {:?}", kv.value.to_value()?);
    }

    Ok(())
}
*/
            //! ```
            //!
            //! Here is an example of iterating over partial keys. In this example some multi-signature operations
            //! are sent to the node. We can iterate over the pending multisig operations of a single multisig account:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use polkadot::multisig::events::NewMultisig;
use polkadot::runtime_types::{
    frame_system::pallet::Call, rococo_runtime::RuntimeCall, sp_weights::weight_v2::Weight,
};
use subxt::utils::AccountId32;
use subxt::{OnlineClient, PolkadotConfig};
use subxt_signer::sr25519::{dev, Keypair};

#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a new API client, configured to talk to Polkadot nodes.
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Prepare the chain to have 3 open multisig requests (2 of them are alice + bob):
    let alice_signer = dev::alice();
    let bob = AccountId32(dev::bob().public_key().0);
    let charlie = AccountId32(dev::charlie().public_key().0);

    let new_multisig_1 = submit_remark_as_multi(&alice_signer, &bob, b"Hello", &api).await?;
    let new_multisig_2 = submit_remark_as_multi(&alice_signer, &bob, b"Hi", &api).await?;
    let new_multisig_3 = submit_remark_as_multi(&alice_signer, &charlie, b"Hello", &api).await?;

    // Note: the NewMultisig event contains the multisig address we need to use for the storage queries:
    assert_eq!(new_multisig_1.multisig, new_multisig_2.multisig);
    assert_ne!(new_multisig_1.multisig, new_multisig_3.multisig);

    // Build a storage query to iterate over open multisig extrinsics from
    // new_multisig_1.multisig which is the AccountId of the alice + bob multisig account
    let alice_bob_account_id = &new_multisig_1.multisig;
    let storage_query = polkadot::storage()
        .multisig()
        .multisigs_iter1(alice_bob_account_id);

    // Get back an iterator of results.
    let mut results = api.storage().at_latest().await?.iter(storage_query).await?;

    while let Some(Ok(kv)) = results.next().await {
        println!("Keys decoded: {:?}", kv.keys);
        println!("Key: 0x{}", hex::encode(&kv.key_bytes));
        println!("Value: {:?}", kv.value);
    }
    Ok(())
}

async fn submit_remark_as_multi(
    signer: &Keypair,
    other: &AccountId32,
    remark: &[u8],
    api: &OnlineClient<PolkadotConfig>,
) -> Result<NewMultisig, Box<dyn std::error::Error>> {
    let multisig_remark_tx = polkadot::tx().multisig().as_multi(
        2,
        vec![other.clone()],
        None,
        RuntimeCall::System(Call::remark {
            remark: remark.to_vec(),
        }),
        Weight {
            ref_time: 0,
            proof_size: 0,
        },
    );
    let events = api
        .tx()
        .sign_and_submit_then_watch_default(&multisig_remark_tx, signer)
        .await?
        .wait_for_finalized_success()
        .await?;
    let new_multisig = events
        .find_first::<polkadot::multisig::events::NewMultisig>()?
        .expect("should contain event");
    Ok(new_multisig)
}
*/
            //! ```
            //!
            //! ### Advanced
            //!
            //! For more advanced use cases, have a look at [`crate::storage::Storage::fetch_raw`] and
            //! [`crate::storage::Storage::fetch_raw_keys`]. Both of these take raw bytes as arguments, which can be
            //! obtained from a [`crate::storage::StorageAddress`] by using
            //! [`crate::storage::StorageClient::address_bytes()`] or
            //! [`crate::storage::StorageClient::address_root_bytes()`].
            //!
        }
        pub mod transactions {
            //! # Transactions
            //!
            //! A transaction is an extrinsic that's signed (ie it originates from a given address). The purpose
            //! of extrinsics is to modify the node storage in a deterministic way, and so being able to submit
            //! transactions to a node is one of the core features of Subxt.
            //!
            //! > Note: the documentation tends to use the terms _extrinsic_ and _transaction_ interchangeably;
            //! > An extrinsic is some data that can be added to a block, and is either signed (a _transaction_)
            //! > or unsigned (an _inherent_). Subxt can construct either, but overwhelmingly you'll need to
            //! > sign the payload you'd like to submit.
            //!
            //! Submitting a transaction to a node consists of the following steps:
            //!
            //! 1. [Constructing a transaction payload to submit](#constructing-a-transaction-payload).
            //! 2. [Signing it](#signing-it).
            //! 3. [Submitting it (optionally with some additional parameters)](#submitting-it).
            //!
            //! We'll look at each of these steps in turn.
            //!
            //! ## Constructing a transaction payload
            //!
            //! We can use the statically generated interface to build transaction payloads:
            //!
            //! ```rust,no_run
            //! #[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
            //! pub mod polkadot {}
            //!
            //! let remark = "Hello there".as_bytes().to_vec();
            //! let tx_payload = polkadot::tx().system().remark(remark);
            //! ```
            //!
            //! > If you're not sure what types to import and use to build a given payload, you can use the
            //! > `subxt` CLI tool to generate the interface by using something like `subxt codegen | rustfmt >
            //! > interface.rs`, to see what types and things are available (or even just to use directly
            //! > instead of the [`#[subxt]`](crate::subxt) macro).
            //!
            //! Alternately, we can dynamically construct a transaction payload. This will not be type checked or
            //! validated until it's submitted:
            //!
            //! ```rust,no_run
            //! use subxt::dynamic::Value;
            //!
            //! let tx_payload = subxt::dynamic::tx("System", "remark", vec![
            //!     Value::from_bytes("Hello there")
            //! ]);
            //! ```
            //!
            //! The [`crate::dynamic::Value`] type is a dynamic type much like a `serde_json::Value` but instead
            //! represents any type of data that can be SCALE encoded or decoded. It can be serialized,
            //! deserialized and parsed from/to strings.
            //!
            //! A valid transaction payload is just something that implements the [`crate::tx::TxPayload`] trait;
            //! you can implement this trait on your own custom types if the built-in ones are not suitable for
            //! your needs.
            //!
            //! ## Signing it
            //!
            //! You'll normally need to sign an extrinsic to prove that it originated from an account that you
            //! control. To do this, you will typically first create a [`crate::tx::Signer`] instance, which tells
            //! Subxt who the extrinsic is from, and takes care of signing the relevant details to prove this.
            //!
            //! There are two main ways to create a compatible signer instance:
            //! 1. The `subxt_signer` crate provides a WASM compatible implementation of [`crate::tx::Signer`]
            //! for chains which require sr25519 or ecdsa signatures (requires the `subxt` feature to be enabled).
            //! 2. Alternately, Subxt can use instances of Substrate's `sp_core::Pair` to sign things by wrapping
            //! them in a `crate::tx::PairSigner` (requires the `substrate-compat` feature to be enabled).
            //!
            //! Going for 1 leads to fewer dependencies being imported and WASM compatibility out of the box via
            //! the `web` feature flag. Going for 2 is useful if you're already using the Substrate dependencies or
            //! need additional signing algorithms that `subxt_signer` doesn't support, and don't care about WASM
            //! compatibility.
            //!
            //! Let's see how to use each of these approaches:
            //!
            //! ```rust
            //! # #[cfg(feature = "substrate-compat")]
            //! # {
            //! use subxt::config::PolkadotConfig;
            //! use std::str::FromStr;
            //!
            //! //// 1. Use a `subxt_signer` impl:
            //! use subxt_signer::{ SecretUri, sr25519 };
            //!
            //! // Get hold of a `Signer` for a test account:
            //! let alice = sr25519::dev::alice();
            //!
            //! // Or generate a keypair, here from an SURI:
            //! let uri = SecretUri::from_str("vessel ladder alter error federal sibling chat ability sun glass valve picture/0/1///Password")
            //!     .expect("valid URI");
            //! let keypair = sr25519::Keypair::from_uri(&uri)
            //!     .expect("valid keypair");
            //!
            //! //// 2. Use the corresponding `sp_core::Pair` impl:
            //! use subxt::tx::PairSigner;
            //! use sp_core::Pair;
            //!
            //! // Get hold of a `Signer` for a test account:
            //! let alice = sp_keyring::AccountKeyring::Alice.pair();
            //! let alice = PairSigner::<PolkadotConfig,_>::new(alice);
            //!
            //! // Or generate a keypair, here from an SURI:
            //! let keypair = sp_core::sr25519::Pair::from_string("vessel ladder alter error federal sibling chat ability sun glass valve picture/0/1///Password", None)
            //!     .expect("valid URI");
            //! let keypair = PairSigner::<PolkadotConfig,_>::new(keypair);
            //! #
            //! # // Test that these all impl Signer trait while we're here:
            //! #
            //! # fn is_subxt_signer(_signer: impl subxt::tx::Signer<PolkadotConfig>) {}
            //! # is_subxt_signer(subxt_signer::sr25519::dev::alice());
            //! # is_subxt_signer(subxt_signer::ecdsa::dev::alice());
            //! # is_subxt_signer(PairSigner::<PolkadotConfig,_>::new(sp_keyring::AccountKeyring::Alice.pair()));
            //! # }
            //! ```
            //!
            //! See the `subxt_signer` crate or the `sp_core::Pair` docs for more ways to construct
            //! and work with key pairs.
            //!
            //! If this isn't suitable/available, you can either implement [`crate::tx::Signer`] yourself to use
            //! custom signing logic, or you can use some external signing logic, like so:
            //!
            //! ```rust,no_run
            //! # #[tokio::main]
            //! # async fn main() -> Result<(), Box<dyn std::error::Error>> {
            //! use subxt::client::OnlineClient;
            //! use subxt::config::PolkadotConfig;
            //! use subxt::dynamic::Value;
            //!
            //! // Create client:
            //! let client = OnlineClient::<PolkadotConfig>::new().await?;
            //!
            //! // Create a dummy tx payload to sign:
            //! let payload = subxt::dynamic::tx("System", "remark", vec![
            //!     Value::from_bytes("Hello there")
            //! ]);
            //!
            //! // Construct the tx but don't sign it. You need to provide the nonce
            //! // here, or can use `create_partial_signed` to fetch the correct nonce.
            //! let partial_tx = client.tx().create_partial_signed_with_nonce(
            //!     &payload,
            //!     0u64,
            //!     Default::default()
            //! )?;
            //!
            //! // Fetch the payload that needs to be signed:
            //! let signer_payload = partial_tx.signer_payload();
            //!
            //! // ... At this point, we can hand off the `signer_payload` to be signed externally.
            //! // Ultimately we need to be given back a `signature` (or really, anything
            //! // that can be SCALE encoded) and an `address`:
            //! let signature;
            //! let address;
            //! # use subxt::tx::Signer;
            //! # let signer = subxt_signer::sr25519::dev::alice();
            //! # signature = signer.sign(&signer_payload).into();
            //! # address = signer.public_key().to_address();
            //!
            //! // Now we can build an tx, which one can call `submit` or `submit_and_watch`
            //! // on to submit to a node and optionally watch the status.
            //! let tx = partial_tx.sign_with_address_and_signature(
            //!     &address,
            //!     &signature
            //! );
            //! # Ok(())
            //! # }
            //! ```
            //!
            //! ## Submitting it
            //!
            //! Once we have signed the transaction, we need to submit it.
            //!
            //! ### The high level API
            //!
            //! The highest level approach to doing this is to call
            //! [`crate::tx::TxClient::sign_and_submit_then_watch_default`]. This hands back a
            //! [`crate::tx::TxProgress`] struct which will monitor the transaction status. We can then call
            //! [`crate::tx::TxProgress::wait_for_finalized_success()`] to wait for this transaction to make it
            //! into a finalized block, check for an `ExtrinsicSuccess` event, and then hand back the events for
            //! inspection. This looks like:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{OnlineClient, PolkadotConfig};
use subxt_signer::sr25519::dev;

// Generate an interface that we can use from the node's metadata.
#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a new API client, configured to talk to Polkadot nodes.
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Build a balance transfer extrinsic.
    let dest = dev::bob().public_key().into();
    let balance_transfer_tx = polkadot::tx().balances().transfer_allow_death(dest, 10_000);

    // Submit the balance transfer extrinsic from Alice, and wait for it to be successful
    // and in a finalized block. We get back the extrinsic events if all is well.
    let from = dev::alice();
    let events = api
        .tx()
        .sign_and_submit_then_watch_default(&balance_transfer_tx, &from)
        .await?
        .wait_for_finalized_success()
        .await?;

    // Find a Transfer event and print it.
    let transfer_event = events.find_first::<polkadot::balances::events::Transfer>()?;
    if let Some(event) = transfer_event {
        println!("Balance transfer success: {event:?}");
    }

    Ok(())
}
*/
            //! ```
            //!
            //! ### Providing transaction parameters
            //!
            //! If you'd like to provide parameters (such as mortality) to the transaction, you can use
            //! [`crate::tx::TxClient::sign_and_submit_then_watch`] instead:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::config::polkadot::PolkadotExtrinsicParamsBuilder as Params;
use subxt::{OnlineClient, PolkadotConfig};
use subxt_signer::sr25519::dev;

#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a new API client, configured to talk to Polkadot nodes.
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Build a balance transfer extrinsic.
    let dest = dev::bob().public_key().into();
    let tx = polkadot::tx().balances().transfer_allow_death(dest, 10_000);

    let latest_block = api.blocks().at_latest().await?;

    // Configure the transaction parameters; we give a small tip and set the
    // transaction to live for 32 blocks from the `latest_block` above.
    let tx_params = Params::new()
        .tip(1_000)
        .mortal(latest_block.header(), 32)
        .build();

    // submit the transaction:
    let from = dev::alice();
    let hash = api.tx().sign_and_submit(&tx, &from, tx_params).await?;
    println!("Balance transfer extrinsic submitted with hash : {hash}");

    Ok(())
}
*/
            //! ```
            //!
            //! This example doesn't wait for the transaction to be included in a block; it just submits it and
            //! hopes for the best!
            //!
            //! ### Custom handling of transaction status updates
            //!
            //! If you'd like more control or visibility over exactly which status updates are being emitted for
            //! the transaction, you can monitor them as they are emitted and react however you choose:
            //!
            //! ```rust,ignore
            /*!#![allow(missing_docs)]
use subxt::{tx::TxStatus, OnlineClient, PolkadotConfig};
use subxt_signer::sr25519::dev;

// Generate an interface that we can use from the node's metadata.
#[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_small.scale")]
pub mod polkadot {}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a new API client, configured to talk to Polkadot nodes.
    let api = OnlineClient::<PolkadotConfig>::new().await?;

    // Build a balance transfer extrinsic.
    let dest = dev::bob().public_key().into();
    let balance_transfer_tx = polkadot::tx().balances().transfer_allow_death(dest, 10_000);

    // Submit the balance transfer extrinsic from Alice, and then monitor the
    // progress of it.
    let from = dev::alice();
    let mut balance_transfer_progress = api
        .tx()
        .sign_and_submit_then_watch_default(&balance_transfer_tx, &from)
        .await?;

    while let Some(status) = balance_transfer_progress.next().await {
        match status? {
            // It's finalized in a block!
            TxStatus::InFinalizedBlock(in_block) => {
                println!(
                    "Transaction {:?} is finalized in block {:?}",
                    in_block.extrinsic_hash(),
                    in_block.block_hash()
                );

                // grab the events and fail if no ExtrinsicSuccess event seen:
                let events = in_block.wait_for_success().await?;
                // We can look for events (this uses the static interface; we can also iterate
                // over them and dynamically decode them):
                let transfer_event = events.find_first::<polkadot::balances::events::Transfer>()?;

                if let Some(event) = transfer_event {
                    println!("Balance transfer success: {event:?}");
                } else {
                    println!("Failed to find Balances::Transfer Event");
                }
            }
            // Just log any other status we encounter:
            other => {
                println!("Status: {other:?}");
            }
        }
    }
    Ok(())
}
*/
            //! ```
            //!
            //! Take a look at the API docs for [`crate::tx::TxProgress`], [`crate::tx::TxStatus`] and
            //! [`crate::tx::TxInBlock`] for more options.
            //!
        }
    }
}
pub mod backend {
    //! This module exposes a backend trait for Subxt which allows us to get and set
    //! the necessary information (probably from a JSON-RPC API, but that's up to the
    //! implementation).
    pub mod legacy {
        //! This module exposes a legacy backend implementation, which relies
        //! on the legacy RPC API methods.
        pub mod rpc_methods {
            //! An interface to call the raw legacy RPC methods.
            use crate::backend::rpc::{rpc_params, RpcClient, RpcSubscription};
            use crate::metadata::Metadata;
            use crate::{Config, Error};
            use codec::Decode;
            use derivative::Derivative;
            use primitive_types::U256;
            use serde::{Deserialize, Serialize};
            /// An interface to call the legacy RPC methods. This interface is instantiated with
            /// some `T: Config` trait which determines some of the types that the RPC methods will
            /// take or hand back.
            #[derivative(Clone(bound = ""), Debug(bound = ""))]
            pub struct LegacyRpcMethods<T> {
                client: RpcClient,
                _marker: std::marker::PhantomData<T>,
            }
            #[allow(unused_qualifications)]
            impl<T> ::std::clone::Clone for LegacyRpcMethods<T> {
                fn clone(&self) -> Self {
                    match *self {
                        LegacyRpcMethods {
                            client: ref __arg_0,
                            _marker: ref __arg_1,
                        } => {
                            LegacyRpcMethods {
                                client: (*__arg_0).clone(),
                                _marker: (*__arg_1).clone(),
                            }
                        }
                    }
                }
            }
            #[allow(unused_qualifications)]
            #[allow(clippy::unneeded_field_pattern)]
            impl<T> ::std::fmt::Debug for LegacyRpcMethods<T> {
                fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    match *self {
                        LegacyRpcMethods {
                            client: ref __arg_0,
                            _marker: ref __arg_1,
                        } => {
                            let mut __debug_trait_builder = __f
                                .debug_struct("LegacyRpcMethods");
                            let _ = __debug_trait_builder.field("client", &&(*__arg_0));
                            let _ = __debug_trait_builder.field("_marker", &&(*__arg_1));
                            __debug_trait_builder.finish()
                        }
                    }
                }
            }
            impl<T: Config> LegacyRpcMethods<T> {
                /// Instantiate the legacy RPC method interface.
                pub fn new(client: RpcClient) -> Self {
                    LegacyRpcMethods {
                        client,
                        _marker: std::marker::PhantomData,
                    }
                }
                /// Fetch the raw bytes for a given storage key
                pub async fn state_get_storage(
                    &self,
                    key: &[u8],
                    hash: Option<T::Hash>,
                ) -> Result<Option<StorageKey>, Error> {
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(to_hex(key))
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                            .push(hash)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    let data: Option<Bytes> = self
                        .client
                        .request("state_getStorage", params)
                        .await?;
                    Ok(data.map(|b| b.0))
                }
                /// Returns the keys with prefix with pagination support.
                /// Up to `count` keys will be returned.
                /// If `start_key` is passed, return next keys in storage in lexicographic order.
                pub async fn state_get_keys_paged(
                    &self,
                    key: &[u8],
                    count: u32,
                    start_key: Option<&[u8]>,
                    at: Option<T::Hash>,
                ) -> Result<Vec<StorageData>, Error> {
                    let start_key = start_key.map(to_hex);
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(to_hex(key))
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                            .push(count)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                            .push(start_key)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                            .push(at)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    let data: Vec<Bytes> = self
                        .client
                        .request("state_getKeysPaged", params)
                        .await?;
                    Ok(data.into_iter().map(|b| b.0).collect())
                }
                /// Query historical storage entries in the range from the start block to the end block,
                /// defaulting the end block to the current best block if it's not given. The first
                /// [`StorageChangeSet`] returned has all of the values for each key, and subsequent ones
                /// only contain values for any keys which have changed since the last.
                pub async fn state_query_storage(
                    &self,
                    keys: impl IntoIterator<Item = &[u8]>,
                    from: T::Hash,
                    to: Option<T::Hash>,
                ) -> Result<Vec<StorageChangeSet<T::Hash>>, Error> {
                    let keys: Vec<String> = keys.into_iter().map(to_hex).collect();
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(keys)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                            .push(from)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                            .push(to)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    self.client
                        .request("state_queryStorage", params)
                        .await
                        .map_err(Into::into)
                }
                /// Query storage entries at some block, using the best block if none is given.
                /// This essentially provides a way to ask for a batch of values given a batch of keys,
                /// despite the name of the [`StorageChangeSet`] type.
                pub async fn state_query_storage_at(
                    &self,
                    keys: impl IntoIterator<Item = &[u8]>,
                    at: Option<T::Hash>,
                ) -> Result<Vec<StorageChangeSet<T::Hash>>, Error> {
                    let keys: Vec<String> = keys.into_iter().map(to_hex).collect();
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(keys)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                            .push(at)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    self.client
                        .request("state_queryStorageAt", params)
                        .await
                        .map_err(Into::into)
                }
                /// Fetch the genesis hash
                pub async fn genesis_hash(&self) -> Result<T::Hash, Error> {
                    let block_zero = 0u32;
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(block_zero)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    let genesis_hash: Option<T::Hash> = self
                        .client
                        .request("chain_getBlockHash", params)
                        .await?;
                    genesis_hash.ok_or_else(|| "Genesis hash not found".into())
                }
                /// Fetch the metadata via the legacy `state_getMetadata` RPC method.
                pub async fn state_get_metadata(
                    &self,
                    at: Option<T::Hash>,
                ) -> Result<Metadata, Error> {
                    let bytes: Bytes = self
                        .client
                        .request(
                            "state_getMetadata",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                                    .push(at)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                            },
                        )
                        .await?;
                    let metadata = Metadata::decode(&mut &bytes[..])?;
                    Ok(metadata)
                }
                /// Fetch system health
                pub async fn system_health(&self) -> Result<SystemHealth, Error> {
                    self.client
                        .request(
                            "system_health",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                        )
                        .await
                }
                /// Fetch system chain
                pub async fn system_chain(&self) -> Result<String, Error> {
                    self.client
                        .request(
                            "system_chain",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                        )
                        .await
                }
                /// Fetch system name
                pub async fn system_name(&self) -> Result<String, Error> {
                    self.client
                        .request(
                            "system_name",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                        )
                        .await
                }
                /// Fetch system version
                pub async fn system_version(&self) -> Result<String, Error> {
                    self.client
                        .request(
                            "system_version",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                        )
                        .await
                }
                /// Fetch system properties
                pub async fn system_properties(
                    &self,
                ) -> Result<SystemProperties, Error> {
                    self.client
                        .request(
                            "system_properties",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                        )
                        .await
                }
                /// Fetch next nonce for an Account
                ///
                /// Return account nonce adjusted for extrinsics currently in transaction pool
                pub async fn system_account_next_index(
                    &self,
                    account_id: &T::AccountId,
                ) -> Result<u64, Error>
                where
                    T::AccountId: Serialize,
                {
                    self.client
                        .request(
                            "system_accountNextIndex",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                                    .push(&account_id)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                            },
                        )
                        .await
                }
                /// Get a header
                pub async fn chain_get_header(
                    &self,
                    hash: Option<T::Hash>,
                ) -> Result<Option<T::Header>, Error> {
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(hash)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    let header = self.client.request("chain_getHeader", params).await?;
                    Ok(header)
                }
                /// Get a block hash, returns hash of latest _best_ block by default.
                pub async fn chain_get_block_hash(
                    &self,
                    block_number: Option<BlockNumber>,
                ) -> Result<Option<T::Hash>, Error> {
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(block_number)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    let block_hash = self
                        .client
                        .request("chain_getBlockHash", params)
                        .await?;
                    Ok(block_hash)
                }
                /// Get a block hash of the latest finalized block
                pub async fn chain_get_finalized_head(&self) -> Result<T::Hash, Error> {
                    let hash = self
                        .client
                        .request(
                            "chain_getFinalizedHead",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                        )
                        .await?;
                    Ok(hash)
                }
                /// Get a Block
                pub async fn chain_get_block(
                    &self,
                    hash: Option<T::Hash>,
                ) -> Result<Option<BlockDetails<T>>, Error> {
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(hash)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    let block = self.client.request("chain_getBlock", params).await?;
                    Ok(block)
                }
                /// Reexecute the specified `block_hash` and gather statistics while doing so.
                ///
                /// This function requires the specified block and its parent to be available
                /// at the queried node. If either the specified block or the parent is pruned,
                /// this function will return `None`.
                pub async fn dev_get_block_stats(
                    &self,
                    block_hash: T::Hash,
                ) -> Result<Option<BlockStats>, Error> {
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(block_hash)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    let stats = self.client.request("dev_getBlockStats", params).await?;
                    Ok(stats)
                }
                /// Get proof of storage entries at a specific block's state.
                pub async fn state_get_read_proof(
                    &self,
                    keys: impl IntoIterator<Item = &[u8]>,
                    hash: Option<T::Hash>,
                ) -> Result<ReadProof<T::Hash>, Error> {
                    let keys: Vec<String> = keys.into_iter().map(to_hex).collect();
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(keys)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                            .push(hash)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    let proof = self.client.request("state_getReadProof", params).await?;
                    Ok(proof)
                }
                /// Fetch the runtime version
                pub async fn state_get_runtime_version(
                    &self,
                    at: Option<T::Hash>,
                ) -> Result<RuntimeVersion, Error> {
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(at)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    let version = self
                        .client
                        .request("state_getRuntimeVersion", params)
                        .await?;
                    Ok(version)
                }
                /// Subscribe to all new best block headers.
                pub async fn chain_subscribe_new_heads(
                    &self,
                ) -> Result<RpcSubscription<T::Header>, Error> {
                    let subscription = self
                        .client
                        .subscribe(
                            "chain_subscribeNewHeads",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                            "chain_unsubscribeNewHeads",
                        )
                        .await?;
                    Ok(subscription)
                }
                /// Subscribe to all new block headers.
                pub async fn chain_subscribe_all_heads(
                    &self,
                ) -> Result<RpcSubscription<T::Header>, Error> {
                    let subscription = self
                        .client
                        .subscribe(
                            "chain_subscribeAllHeads",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                            "chain_unsubscribeAllHeads",
                        )
                        .await?;
                    Ok(subscription)
                }
                /// Subscribe to finalized block headers.
                ///
                /// Note: this may not produce _every_ block in the finalized chain;
                /// sometimes multiple blocks are finalized at once, and in this case only the
                /// latest one is returned. the higher level APIs that use this "fill in" the
                /// gaps for us.
                pub async fn chain_subscribe_finalized_heads(
                    &self,
                ) -> Result<RpcSubscription<T::Header>, Error> {
                    let subscription = self
                        .client
                        .subscribe(
                            "chain_subscribeFinalizedHeads",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                            "chain_unsubscribeFinalizedHeads",
                        )
                        .await?;
                    Ok(subscription)
                }
                /// Subscribe to runtime version updates that produce changes in the metadata.
                /// The first item emitted by the stream is the current runtime version.
                pub async fn state_subscribe_runtime_version(
                    &self,
                ) -> Result<RpcSubscription<RuntimeVersion>, Error> {
                    let subscription = self
                        .client
                        .subscribe(
                            "state_subscribeRuntimeVersion",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                            "state_unsubscribeRuntimeVersion",
                        )
                        .await?;
                    Ok(subscription)
                }
                /// Create and submit an extrinsic and return corresponding Hash if successful
                pub async fn author_submit_extrinsic(
                    &self,
                    extrinsic: &[u8],
                ) -> Result<T::Hash, Error> {
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(to_hex(extrinsic))
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    let xt_hash = self
                        .client
                        .request("author_submitExtrinsic", params)
                        .await?;
                    Ok(xt_hash)
                }
                /// Create and submit an extrinsic and return a subscription to the events triggered.
                pub async fn author_submit_and_watch_extrinsic(
                    &self,
                    extrinsic: &[u8],
                ) -> Result<RpcSubscription<TransactionStatus<T::Hash>>, Error> {
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(to_hex(extrinsic))
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    let subscription = self
                        .client
                        .subscribe(
                            "author_submitAndWatchExtrinsic",
                            params,
                            "author_unwatchExtrinsic",
                        )
                        .await?;
                    Ok(subscription)
                }
                /// Insert a key into the keystore.
                pub async fn author_insert_key(
                    &self,
                    key_type: String,
                    suri: String,
                    public: Vec<u8>,
                ) -> Result<(), Error> {
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(key_type)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                            .push(suri)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                            .push(Bytes(public))
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    self.client.request("author_insertKey", params).await?;
                    Ok(())
                }
                /// Generate new session keys and returns the corresponding public keys.
                pub async fn author_rotate_keys(&self) -> Result<Vec<u8>, Error> {
                    let bytes: Bytes = self
                        .client
                        .request(
                            "author_rotateKeys",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                        )
                        .await?;
                    Ok(bytes.0)
                }
                /// Checks if the keystore has private keys for the given session public keys.
                ///
                /// `session_keys` is the SCALE encoded session keys object from the runtime.
                ///
                /// Returns `true` if all private keys could be found.
                pub async fn author_has_session_keys(
                    &self,
                    session_keys: Vec<u8>,
                ) -> Result<bool, Error> {
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(Bytes(session_keys))
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    self.client.request("author_hasSessionKeys", params).await
                }
                /// Checks if the keystore has private keys for the given public key and key type.
                ///
                /// Returns `true` if a private key could be found.
                pub async fn author_has_key(
                    &self,
                    public_key: Vec<u8>,
                    key_type: String,
                ) -> Result<bool, Error> {
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(Bytes(public_key))
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                            .push(key_type)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    self.client.request("author_hasKey", params).await
                }
                /// Execute a runtime API call via `state_call` RPC method.
                pub async fn state_call(
                    &self,
                    function: &str,
                    call_parameters: Option<&[u8]>,
                    at: Option<T::Hash>,
                ) -> Result<Vec<u8>, Error> {
                    let call_parameters = call_parameters.unwrap_or_default();
                    let bytes: Bytes = self
                        .client
                        .request(
                            "state_call",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                                    .push(function)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(to_hex(call_parameters))
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(at)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                            },
                        )
                        .await?;
                    Ok(bytes.0)
                }
                /// Submits the extrinsic to the dry_run RPC, to test if it would succeed.
                ///
                /// Returns a [`DryRunResult`], which is the result of performing the dry run.
                pub async fn dry_run(
                    &self,
                    encoded_signed: &[u8],
                    at: Option<T::Hash>,
                ) -> Result<DryRunResultBytes, Error> {
                    let params = {
                        #[allow(unused_mut)]
                        let mut params = crate::backend::rpc::RpcParams::new();
                        params
                            .push(to_hex(encoded_signed))
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                            .push(at)
                            .expect(
                                "values passed to rpc_params! must be serializable to JSON",
                            );
                        params
                    };
                    let result_bytes: Bytes = self
                        .client
                        .request("system_dryRun", params)
                        .await?;
                    Ok(DryRunResultBytes(result_bytes.0))
                }
            }
            /// Storage key.
            pub type StorageKey = Vec<u8>;
            /// Storage data.
            pub type StorageData = Vec<u8>;
            /// Health struct returned by the RPC
            #[serde(rename_all = "camelCase")]
            pub struct SystemHealth {
                /// Number of connected peers
                pub peers: usize,
                /// Is the node syncing
                pub is_syncing: bool,
                /// Should this node have any peers
                ///
                /// Might be false for local chains or when running without discovery.
                pub should_have_peers: bool,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for SystemHealth {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "peers" => _serde::__private::Ok(__Field::__field0),
                                    "isSyncing" => _serde::__private::Ok(__Field::__field1),
                                    "shouldHavePeers" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"peers" => _serde::__private::Ok(__Field::__field0),
                                    b"isSyncing" => _serde::__private::Ok(__Field::__field1),
                                    b"shouldHavePeers" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<SystemHealth>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = SystemHealth;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct SystemHealth",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    usize,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct SystemHealth with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    bool,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct SystemHealth with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    bool,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct SystemHealth with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(SystemHealth {
                                    peers: __field0,
                                    is_syncing: __field1,
                                    should_have_peers: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("peers"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "isSyncing",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "shouldHavePeers",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("peers")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("isSyncing")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("shouldHavePeers")?
                                    }
                                };
                                _serde::__private::Ok(SystemHealth {
                                    peers: __field0,
                                    is_syncing: __field1,
                                    should_have_peers: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "peers",
                            "isSyncing",
                            "shouldHavePeers",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "SystemHealth",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<SystemHealth>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::clone::Clone for SystemHealth {
                #[inline]
                fn clone(&self) -> SystemHealth {
                    SystemHealth {
                        peers: ::core::clone::Clone::clone(&self.peers),
                        is_syncing: ::core::clone::Clone::clone(&self.is_syncing),
                        should_have_peers: ::core::clone::Clone::clone(
                            &self.should_have_peers,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SystemHealth {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "SystemHealth",
                        "peers",
                        &self.peers,
                        "is_syncing",
                        &self.is_syncing,
                        "should_have_peers",
                        &&self.should_have_peers,
                    )
                }
            }
            /// System properties; an arbitrary JSON object.
            pub type SystemProperties = serde_json::Map<String, serde_json::Value>;
            /// A block number
            pub type BlockNumber = NumberOrHex;
            /// The response from `chain_getBlock`
            #[serde(bound = "T: Config")]
            pub struct BlockDetails<T: Config> {
                /// The block itself.
                pub block: Block<T>,
                /// Block justification.
                pub justifications: Option<Vec<BlockJustification>>,
            }
            #[automatically_derived]
            impl<T: ::core::fmt::Debug + Config> ::core::fmt::Debug for BlockDetails<T> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "BlockDetails",
                        "block",
                        &self.block,
                        "justifications",
                        &&self.justifications,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, T: Config> _serde::Deserialize<'de> for BlockDetails<T>
                where
                    T: Config,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "block" => _serde::__private::Ok(__Field::__field0),
                                    "justifications" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"block" => _serde::__private::Ok(__Field::__field0),
                                    b"justifications" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, T: Config>
                        where
                            T: Config,
                        {
                            marker: _serde::__private::PhantomData<BlockDetails<T>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de, T: Config> _serde::de::Visitor<'de>
                        for __Visitor<'de, T>
                        where
                            T: Config,
                        {
                            type Value = BlockDetails<T>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct BlockDetails",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Block<T>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct BlockDetails with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Option<Vec<BlockJustification>>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct BlockDetails with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(BlockDetails {
                                    block: __field0,
                                    justifications: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Block<T>> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Option<Vec<BlockJustification>>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("block"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Block<T>>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "justifications",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<Vec<BlockJustification>>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("block")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("justifications")?
                                    }
                                };
                                _serde::__private::Ok(BlockDetails {
                                    block: __field0,
                                    justifications: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "block",
                            "justifications",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "BlockDetails",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<BlockDetails<T>>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// Block details in the [`BlockDetails`].
            pub struct Block<T: Config> {
                /// The block header.
                pub header: T::Header,
                /// The accompanying extrinsics.
                pub extrinsics: Vec<Bytes>,
            }
            #[automatically_derived]
            impl<T: ::core::fmt::Debug + Config> ::core::fmt::Debug for Block<T>
            where
                T::Header: ::core::fmt::Debug,
            {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Block",
                        "header",
                        &self.header,
                        "extrinsics",
                        &&self.extrinsics,
                    )
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, T: Config> _serde::Deserialize<'de> for Block<T>
                where
                    T::Header: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "header" => _serde::__private::Ok(__Field::__field0),
                                    "extrinsics" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"header" => _serde::__private::Ok(__Field::__field0),
                                    b"extrinsics" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, T: Config>
                        where
                            T::Header: _serde::Deserialize<'de>,
                        {
                            marker: _serde::__private::PhantomData<Block<T>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de, T: Config> _serde::de::Visitor<'de>
                        for __Visitor<'de, T>
                        where
                            T::Header: _serde::Deserialize<'de>,
                        {
                            type Value = Block<T>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Block",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    T::Header,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Block with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<Bytes>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Block with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Block {
                                    header: __field0,
                                    extrinsics: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<T::Header> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<Bytes>> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("header"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<T::Header>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "extrinsics",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<Bytes>>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("header")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("extrinsics")?
                                    }
                                };
                                _serde::__private::Ok(Block {
                                    header: __field0,
                                    extrinsics: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "header",
                            "extrinsics",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Block",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Block<T>>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// An abstraction over justification for a block's validity under a consensus algorithm.
            pub type BlockJustification = (ConsensusEngineId, EncodedJustification);
            /// Consensus engine unique ID.
            pub type ConsensusEngineId = [u8; 4];
            /// The encoded justification specific to a consensus engine.
            pub type EncodedJustification = Vec<u8>;
            /// This contains the runtime version information necessary to make transactions, as obtained from
            /// the RPC call `state_getRuntimeVersion`,
            #[serde(rename_all = "camelCase")]
            pub struct RuntimeVersion {
                /// Version of the runtime specification. A full-node will not attempt to use its native
                /// runtime in substitute for the on-chain Wasm runtime unless all of `spec_name`,
                /// `spec_version` and `authoring_version` are the same between Wasm and native.
                pub spec_version: u32,
                /// All existing dispatches are fully compatible when this number doesn't change. If this
                /// number changes, then `spec_version` must change, also.
                ///
                /// This number must change when an existing dispatchable (module ID, dispatch ID) is changed,
                /// either through an alteration in its user-level semantics, a parameter
                /// added/removed/changed, a dispatchable being removed, a module being removed, or a
                /// dispatchable/module changing its index.
                ///
                /// It need *not* change when a new module is added or when a dispatchable is added.
                pub transaction_version: u32,
                /// Fields unnecessary to Subxt are written out to this map.
                #[serde(flatten)]
                pub other: std::collections::HashMap<String, serde_json::Value>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for RuntimeVersion {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "RuntimeVersion",
                        "spec_version",
                        &self.spec_version,
                        "transaction_version",
                        &self.transaction_version,
                        "other",
                        &&self.other,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RuntimeVersion {
                #[inline]
                fn clone(&self) -> RuntimeVersion {
                    RuntimeVersion {
                        spec_version: ::core::clone::Clone::clone(&self.spec_version),
                        transaction_version: ::core::clone::Clone::clone(
                            &self.transaction_version,
                        ),
                        other: ::core::clone::Clone::clone(&self.other),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for RuntimeVersion {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for RuntimeVersion {
                #[inline]
                fn eq(&self, other: &RuntimeVersion) -> bool {
                    self.spec_version == other.spec_version
                        && self.transaction_version == other.transaction_version
                        && self.other == other.other
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for RuntimeVersion {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                    let _: ::core::cmp::AssertParamIsEq<
                        std::collections::HashMap<String, serde_json::Value>,
                    >;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RuntimeVersion {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field<'de> {
                            __field0,
                            __field1,
                            __other(_serde::__private::de::Content<'de>),
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field<'de>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_bool<__E>(
                                self,
                                __value: bool,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::Bool(__value),
                                    ),
                                )
                            }
                            fn visit_i8<__E>(
                                self,
                                __value: i8,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::I8(__value),
                                    ),
                                )
                            }
                            fn visit_i16<__E>(
                                self,
                                __value: i16,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::I16(__value),
                                    ),
                                )
                            }
                            fn visit_i32<__E>(
                                self,
                                __value: i32,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::I32(__value),
                                    ),
                                )
                            }
                            fn visit_i64<__E>(
                                self,
                                __value: i64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::I64(__value),
                                    ),
                                )
                            }
                            fn visit_u8<__E>(
                                self,
                                __value: u8,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::U8(__value),
                                    ),
                                )
                            }
                            fn visit_u16<__E>(
                                self,
                                __value: u16,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::U16(__value),
                                    ),
                                )
                            }
                            fn visit_u32<__E>(
                                self,
                                __value: u32,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::U32(__value),
                                    ),
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::U64(__value),
                                    ),
                                )
                            }
                            fn visit_f32<__E>(
                                self,
                                __value: f32,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::F32(__value),
                                    ),
                                )
                            }
                            fn visit_f64<__E>(
                                self,
                                __value: f64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::F64(__value),
                                    ),
                                )
                            }
                            fn visit_char<__E>(
                                self,
                                __value: char,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::Char(__value),
                                    ),
                                )
                            }
                            fn visit_unit<__E>(
                                self,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(_serde::__private::de::Content::Unit),
                                )
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "specVersion" => _serde::__private::Ok(__Field::__field0),
                                    "transactionVersion" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => {
                                        let __value = _serde::__private::de::Content::String(
                                            _serde::__private::ToString::to_string(__value),
                                        );
                                        _serde::__private::Ok(__Field::__other(__value))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"specVersion" => _serde::__private::Ok(__Field::__field0),
                                    b"transactionVersion" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => {
                                        let __value = _serde::__private::de::Content::ByteBuf(
                                            __value.to_vec(),
                                        );
                                        _serde::__private::Ok(__Field::__other(__value))
                                    }
                                }
                            }
                            fn visit_borrowed_str<__E>(
                                self,
                                __value: &'de str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "specVersion" => _serde::__private::Ok(__Field::__field0),
                                    "transactionVersion" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => {
                                        let __value = _serde::__private::de::Content::Str(__value);
                                        _serde::__private::Ok(__Field::__other(__value))
                                    }
                                }
                            }
                            fn visit_borrowed_bytes<__E>(
                                self,
                                __value: &'de [u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"specVersion" => _serde::__private::Ok(__Field::__field0),
                                    b"transactionVersion" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => {
                                        let __value = _serde::__private::de::Content::Bytes(
                                            __value,
                                        );
                                        _serde::__private::Ok(__Field::__other(__value))
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field<'de> {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<RuntimeVersion>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RuntimeVersion;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct RuntimeVersion",
                                )
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<u32> = _serde::__private::None;
                                let mut __collect = _serde::__private::Vec::<
                                    _serde::__private::Option<
                                        (
                                            _serde::__private::de::Content,
                                            _serde::__private::de::Content,
                                        ),
                                    >,
                                >::new();
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "specVersion",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "transactionVersion",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__other(__name) => {
                                            __collect
                                                .push(
                                                    _serde::__private::Some((
                                                        __name,
                                                        _serde::de::MapAccess::next_value(&mut __map)?,
                                                    )),
                                                );
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("specVersion")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("transactionVersion")?
                                    }
                                };
                                let __field2: std::collections::HashMap<
                                    String,
                                    serde_json::Value,
                                > = _serde::de::Deserialize::deserialize(
                                    _serde::__private::de::FlatMapDeserializer(
                                        &mut __collect,
                                        _serde::__private::PhantomData,
                                    ),
                                )?;
                                _serde::__private::Ok(RuntimeVersion {
                                    spec_version: __field0,
                                    transaction_version: __field1,
                                    other: __field2,
                                })
                            }
                        }
                        _serde::Deserializer::deserialize_map(
                            __deserializer,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<RuntimeVersion>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// Possible transaction status events.
            ///
            /// # Note
            ///
            /// This is copied from `sp-transaction-pool` to avoid a dependency on that crate. Therefore it
            /// must be kept compatible with that type from the target substrate version.
            #[serde(rename_all = "camelCase")]
            pub enum TransactionStatus<Hash> {
                /// Transaction is part of the future queue.
                Future,
                /// Transaction is part of the ready queue.
                Ready,
                /// The transaction has been broadcast to the given peers.
                Broadcast(Vec<String>),
                /// Transaction has been included in block with given hash.
                InBlock(Hash),
                /// The block this transaction was included in has been retracted.
                Retracted(Hash),
                /// Maximum number of finality watchers has been reached,
                /// old watchers are being removed.
                FinalityTimeout(Hash),
                /// Transaction has been finalized by a finality-gadget, e.g GRANDPA
                Finalized(Hash),
                /// Transaction has been replaced in the pool, by another transaction
                /// that provides the same tags. (e.g. same (sender, nonce)).
                Usurped(Hash),
                /// Transaction has been dropped from the pool because of the limit.
                Dropped,
                /// Transaction is no longer valid in the current state.
                Invalid,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug
            for TransactionStatus<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        TransactionStatus::Future => {
                            ::core::fmt::Formatter::write_str(f, "Future")
                        }
                        TransactionStatus::Ready => {
                            ::core::fmt::Formatter::write_str(f, "Ready")
                        }
                        TransactionStatus::Broadcast(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Broadcast",
                                &__self_0,
                            )
                        }
                        TransactionStatus::InBlock(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "InBlock",
                                &__self_0,
                            )
                        }
                        TransactionStatus::Retracted(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Retracted",
                                &__self_0,
                            )
                        }
                        TransactionStatus::FinalityTimeout(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FinalityTimeout",
                                &__self_0,
                            )
                        }
                        TransactionStatus::Finalized(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Finalized",
                                &__self_0,
                            )
                        }
                        TransactionStatus::Usurped(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Usurped",
                                &__self_0,
                            )
                        }
                        TransactionStatus::Dropped => {
                            ::core::fmt::Formatter::write_str(f, "Dropped")
                        }
                        TransactionStatus::Invalid => {
                            ::core::fmt::Formatter::write_str(f, "Invalid")
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, Hash> _serde::Deserialize<'de> for TransactionStatus<Hash>
                where
                    Hash: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 10",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "future" => _serde::__private::Ok(__Field::__field0),
                                    "ready" => _serde::__private::Ok(__Field::__field1),
                                    "broadcast" => _serde::__private::Ok(__Field::__field2),
                                    "inBlock" => _serde::__private::Ok(__Field::__field3),
                                    "retracted" => _serde::__private::Ok(__Field::__field4),
                                    "finalityTimeout" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    "finalized" => _serde::__private::Ok(__Field::__field6),
                                    "usurped" => _serde::__private::Ok(__Field::__field7),
                                    "dropped" => _serde::__private::Ok(__Field::__field8),
                                    "invalid" => _serde::__private::Ok(__Field::__field9),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"future" => _serde::__private::Ok(__Field::__field0),
                                    b"ready" => _serde::__private::Ok(__Field::__field1),
                                    b"broadcast" => _serde::__private::Ok(__Field::__field2),
                                    b"inBlock" => _serde::__private::Ok(__Field::__field3),
                                    b"retracted" => _serde::__private::Ok(__Field::__field4),
                                    b"finalityTimeout" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    b"finalized" => _serde::__private::Ok(__Field::__field6),
                                    b"usurped" => _serde::__private::Ok(__Field::__field7),
                                    b"dropped" => _serde::__private::Ok(__Field::__field8),
                                    b"invalid" => _serde::__private::Ok(__Field::__field9),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            marker: _serde::__private::PhantomData<
                                TransactionStatus<Hash>,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de, Hash> _serde::de::Visitor<'de> for __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            type Value = TransactionStatus<Hash>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum TransactionStatus",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TransactionStatus::Future)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TransactionStatus::Ready)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Vec<String>,
                                            >(__variant),
                                            TransactionStatus::Broadcast,
                                        )
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Hash,
                                            >(__variant),
                                            TransactionStatus::InBlock,
                                        )
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Hash,
                                            >(__variant),
                                            TransactionStatus::Retracted,
                                        )
                                    }
                                    (__Field::__field5, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Hash,
                                            >(__variant),
                                            TransactionStatus::FinalityTimeout,
                                        )
                                    }
                                    (__Field::__field6, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Hash,
                                            >(__variant),
                                            TransactionStatus::Finalized,
                                        )
                                    }
                                    (__Field::__field7, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Hash,
                                            >(__variant),
                                            TransactionStatus::Usurped,
                                        )
                                    }
                                    (__Field::__field8, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TransactionStatus::Dropped)
                                    }
                                    (__Field::__field9, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(TransactionStatus::Invalid)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "future",
                            "ready",
                            "broadcast",
                            "inBlock",
                            "retracted",
                            "finalityTimeout",
                            "finalized",
                            "usurped",
                            "dropped",
                            "invalid",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "TransactionStatus",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    TransactionStatus<Hash>,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// The decoded result returned from calling `system_dryRun` on some extrinsic.
            pub enum DryRunResult {
                /// The transaction could be included in the block and executed.
                Success,
                /// The transaction could be included in the block, but the call failed to dispatch.
                DispatchError(crate::error::DispatchError),
                /// The transaction could not be included in the block.
                TransactionValidityError,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for DryRunResult {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        DryRunResult::Success => {
                            ::core::fmt::Formatter::write_str(f, "Success")
                        }
                        DryRunResult::DispatchError(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "DispatchError",
                                &__self_0,
                            )
                        }
                        DryRunResult::TransactionValidityError => {
                            ::core::fmt::Formatter::write_str(
                                f,
                                "TransactionValidityError",
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DryRunResult {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DryRunResult {
                #[inline]
                fn eq(&self, other: &DryRunResult) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                DryRunResult::DispatchError(__self_0),
                                DryRunResult::DispatchError(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => true,
                        }
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for DryRunResult {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<crate::error::DispatchError>;
                }
            }
            /// The bytes representing an error dry running an extrinsic. call [`DryRunResultBytes::into_dry_run_result`]
            /// to attempt to decode this into something more meaningful.
            pub struct DryRunResultBytes(pub Vec<u8>);
            impl DryRunResultBytes {
                /// Attempt to decode the error bytes into a [`DryRunResult`] using the provided [`Metadata`].
                pub fn into_dry_run_result(
                    self,
                    metadata: &crate::metadata::Metadata,
                ) -> Result<DryRunResult, crate::Error> {
                    let bytes = self.0;
                    if bytes[0] == 0 && bytes[1] == 0 {
                        Ok(DryRunResult::Success)
                    } else if bytes[0] == 0 && bytes[1] == 1 {
                        let dispatch_error = crate::error::DispatchError::decode_from(
                            &bytes[2..],
                            metadata.clone(),
                        )?;
                        Ok(DryRunResult::DispatchError(dispatch_error))
                    } else if bytes[0] == 1 {
                        Ok(DryRunResult::TransactionValidityError)
                    } else {
                        Err(crate::Error::Unknown(bytes))
                    }
                }
            }
            /// Storage change set
            #[serde(rename_all = "camelCase")]
            pub struct StorageChangeSet<Hash> {
                /// Block hash
                pub block: Hash,
                /// A list of changes; tuples of storage key and optional storage data.
                pub changes: Vec<(Bytes, Option<Bytes>)>,
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone> ::core::clone::Clone
            for StorageChangeSet<Hash> {
                #[inline]
                fn clone(&self) -> StorageChangeSet<Hash> {
                    StorageChangeSet {
                        block: ::core::clone::Clone::clone(&self.block),
                        changes: ::core::clone::Clone::clone(&self.changes),
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<Hash> _serde::Serialize for StorageChangeSet<Hash>
                where
                    Hash: _serde::Serialize,
                {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "StorageChangeSet",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "block",
                            &self.block,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "changes",
                            &self.changes,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, Hash> _serde::Deserialize<'de> for StorageChangeSet<Hash>
                where
                    Hash: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "block" => _serde::__private::Ok(__Field::__field0),
                                    "changes" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"block" => _serde::__private::Ok(__Field::__field0),
                                    b"changes" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            marker: _serde::__private::PhantomData<
                                StorageChangeSet<Hash>,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de, Hash> _serde::de::Visitor<'de> for __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            type Value = StorageChangeSet<Hash>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct StorageChangeSet",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Hash,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct StorageChangeSet with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<(Bytes, Option<Bytes>)>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct StorageChangeSet with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(StorageChangeSet {
                                    block: __field0,
                                    changes: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Hash> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Vec<(Bytes, Option<Bytes>)>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("block"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Hash>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "changes",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Vec<(Bytes, Option<Bytes>)>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("block")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("changes")?
                                    }
                                };
                                _serde::__private::Ok(StorageChangeSet {
                                    block: __field0,
                                    changes: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["block", "changes"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "StorageChangeSet",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    StorageChangeSet<Hash>,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl<Hash> ::core::marker::StructuralPartialEq for StorageChangeSet<Hash> {}
            #[automatically_derived]
            impl<Hash: ::core::cmp::PartialEq> ::core::cmp::PartialEq
            for StorageChangeSet<Hash> {
                #[inline]
                fn eq(&self, other: &StorageChangeSet<Hash>) -> bool {
                    self.block == other.block && self.changes == other.changes
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::cmp::Eq> ::core::cmp::Eq for StorageChangeSet<Hash> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Hash>;
                    let _: ::core::cmp::AssertParamIsEq<Vec<(Bytes, Option<Bytes>)>>;
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug
            for StorageChangeSet<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "StorageChangeSet",
                        "block",
                        &self.block,
                        "changes",
                        &&self.changes,
                    )
                }
            }
            /// Statistics of a block returned by the `dev_getBlockStats` RPC.
            #[serde(rename_all = "camelCase")]
            pub struct BlockStats {
                /// The length in bytes of the storage proof produced by executing the block.
                pub witness_len: u64,
                /// The length in bytes of the storage proof after compaction.
                pub witness_compact_len: u64,
                /// Length of the block in bytes.
                ///
                /// This information can also be acquired by downloading the whole block. This merely
                /// saves some complexity on the client side.
                pub block_len: u64,
                /// Number of extrinsics in the block.
                ///
                /// This information can also be acquired by downloading the whole block. This merely
                /// saves some complexity on the client side.
                pub num_extrinsics: u64,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for BlockStats {
                #[inline]
                fn clone(&self) -> BlockStats {
                    BlockStats {
                        witness_len: ::core::clone::Clone::clone(&self.witness_len),
                        witness_compact_len: ::core::clone::Clone::clone(
                            &self.witness_compact_len,
                        ),
                        block_len: ::core::clone::Clone::clone(&self.block_len),
                        num_extrinsics: ::core::clone::Clone::clone(&self.num_extrinsics),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for BlockStats {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "BlockStats",
                        "witness_len",
                        &self.witness_len,
                        "witness_compact_len",
                        &self.witness_compact_len,
                        "block_len",
                        &self.block_len,
                        "num_extrinsics",
                        &&self.num_extrinsics,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for BlockStats {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for BlockStats {
                #[inline]
                fn eq(&self, other: &BlockStats) -> bool {
                    self.witness_len == other.witness_len
                        && self.witness_compact_len == other.witness_compact_len
                        && self.block_len == other.block_len
                        && self.num_extrinsics == other.num_extrinsics
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for BlockStats {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u64>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for BlockStats {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "BlockStats",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "witnessLen",
                            &self.witness_len,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "witnessCompactLen",
                            &self.witness_compact_len,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "blockLen",
                            &self.block_len,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "numExtrinsics",
                            &self.num_extrinsics,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for BlockStats {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "witnessLen" => _serde::__private::Ok(__Field::__field0),
                                    "witnessCompactLen" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    "blockLen" => _serde::__private::Ok(__Field::__field2),
                                    "numExtrinsics" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"witnessLen" => _serde::__private::Ok(__Field::__field0),
                                    b"witnessCompactLen" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    b"blockLen" => _serde::__private::Ok(__Field::__field2),
                                    b"numExtrinsics" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<BlockStats>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = BlockStats;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct BlockStats",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    u64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct BlockStats with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    u64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct BlockStats with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    u64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct BlockStats with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    u64,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct BlockStats with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(BlockStats {
                                    witness_len: __field0,
                                    witness_compact_len: __field1,
                                    block_len: __field2,
                                    num_extrinsics: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<u64> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<u64> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "witnessLen",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "witnessCompactLen",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "blockLen",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "numExtrinsics",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("witnessLen")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("witnessCompactLen")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("blockLen")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("numExtrinsics")?
                                    }
                                };
                                _serde::__private::Ok(BlockStats {
                                    witness_len: __field0,
                                    witness_compact_len: __field1,
                                    block_len: __field2,
                                    num_extrinsics: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "witnessLen",
                            "witnessCompactLen",
                            "blockLen",
                            "numExtrinsics",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "BlockStats",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<BlockStats>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// ReadProof struct returned by the RPC
            ///
            /// # Note
            ///
            /// This is copied from `sc-rpc-api` to avoid a dependency on that crate. Therefore it
            /// must be kept compatible with that type from the target substrate version.
            #[serde(rename_all = "camelCase")]
            pub struct ReadProof<Hash> {
                /// Block hash used to generate the proof
                pub at: Hash,
                /// A proof used to prove that storage entries are included in the storage trie
                pub proof: Vec<Bytes>,
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone> ::core::clone::Clone for ReadProof<Hash> {
                #[inline]
                fn clone(&self) -> ReadProof<Hash> {
                    ReadProof {
                        at: ::core::clone::Clone::clone(&self.at),
                        proof: ::core::clone::Clone::clone(&self.proof),
                    }
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug for ReadProof<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "ReadProof",
                        "at",
                        &self.at,
                        "proof",
                        &&self.proof,
                    )
                }
            }
            #[automatically_derived]
            impl<Hash> ::core::marker::StructuralPartialEq for ReadProof<Hash> {}
            #[automatically_derived]
            impl<Hash: ::core::cmp::PartialEq> ::core::cmp::PartialEq
            for ReadProof<Hash> {
                #[inline]
                fn eq(&self, other: &ReadProof<Hash>) -> bool {
                    self.at == other.at && self.proof == other.proof
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::cmp::Eq> ::core::cmp::Eq for ReadProof<Hash> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Hash>;
                    let _: ::core::cmp::AssertParamIsEq<Vec<Bytes>>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<Hash> _serde::Serialize for ReadProof<Hash>
                where
                    Hash: _serde::Serialize,
                {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ReadProof",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "at",
                            &self.at,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "proof",
                            &self.proof,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, Hash> _serde::Deserialize<'de> for ReadProof<Hash>
                where
                    Hash: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "at" => _serde::__private::Ok(__Field::__field0),
                                    "proof" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"at" => _serde::__private::Ok(__Field::__field0),
                                    b"proof" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            marker: _serde::__private::PhantomData<ReadProof<Hash>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de, Hash> _serde::de::Visitor<'de> for __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            type Value = ReadProof<Hash>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ReadProof",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Hash,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ReadProof with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<Bytes>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ReadProof with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ReadProof {
                                    at: __field0,
                                    proof: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Hash> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<Bytes>> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("at"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Hash>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("proof"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<Bytes>>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("at")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("proof")?
                                    }
                                };
                                _serde::__private::Ok(ReadProof {
                                    at: __field0,
                                    proof: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["at", "proof"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ReadProof",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ReadProof<Hash>>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// A number type that can be serialized both as a number or a string that encodes a number in a
            /// string.
            ///
            /// We allow two representations of the block number as input. Either we deserialize to the type
            /// that is specified in the block type or we attempt to parse given hex value.
            ///
            /// The primary motivation for having this type is to avoid overflows when using big integers in
            /// JavaScript (which we consider as an important RPC API consumer).
            #[serde(untagged)]
            pub enum NumberOrHex {
                /// The number represented directly.
                Number(u64),
                /// Hex representation of the number.
                Hex(U256),
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NumberOrHex {}
            #[automatically_derived]
            impl ::core::clone::Clone for NumberOrHex {
                #[inline]
                fn clone(&self) -> NumberOrHex {
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    let _: ::core::clone::AssertParamIsClone<U256>;
                    *self
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for NumberOrHex {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            NumberOrHex::Number(ref __field0) => {
                                _serde::Serialize::serialize(__field0, __serializer)
                            }
                            NumberOrHex::Hex(ref __field0) => {
                                _serde::Serialize::serialize(__field0, __serializer)
                            }
                        }
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for NumberOrHex {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        let __content = <_serde::__private::de::Content as _serde::Deserialize>::deserialize(
                            __deserializer,
                        )?;
                        let __deserializer = _serde::__private::de::ContentRefDeserializer::<
                            __D::Error,
                        >::new(&__content);
                        if let _serde::__private::Ok(__ok)
                            = _serde::__private::Result::map(
                                <u64 as _serde::Deserialize>::deserialize(__deserializer),
                                NumberOrHex::Number,
                            ) {
                            return _serde::__private::Ok(__ok);
                        }
                        if let _serde::__private::Ok(__ok)
                            = _serde::__private::Result::map(
                                <U256 as _serde::Deserialize>::deserialize(__deserializer),
                                NumberOrHex::Hex,
                            ) {
                            return _serde::__private::Ok(__ok);
                        }
                        _serde::__private::Err(
                            _serde::de::Error::custom(
                                "data did not match any variant of untagged enum NumberOrHex",
                            ),
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::fmt::Debug for NumberOrHex {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        NumberOrHex::Number(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Number",
                                &__self_0,
                            )
                        }
                        NumberOrHex::Hex(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Hex",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NumberOrHex {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NumberOrHex {
                #[inline]
                fn eq(&self, other: &NumberOrHex) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                NumberOrHex::Number(__self_0),
                                NumberOrHex::Number(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (NumberOrHex::Hex(__self_0), NumberOrHex::Hex(__arg1_0)) => {
                                *__self_0 == *__arg1_0
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for NumberOrHex {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u64>;
                    let _: ::core::cmp::AssertParamIsEq<U256>;
                }
            }
            impl NumberOrHex {
                /// Converts this number into an U256.
                pub fn into_u256(self) -> U256 {
                    match self {
                        NumberOrHex::Number(n) => n.into(),
                        NumberOrHex::Hex(h) => h,
                    }
                }
            }
            impl From<NumberOrHex> for U256 {
                fn from(num_or_hex: NumberOrHex) -> U256 {
                    num_or_hex.into_u256()
                }
            }
            impl From<u8> for NumberOrHex {
                fn from(x: u8) -> Self {
                    NumberOrHex::Number(x.into())
                }
            }
            impl From<u16> for NumberOrHex {
                fn from(x: u16) -> Self {
                    NumberOrHex::Number(x.into())
                }
            }
            impl From<u32> for NumberOrHex {
                fn from(x: u32) -> Self {
                    NumberOrHex::Number(x.into())
                }
            }
            impl From<u64> for NumberOrHex {
                fn from(x: u64) -> Self {
                    NumberOrHex::Number(x.into())
                }
            }
            impl From<u128> for NumberOrHex {
                fn from(n: u128) -> Self {
                    NumberOrHex::Hex(n.into())
                }
            }
            impl From<U256> for NumberOrHex {
                fn from(n: U256) -> Self {
                    NumberOrHex::Hex(n)
                }
            }
            /// A quick helper to encode some bytes to hex.
            fn to_hex(bytes: impl AsRef<[u8]>) -> String {
                {
                    let res = ::alloc::fmt::format(
                        format_args!("0x{0}", hex::encode(bytes.as_ref())),
                    );
                    res
                }
            }
            /// Hex-serialized shim for `Vec<u8>`.
            pub struct Bytes(#[serde(with = "impl_serde::serialize")] pub Vec<u8>);
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Bytes {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Bytes {
                #[inline]
                fn eq(&self, other: &Bytes) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Bytes {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Bytes {
                #[inline]
                fn clone(&self) -> Bytes {
                    Bytes(::core::clone::Clone::clone(&self.0))
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Bytes {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        _serde::Serializer::serialize_newtype_struct(
                            __serializer,
                            "Bytes",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (&'__a Vec<u8>,),
                                    phantom: _serde::__private::PhantomData<Bytes>,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        impl_serde::serialize::serialize(self.values.0, __s)
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.0,),
                                    phantom: _serde::__private::PhantomData::<Bytes>,
                                }
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Bytes {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Bytes>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Bytes;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "tuple struct Bytes",
                                )
                            }
                            #[inline]
                            fn visit_newtype_struct<__E>(
                                self,
                                __e: __E,
                            ) -> _serde::__private::Result<Self::Value, __E::Error>
                            where
                                __E: _serde::Deserializer<'de>,
                            {
                                let __field0: Vec<u8> = impl_serde::serialize::deserialize(
                                    __e,
                                )?;
                                _serde::__private::Ok(Bytes(__field0))
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Vec<u8>,
                                        phantom: _serde::__private::PhantomData<Bytes>,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: impl_serde::serialize::deserialize(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"tuple struct Bytes with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Bytes(__field0))
                            }
                        }
                        _serde::Deserializer::deserialize_newtype_struct(
                            __deserializer,
                            "Bytes",
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Bytes>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::hash::Hash for Bytes {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Bytes {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Bytes,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Bytes {
                #[inline]
                fn cmp(&self, other: &Bytes) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Bytes {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Bytes",
                        &&self.0,
                    )
                }
            }
            impl std::ops::Deref for Bytes {
                type Target = [u8];
                fn deref(&self) -> &[u8] {
                    &self.0[..]
                }
            }
            impl From<Vec<u8>> for Bytes {
                fn from(s: Vec<u8>) -> Self {
                    Bytes(s)
                }
            }
        }
        use self::rpc_methods::TransactionStatus as RpcTransactionStatus;
        use crate::backend::{
            rpc::RpcClient, Backend, BlockRef, RuntimeVersion, StorageResponse, StreamOf,
            StreamOfResults, TransactionStatus,
        };
        use crate::{config::Header, Config, Error};
        use async_trait::async_trait;
        use futures::{
            future, future::Either, stream, Future, FutureExt, Stream, StreamExt,
        };
        use std::collections::VecDeque;
        use std::pin::Pin;
        use std::task::{Context, Poll};
        pub use rpc_methods::LegacyRpcMethods;
        /// The legacy backend.
        pub struct LegacyBackend<T> {
            methods: LegacyRpcMethods<T>,
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for LegacyBackend<T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "LegacyBackend",
                    "methods",
                    &&self.methods,
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for LegacyBackend<T> {
            #[inline]
            fn clone(&self) -> LegacyBackend<T> {
                LegacyBackend {
                    methods: ::core::clone::Clone::clone(&self.methods),
                }
            }
        }
        impl<T: Config> LegacyBackend<T> {
            /// Instantiate a new backend which uses the legacy API methods.
            pub fn new(client: RpcClient) -> Self {
                Self {
                    methods: LegacyRpcMethods::new(client),
                }
            }
        }
        impl<T: Config> super::sealed::Sealed for LegacyBackend<T> {}
        impl<T: Config + Send + Sync + 'static> Backend<T> for LegacyBackend<T> {
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn storage_fetch_values<'life0, 'async_trait>(
                &'life0 self,
                keys: Vec<Vec<u8>>,
                at: T::Hash,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<StreamOfResults<StorageResponse>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<StreamOfResults<StorageResponse>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let keys = keys;
                    let at = at;
                    let __ret: Result<StreamOfResults<StorageResponse>, Error> = {
                        let methods = __self.methods.clone();
                        let iter = keys
                            .into_iter()
                            .map(move |key| {
                                let methods = methods.clone();
                                async move {
                                    let res = methods.state_get_storage(&key, Some(at)).await?;
                                    Ok(res.map(|value| StorageResponse { key, value }))
                                }
                            });
                        let s = stream::iter(iter)
                            .then(|fut| fut)
                            .filter_map(|r| future::ready(r.transpose()));
                        Ok(StreamOf(Box::pin(s)))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn storage_fetch_descendant_keys<'life0, 'async_trait>(
                &'life0 self,
                key: Vec<u8>,
                at: T::Hash,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<StreamOfResults<Vec<u8>>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<StreamOfResults<Vec<u8>>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let key = key;
                    let at = at;
                    let __ret: Result<StreamOfResults<Vec<u8>>, Error> = {
                        let keys = StorageFetchDescendantKeysStream {
                            at,
                            key,
                            methods: __self.methods.clone(),
                            done: Default::default(),
                            keys_fut: Default::default(),
                            pagination_start_key: None,
                        };
                        let keys = keys
                            .flat_map(|keys| {
                                match keys {
                                    Err(e) => {
                                        Either::Left(stream::iter(std::iter::once(Err(e))))
                                    }
                                    Ok(keys) => {
                                        Either::Right(stream::iter(keys.into_iter().map(Ok)))
                                    }
                                }
                            });
                        Ok(StreamOf(Box::pin(keys)))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn storage_fetch_descendant_values<'life0, 'async_trait>(
                &'life0 self,
                key: Vec<u8>,
                at: T::Hash,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<StreamOfResults<StorageResponse>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<StreamOfResults<StorageResponse>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let key = key;
                    let at = at;
                    let __ret: Result<StreamOfResults<StorageResponse>, Error> = {
                        let keys_stream = StorageFetchDescendantKeysStream {
                            at,
                            key,
                            methods: __self.methods.clone(),
                            done: Default::default(),
                            keys_fut: Default::default(),
                            pagination_start_key: None,
                        };
                        Ok(
                            StreamOf(
                                Box::pin(StorageFetchDescendantValuesStream {
                                    keys: keys_stream,
                                    results_fut: None,
                                    results: Default::default(),
                                }),
                            ),
                        )
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn genesis_hash<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<T::Hash, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<T::Hash, Error>> {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<T::Hash, Error> = {
                        __self.methods.genesis_hash().await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn block_header<'life0, 'async_trait>(
                &'life0 self,
                at: T::Hash,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<Option<T::Header>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<Option<T::Header>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let at = at;
                    let __ret: Result<Option<T::Header>, Error> = {
                        __self.methods.chain_get_header(Some(at)).await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn block_body<'life0, 'async_trait>(
                &'life0 self,
                at: T::Hash,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<Option<Vec<Vec<u8>>>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<Option<Vec<Vec<u8>>>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let at = at;
                    let __ret: Result<Option<Vec<Vec<u8>>>, Error> = {
                        let Some(details) = __self
                            .methods
                            .chain_get_block(Some(at))
                            .await? else { return Ok(None);
                    };
                        Ok(
                            Some(
                                details.block.extrinsics.into_iter().map(|b| b.0).collect(),
                            ),
                        )
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn latest_finalized_block_ref<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<BlockRef<T::Hash>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<BlockRef<T::Hash>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<BlockRef<T::Hash>, Error> = {
                        let hash = __self.methods.chain_get_finalized_head().await?;
                        Ok(BlockRef::from_hash(hash))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn current_runtime_version<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<RuntimeVersion, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<RuntimeVersion, Error>> {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<RuntimeVersion, Error> = {
                        let details = __self
                            .methods
                            .state_get_runtime_version(None)
                            .await?;
                        Ok(RuntimeVersion {
                            spec_version: details.spec_version,
                            transaction_version: details.transaction_version,
                        })
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn stream_runtime_version<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<StreamOfResults<RuntimeVersion>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<StreamOfResults<RuntimeVersion>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<StreamOfResults<RuntimeVersion>, Error> = {
                        let sub = __self
                            .methods
                            .state_subscribe_runtime_version()
                            .await?;
                        let sub = sub
                            .map(|r| {
                                r.map(|v| RuntimeVersion {
                                    spec_version: v.spec_version,
                                    transaction_version: v.transaction_version,
                                })
                            });
                        Ok(StreamOf(Box::pin(sub)))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn stream_all_block_headers<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<
                            StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                            Error,
                        >,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<
                                StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                                Error,
                            >,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<
                        StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                        Error,
                    > = {
                        let sub = __self.methods.chain_subscribe_all_heads().await?;
                        let sub = sub
                            .map(|r| {
                                r.map(|h| {
                                    let hash = h.hash();
                                    (h, BlockRef::from_hash(hash))
                                })
                            });
                        Ok(StreamOf(Box::pin(sub)))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn stream_best_block_headers<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<
                            StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                            Error,
                        >,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<
                                StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                                Error,
                            >,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<
                        StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                        Error,
                    > = {
                        let sub = __self.methods.chain_subscribe_new_heads().await?;
                        let sub = sub
                            .map(|r| {
                                r.map(|h| {
                                    let hash = h.hash();
                                    (h, BlockRef::from_hash(hash))
                                })
                            });
                        Ok(StreamOf(Box::pin(sub)))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn stream_finalized_block_headers<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<
                            StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                            Error,
                        >,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<
                                StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                                Error,
                            >,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<
                        StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                        Error,
                    > = {
                        let sub: super::rpc::RpcSubscription<<T as Config>::Header> = __self
                            .methods
                            .chain_subscribe_finalized_heads()
                            .await?;
                        let last_finalized_block_ref = __self
                            .latest_finalized_block_ref()
                            .await?;
                        let last_finalized_block_num = __self
                            .block_header(last_finalized_block_ref.hash())
                            .await?
                            .map(|h| h.number().into());
                        let sub = subscribe_to_block_headers_filling_in_gaps(
                            __self.methods.clone(),
                            sub,
                            last_finalized_block_num,
                        );
                        let sub = sub
                            .map(|r| {
                                r.map(|h| {
                                    let hash = h.hash();
                                    (h, BlockRef::from_hash(hash))
                                })
                            });
                        Ok(StreamOf(Box::pin(sub)))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn submit_transaction<'life0, 'life1, 'async_trait>(
                &'life0 self,
                extrinsic: &'life1 [u8],
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<
                            StreamOfResults<TransactionStatus<T::Hash>>,
                            Error,
                        >,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<StreamOfResults<TransactionStatus<T::Hash>>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<
                        StreamOfResults<TransactionStatus<T::Hash>>,
                        Error,
                    > = {
                        let sub = __self
                            .methods
                            .author_submit_and_watch_extrinsic(extrinsic)
                            .await?;
                        let sub = sub
                            .filter_map(|r| {
                                let mapped = r
                                    .map(|tx| {
                                        match tx {
                                            RpcTransactionStatus::Future => None,
                                            RpcTransactionStatus::Retracted(_) => None,
                                            RpcTransactionStatus::Ready => {
                                                Some(TransactionStatus::Validated)
                                            }
                                            RpcTransactionStatus::Broadcast(peers) => {
                                                Some(TransactionStatus::Broadcasted {
                                                    num_peers: peers.len() as u32,
                                                })
                                            }
                                            RpcTransactionStatus::InBlock(hash) => {
                                                Some(TransactionStatus::InBestBlock {
                                                    hash: BlockRef::from_hash(hash),
                                                })
                                            }
                                            RpcTransactionStatus::FinalityTimeout(_) => {
                                                Some(TransactionStatus::Invalid {
                                                    message: "Finality timeout".into(),
                                                })
                                            }
                                            RpcTransactionStatus::Finalized(hash) => {
                                                Some(TransactionStatus::InFinalizedBlock {
                                                    hash: BlockRef::from_hash(hash),
                                                })
                                            }
                                            RpcTransactionStatus::Usurped(_) => {
                                                Some(TransactionStatus::Invalid {
                                                    message: "Transaction was usurped by another with the same nonce"
                                                        .into(),
                                                })
                                            }
                                            RpcTransactionStatus::Dropped => {
                                                Some(TransactionStatus::Dropped {
                                                    message: "Transaction was dropped".into(),
                                                })
                                            }
                                            RpcTransactionStatus::Invalid => {
                                                Some(TransactionStatus::Invalid {
                                                    message: "Transaction is invalid (eg because of a bad nonce, signature etc)"
                                                        .into(),
                                                })
                                            }
                                        }
                                    })
                                    .transpose();
                                future::ready(mapped)
                            });
                        Ok(StreamOf(Box::pin(sub)))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn call<'life0, 'life1, 'life2, 'async_trait>(
                &'life0 self,
                method: &'life1 str,
                call_parameters: Option<&'life2 [u8]>,
                at: T::Hash,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<Vec<u8>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<Vec<u8>, Error>> {
                        return __ret;
                    }
                    let __self = self;
                    let call_parameters = call_parameters;
                    let at = at;
                    let __ret: Result<Vec<u8>, Error> = {
                        __self
                            .methods
                            .state_call(method, call_parameters, Some(at))
                            .await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
        /// Note: This is exposed for testing but is not considered stable and may change
        /// without notice in a patch release.
        #[doc(hidden)]
        pub fn subscribe_to_block_headers_filling_in_gaps<T, S, E>(
            methods: LegacyRpcMethods<T>,
            sub: S,
            mut last_block_num: Option<u64>,
        ) -> impl Stream<Item = Result<T::Header, Error>> + Send
        where
            T: Config,
            S: Stream<Item = Result<T::Header, E>> + Send,
            E: Into<Error> + Send + 'static,
        {
            sub.flat_map(move |s| {
                let header = match s {
                    Ok(header) => header,
                    Err(e) => return Either::Left(stream::once(async { Err(e.into()) })),
                };
                let end_block_num = header.number().into();
                let start_block_num = last_block_num
                    .map(|n| n + 1)
                    .unwrap_or(end_block_num);
                let methods = methods.clone();
                let previous_headers = stream::iter(start_block_num..end_block_num)
                    .then(move |n| {
                        let methods = methods.clone();
                        async move {
                            let hash = methods
                                .chain_get_block_hash(Some(n.into()))
                                .await?;
                            let header = methods.chain_get_header(hash).await?;
                            Ok::<_, Error>(header)
                        }
                    })
                    .filter_map(|h| async { h.transpose() });
                last_block_num = Some(end_block_num);
                Either::Right(previous_headers.chain(stream::once(async { Ok(header) })))
            })
        }
        /// How many keys/values to fetch at once.
        const STORAGE_PAGE_SIZE: u32 = 32;
        /// This provides a stream of values given some prefix `key`. It
        /// internally manages pagination and such.
        #[allow(clippy::type_complexity)]
        pub struct StorageFetchDescendantKeysStream<T: Config> {
            methods: LegacyRpcMethods<T>,
            key: Vec<u8>,
            at: T::Hash,
            pagination_start_key: Option<Vec<u8>>,
            keys_fut: Option<
                Pin<
                    Box<
                        dyn Future<Output = Result<Vec<Vec<u8>>, Error>> + Send + 'static,
                    >,
                >,
            >,
            done: bool,
        }
        impl<T: Config> std::marker::Unpin for StorageFetchDescendantKeysStream<T> {}
        impl<T: Config> Stream for StorageFetchDescendantKeysStream<T> {
            type Item = Result<Vec<Vec<u8>>, Error>;
            fn poll_next(
                mut self: Pin<&mut Self>,
                cx: &mut Context<'_>,
            ) -> Poll<Option<Self::Item>> {
                let mut this = self.as_mut();
                loop {
                    if this.done {
                        return Poll::Ready(None);
                    }
                    if let Some(mut keys_fut) = this.keys_fut.take() {
                        let Poll::Ready(keys) = keys_fut.poll_unpin(cx) else {
                        this.keys_fut = Some(keys_fut);
                        return Poll::Pending;
                    };
                        match keys {
                            Ok(keys) => {
                                if keys.is_empty() {
                                    this.done = true;
                                    return Poll::Ready(None);
                                }
                                this.pagination_start_key = keys.last().cloned();
                                return Poll::Ready(Some(Ok(keys)));
                            }
                            Err(e) => {
                                return Poll::Ready(Some(Err(e)));
                            }
                        }
                    }
                    let methods = this.methods.clone();
                    let key = this.key.clone();
                    let at = this.at;
                    let pagination_start_key = this.pagination_start_key.take();
                    let keys_fut = async move {
                        methods
                            .state_get_keys_paged(
                                &key,
                                STORAGE_PAGE_SIZE,
                                pagination_start_key.as_deref(),
                                Some(at),
                            )
                            .await
                    };
                    this.keys_fut = Some(Box::pin(keys_fut));
                }
            }
        }
        /// This provides a stream of values given some stream of keys.
        #[allow(clippy::type_complexity)]
        pub struct StorageFetchDescendantValuesStream<T: Config> {
            keys: StorageFetchDescendantKeysStream<T>,
            results_fut: Option<
                Pin<
                    Box<
                        dyn Future<
                            Output = Result<Option<VecDeque<(Vec<u8>, Vec<u8>)>>, Error>,
                        > + Send + 'static,
                    >,
                >,
            >,
            results: VecDeque<(Vec<u8>, Vec<u8>)>,
        }
        impl<T: Config> Stream for StorageFetchDescendantValuesStream<T> {
            type Item = Result<StorageResponse, Error>;
            fn poll_next(
                mut self: Pin<&mut Self>,
                cx: &mut Context<'_>,
            ) -> Poll<Option<Self::Item>> {
                let mut this = self.as_mut();
                loop {
                    if let Some((key, value)) = this.results.pop_front() {
                        let res = StorageResponse { key, value };
                        return Poll::Ready(Some(Ok(res)));
                    }
                    if let Some(mut results_fut) = this.results_fut.take() {
                        match results_fut.poll_unpin(cx) {
                            Poll::Ready(Ok(Some(results))) => {
                                this.results = results;
                                continue;
                            }
                            Poll::Ready(Ok(None)) => {
                                continue;
                            }
                            Poll::Ready(Err(e)) => return Poll::Ready(Some(Err(e))),
                            Poll::Pending => {
                                this.results_fut = Some(results_fut);
                                return Poll::Pending;
                            }
                        }
                    }
                    match this.keys.poll_next_unpin(cx) {
                        Poll::Ready(Some(Ok(keys))) => {
                            let methods = this.keys.methods.clone();
                            let at = this.keys.at;
                            let results_fut = async move {
                                let keys = keys.iter().map(|k| &**k);
                                let values = methods
                                    .state_query_storage_at(keys, Some(at))
                                    .await?;
                                let values: VecDeque<_> = values
                                    .into_iter()
                                    .flat_map(|v| {
                                        v.changes
                                            .into_iter()
                                            .filter_map(|(k, v)| {
                                                let v = v?;
                                                Some((k.0, v.0))
                                            })
                                    })
                                    .collect();
                                Ok(Some(values))
                            };
                            this.results_fut = Some(Box::pin(results_fut));
                            continue;
                        }
                        Poll::Ready(Some(Err(e))) => return Poll::Ready(Some(Err(e))),
                        Poll::Ready(None) => return Poll::Ready(None),
                        Poll::Pending => return Poll::Pending,
                    }
                }
            }
        }
    }
    pub mod rpc {
        //! RPC types and client for interacting with a substrate node.
        //!
        //! These are used behind the scenes by Subxt backend implementations, for
        //! example [`crate::backend::legacy::LegacyBackend`]. If you need an RPC client,
        //! then you can manually instantiate one, and then hand it to Subxt if you'd like
        //! to re-use it for the Subxt connection.
        //!
        //! - [`RpcClientT`] is the underlying dynamic RPC implementation. This provides
        //!   the low level [`RpcClientT::request_raw`] and [`RpcClientT::subscribe_raw`]
        //!   methods.
        //! - [`RpcClient`] is the higher level wrapper around this, offering
        //!   the [`RpcClient::request`] and [`RpcClient::subscribe`] methods.
        //!
        //! # Example
        //!
        //! Fetching the genesis hash.
        //!
        //! ```no_run
        //! # #[tokio::main]
        //! # async fn main() {
        //! use subxt::{
        //!     client::OnlineClient,
        //!     config::SubstrateConfig,
        //!     backend::rpc::RpcClient,
        //!     backend::legacy::LegacyRpcMethods,
        //! };
        //!
        //! // Instantiate a default RPC client pointing at some URL.
        //! let rpc_client = RpcClient::from_url("ws://localhost:9944")
        //!     .await
        //!     .unwrap();
        //!
        //! // Instantiate the legacy RPC interface, providing an appropriate
        //! // config so that it uses the correct types for your chain.
        //! let rpc_methods = LegacyRpcMethods::<SubstrateConfig>::new(rpc_client.clone());
        //!
        //! // Use it to make RPC calls, here using the legacy genesis_hash method.
        //! let genesis_hash = rpc_methods
        //!     .genesis_hash()
        //!     .await
        //!     .unwrap();
        //!
        //! println!("{genesis_hash}");
        //!
        //! // Instantiate the Subxt interface using the same client and config if you
        //! // want to reuse the same connection:
        //! let client = OnlineClient::<SubstrateConfig>::from_rpc_client(rpc_client);
        //! # }
        //! ```
        #![allow(clippy::module_inception)]
        #[cfg(feature = "jsonrpsee")]
        mod jsonrpsee_impl {
            use super::{RawRpcFuture, RawRpcSubscription, RpcClientT};
            use crate::error::RpcError;
            use futures::stream::{StreamExt, TryStreamExt};
            use jsonrpsee::{
                core::{
                    client::{Client, ClientT, SubscriptionClientT, SubscriptionKind},
                    traits::ToRpcParams,
                },
                types::SubscriptionId,
            };
            use serde_json::value::RawValue;
            struct Params(Option<Box<RawValue>>);
            impl ToRpcParams for Params {
                fn to_rpc_params(
                    self,
                ) -> Result<Option<Box<RawValue>>, serde_json::Error> {
                    Ok(self.0)
                }
            }
            impl RpcClientT for Client {
                fn request_raw<'a>(
                    &'a self,
                    method: &'a str,
                    params: Option<Box<RawValue>>,
                ) -> RawRpcFuture<'a, Box<RawValue>> {
                    Box::pin(async move {
                        let res = ClientT::request(self, method, Params(params))
                            .await
                            .map_err(|e| RpcError::ClientError(Box::new(e)))?;
                        Ok(res)
                    })
                }
                fn subscribe_raw<'a>(
                    &'a self,
                    sub: &'a str,
                    params: Option<Box<RawValue>>,
                    unsub: &'a str,
                ) -> RawRpcFuture<'a, RawRpcSubscription> {
                    Box::pin(async move {
                        let stream = SubscriptionClientT::subscribe::<
                            Box<RawValue>,
                            _,
                        >(self, sub, Params(params), unsub)
                            .await
                            .map_err(|e| RpcError::ClientError(Box::new(e)))?;
                        let id = match stream.kind() {
                            SubscriptionKind::Subscription(SubscriptionId::Str(id)) => {
                                Some(id.clone().into_owned())
                            }
                            _ => None,
                        };
                        let stream = stream
                            .map_err(|e| RpcError::ClientError(Box::new(e)))
                            .boxed();
                        Ok(RawRpcSubscription { stream, id })
                    })
                }
            }
        }
        mod rpc_client {
            use super::{RawRpcSubscription, RpcClientT};
            use crate::error::Error;
            use futures::{Stream, StreamExt};
            use serde::{de::DeserializeOwned, Serialize};
            use serde_json::value::RawValue;
            use std::{pin::Pin, sync::Arc, task::Poll};
            /// A concrete wrapper around an [`RpcClientT`] which provides some higher level helper methods,
            /// is cheaply cloneable, and can be handed to things like [`crate::client::OnlineClient`] to
            /// instantiate it.
            pub struct RpcClient {
                client: Arc<dyn RpcClientT>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RpcClient {
                #[inline]
                fn clone(&self) -> RpcClient {
                    RpcClient {
                        client: ::core::clone::Clone::clone(&self.client),
                    }
                }
            }
            impl RpcClient {
                #[cfg(feature = "jsonrpsee")]
                /// Create a default RPC client pointed at some URL, currently based on [`jsonrpsee`].
                ///
                /// Errors if an insecure URL is provided. In this case, use [`RpcClient::from_insecure_url`] instead.
                pub async fn from_url<U: AsRef<str>>(url: U) -> Result<Self, Error> {
                    crate::utils::validate_url_is_secure(url.as_ref())?;
                    RpcClient::from_insecure_url(url).await
                }
                #[cfg(feature = "jsonrpsee")]
                /// Create a default RPC client pointed at some URL, currently based on [`jsonrpsee`].
                ///
                /// Allows insecure URLs without SSL encryption, e.g. (http:// and ws:// URLs).
                pub async fn from_insecure_url<U: AsRef<str>>(
                    url: U,
                ) -> Result<Self, Error> {
                    let client = jsonrpsee_helpers::client(url.as_ref())
                        .await
                        .map_err(|e| crate::error::RpcError::ClientError(Box::new(e)))?;
                    Ok(Self::new(client))
                }
                /// Create a new [`RpcClient`] from an arbitrary [`RpcClientT`] implementation.
                pub fn new<R: RpcClientT>(client: R) -> Self {
                    RpcClient {
                        client: Arc::new(client),
                    }
                }
                /// Make an RPC request, given a method name and some parameters.
                ///
                /// See [`RpcParams`] and the [`rpc_params!`] macro for an example of how to
                /// construct the parameters.
                pub async fn request<Res: DeserializeOwned>(
                    &self,
                    method: &str,
                    params: RpcParams,
                ) -> Result<Res, Error> {
                    let res = self.client.request_raw(method, params.build()).await?;
                    let val = serde_json::from_str(res.get())?;
                    Ok(val)
                }
                /// Subscribe to an RPC endpoint, providing the parameters and the method to call to
                /// unsubscribe from it again.
                ///
                /// See [`RpcParams`] and the [`rpc_params!`] macro for an example of how to
                /// construct the parameters.
                pub async fn subscribe<Res: DeserializeOwned>(
                    &self,
                    sub: &str,
                    params: RpcParams,
                    unsub: &str,
                ) -> Result<RpcSubscription<Res>, Error> {
                    let sub = self
                        .client
                        .subscribe_raw(sub, params.build(), unsub)
                        .await?;
                    Ok(RpcSubscription::new(sub))
                }
            }
            impl std::fmt::Debug for RpcClient {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.debug_tuple("RpcClient").finish()
                }
            }
            impl std::ops::Deref for RpcClient {
                type Target = dyn RpcClientT;
                fn deref(&self) -> &Self::Target {
                    &*self.client
                }
            }
            pub use rpc_params;
            /// This represents the parameters passed to an [`RpcClient`], and exists to
            /// enforce that parameters are provided in the correct format.
            ///
            /// Prefer to use the [`rpc_params!`] macro for simpler creation of these.
            ///
            /// # Example
            ///
            /// ```rust
            /// use subxt::backend::rpc::RpcParams;
            ///
            /// let mut params = RpcParams::new();
            /// params.push(1).unwrap();
            /// params.push(true).unwrap();
            /// params.push("foo").unwrap();
            ///
            /// assert_eq!(params.build().unwrap().get(), "[1,true,\"foo\"]");
            /// ```
            pub struct RpcParams(Vec<u8>);
            #[automatically_derived]
            impl ::core::fmt::Debug for RpcParams {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RpcParams",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RpcParams {
                #[inline]
                fn clone(&self) -> RpcParams {
                    RpcParams(::core::clone::Clone::clone(&self.0))
                }
            }
            #[automatically_derived]
            impl ::core::default::Default for RpcParams {
                #[inline]
                fn default() -> RpcParams {
                    RpcParams(::core::default::Default::default())
                }
            }
            impl RpcParams {
                /// Create a new empty set of [`RpcParams`].
                pub fn new() -> Self {
                    Self(Vec::new())
                }
                /// Push a parameter into our [`RpcParams`]. This serializes it to JSON
                /// in the process, and so will return an error if this is not possible.
                pub fn push<P: Serialize>(&mut self, param: P) -> Result<(), Error> {
                    if self.0.is_empty() {
                        self.0.push(b'[');
                    } else {
                        self.0.push(b',')
                    }
                    serde_json::to_writer(&mut self.0, &param)?;
                    Ok(())
                }
                /// Build a [`RawValue`] from our params, returning `None` if no parameters
                /// were provided.
                pub fn build(mut self) -> Option<Box<RawValue>> {
                    if self.0.is_empty() {
                        None
                    } else {
                        self.0.push(b']');
                        let s = unsafe { String::from_utf8_unchecked(self.0) };
                        Some(RawValue::from_string(s).expect("Should be valid JSON"))
                    }
                }
            }
            /// A generic RPC Subscription. This implements [`Stream`], and so most of
            /// the functionality you'll need to interact with it comes from the
            /// [`StreamExt`] extension trait.
            pub struct RpcSubscription<Res> {
                inner: RawRpcSubscription,
                _marker: std::marker::PhantomData<Res>,
            }
            impl<Res> std::fmt::Debug for RpcSubscription<Res> {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.debug_struct("RpcSubscription")
                        .field("inner", &"RawRpcSubscription")
                        .field("_marker", &self._marker)
                        .finish()
                }
            }
            impl<Res> RpcSubscription<Res> {
                /// Creates a new [`RpcSubscription`].
                pub fn new(inner: RawRpcSubscription) -> Self {
                    Self {
                        inner,
                        _marker: std::marker::PhantomData,
                    }
                }
                /// Obtain the ID associated with this subscription.
                pub fn subscription_id(&self) -> Option<&str> {
                    self.inner.id.as_deref()
                }
            }
            impl<Res: DeserializeOwned> RpcSubscription<Res> {
                /// Returns the next item in the stream. This is just a wrapper around
                /// [`StreamExt::next()`] so that you can avoid the extra import.
                pub async fn next(&mut self) -> Option<Result<Res, Error>> {
                    StreamExt::next(self).await
                }
            }
            impl<Res> std::marker::Unpin for RpcSubscription<Res> {}
            impl<Res: DeserializeOwned> Stream for RpcSubscription<Res> {
                type Item = Result<Res, Error>;
                fn poll_next(
                    mut self: Pin<&mut Self>,
                    cx: &mut std::task::Context<'_>,
                ) -> Poll<Option<Self::Item>> {
                    let res = match self.inner.stream.poll_next_unpin(cx) {
                        ::futures_core::task::Poll::Ready(t) => t,
                        ::futures_core::task::Poll::Pending => {
                            return ::futures_core::task::Poll::Pending;
                        }
                    };
                    let res = res
                        .map(|r| {
                            r.map_err(|e| e.into())
                                .and_then(|raw_val| {
                                    serde_json::from_str(raw_val.get()).map_err(|e| e.into())
                                })
                        });
                    Poll::Ready(res)
                }
            }
            #[cfg(all(feature = "jsonrpsee", feature = "native"))]
            mod jsonrpsee_helpers {
                pub use jsonrpsee::{
                    client_transport::ws::{
                        self, EitherStream, Url, WsTransportClientBuilder,
                    },
                    core::client::{Client, Error},
                };
                use tokio_util::compat::Compat;
                pub type Sender = ws::Sender<Compat<EitherStream>>;
                pub type Receiver = ws::Receiver<Compat<EitherStream>>;
                /// Build WS RPC client from URL
                pub async fn client(url: &str) -> Result<Client, Error> {
                    let (sender, receiver) = ws_transport(url).await?;
                    Ok(
                        Client::builder()
                            .max_buffer_capacity_per_subscription(4096)
                            .build_with_tokio(sender, receiver),
                    )
                }
                async fn ws_transport(url: &str) -> Result<(Sender, Receiver), Error> {
                    let url = Url::parse(url).map_err(|e| Error::Transport(e.into()))?;
                    WsTransportClientBuilder::default()
                        .build(url)
                        .await
                        .map_err(|e| Error::Transport(e.into()))
                }
            }
        }
        mod rpc_client_t {
            use crate::error::RpcError;
            use futures::Stream;
            use std::{future::Future, pin::Pin};
            pub use serde_json::value::RawValue;
            /// A trait describing low level JSON-RPC interactions. Implementations of this can be
            /// used to instantiate a [`super::RpcClient`], which can be passed to [`crate::OnlineClient`]
            /// or used for lower level RPC calls via eg [`crate::backend::legacy::LegacyRpcMethods`].
            ///
            /// This is a low level interface whose methods expect an already-serialized set of params,
            /// and return an owned but still-serialized [`RawValue`], deferring deserialization to
            /// the caller. This is the case because we want the methods to be object-safe (which prohibits
            /// generics), and want to avoid any unnecessary allocations in serializing/deserializing
            /// parameters.
            ///
            /// # Panics
            ///
            /// Implementations are free to panic if the `RawValue`'s passed to `request_raw` or
            /// `subscribe_raw` are not JSON arrays. Internally, we ensure that this is always the case.
            pub trait RpcClientT: Send + Sync + 'static {
                /// Make a raw request for which we expect a single response back from. Implementations
                /// should expect that the params will either be `None`, or be an already-serialized
                /// JSON array of parameters.
                ///
                /// See [`super::RpcParams`] and the [`super::rpc_params!`] macro for an example of how to
                /// construct the parameters.
                ///
                /// Prefer to use the interface provided on [`super::RpcClient`] where possible.
                fn request_raw<'a>(
                    &'a self,
                    method: &'a str,
                    params: Option<Box<RawValue>>,
                ) -> RawRpcFuture<'a, Box<RawValue>>;
                /// Subscribe to some method. Implementations should expect that the params will
                /// either be `None`, or be an already-serialized JSON array of parameters.
                ///
                /// See [`super::RpcParams`] and the [`super::rpc_params!`] macro for an example of how to
                /// construct the parameters.
                ///
                /// Prefer to use the interface provided on [`super::RpcClient`] where possible.
                fn subscribe_raw<'a>(
                    &'a self,
                    sub: &'a str,
                    params: Option<Box<RawValue>>,
                    unsub: &'a str,
                ) -> RawRpcFuture<'a, RawRpcSubscription>;
            }
            /// A boxed future that is returned from the [`RpcClientT`] methods.
            pub type RawRpcFuture<'a, T> = Pin<
                Box<dyn Future<Output = Result<T, RpcError>> + Send + 'a>,
            >;
            /// The RPC subscription returned from [`RpcClientT`]'s `subscription` method.
            pub struct RawRpcSubscription {
                /// The subscription stream.
                pub stream: Pin<
                    Box<
                        dyn Stream<
                            Item = Result<Box<RawValue>, RpcError>,
                        > + Send + 'static,
                    >,
                >,
                /// The ID associated with the subscription.
                pub id: Option<String>,
            }
            impl<T: RpcClientT> RpcClientT for std::sync::Arc<T> {
                fn request_raw<'a>(
                    &'a self,
                    method: &'a str,
                    params: Option<Box<RawValue>>,
                ) -> RawRpcFuture<'a, Box<RawValue>> {
                    (**self).request_raw(method, params)
                }
                fn subscribe_raw<'a>(
                    &'a self,
                    sub: &'a str,
                    params: Option<Box<RawValue>>,
                    unsub: &'a str,
                ) -> RawRpcFuture<'a, RawRpcSubscription> {
                    (**self).subscribe_raw(sub, params, unsub)
                }
            }
            impl<T: RpcClientT> RpcClientT for Box<T> {
                fn request_raw<'a>(
                    &'a self,
                    method: &'a str,
                    params: Option<Box<RawValue>>,
                ) -> RawRpcFuture<'a, Box<RawValue>> {
                    (**self).request_raw(method, params)
                }
                fn subscribe_raw<'a>(
                    &'a self,
                    sub: &'a str,
                    params: Option<Box<RawValue>>,
                    unsub: &'a str,
                ) -> RawRpcFuture<'a, RawRpcSubscription> {
                    (**self).subscribe_raw(sub, params, unsub)
                }
            }
        }
        pub use rpc_client::{rpc_params, RpcClient, RpcParams, RpcSubscription};
        pub use rpc_client_t::{RawRpcFuture, RawRpcSubscription, RawValue, RpcClientT};
    }
    pub mod unstable {
        //! This module will expose a backend implementation based on the new APIs
        //! described at <https://github.com/paritytech/json-rpc-interface-spec/>. See
        //! [`rpc_methods`] for the raw API calls.
        //!
        //! # Warning
        //!
        //! Everything in this module is **unstable**, meaning that it could change without
        //! warning at any time.
        mod follow_stream {
            use super::rpc_methods::{FollowEvent, UnstableRpcMethods};
            use crate::config::Config;
            use crate::error::Error;
            use futures::{FutureExt, Stream, StreamExt};
            use std::future::Future;
            use std::pin::Pin;
            use std::task::{Context, Poll};
            /// A `Stream` whose goal is to remain subscribed to `chainHead_follow`. It will re-subscribe if the subscription
            /// is ended for any reason, and it will return the current `subscription_id` as an event, along with the other
            /// follow events.
            pub struct FollowStream<Hash> {
                stream_getter: FollowEventStreamGetter<Hash>,
                stream: InnerStreamState<Hash>,
            }
            impl<Hash> std::fmt::Debug for FollowStream<Hash> {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.debug_struct("FollowStream")
                        .field("stream_getter", &"..")
                        .field("stream", &self.stream)
                        .finish()
                }
            }
            /// A getter function that returns an [`FollowEventStreamFut<Hash>`].
            pub type FollowEventStreamGetter<Hash> = Box<
                dyn FnMut() -> FollowEventStreamFut<Hash> + Send,
            >;
            /// The future which will return a stream of follow events and the subscription ID for it.
            pub type FollowEventStreamFut<Hash> = Pin<
                Box<
                    dyn Future<
                        Output = Result<(FollowEventStream<Hash>, String), Error>,
                    > + Send + 'static,
                >,
            >;
            /// The stream of follow events.
            pub type FollowEventStream<Hash> = Pin<
                Box<dyn Stream<Item = Result<FollowEvent<Hash>, Error>> + Send + 'static>,
            >;
            /// Either a ready message with the current subscription ID, or
            /// an event from the stream itself.
            pub enum FollowStreamMsg<Hash> {
                /// The stream is ready (and has a subscription ID)
                Ready(String),
                /// An event from the stream.
                Event(FollowEvent<Hash>),
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug for FollowStreamMsg<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        FollowStreamMsg::Ready(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Ready",
                                &__self_0,
                            )
                        }
                        FollowStreamMsg::Event(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Event",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone> ::core::clone::Clone
            for FollowStreamMsg<Hash> {
                #[inline]
                fn clone(&self) -> FollowStreamMsg<Hash> {
                    match self {
                        FollowStreamMsg::Ready(__self_0) => {
                            FollowStreamMsg::Ready(::core::clone::Clone::clone(__self_0))
                        }
                        FollowStreamMsg::Event(__self_0) => {
                            FollowStreamMsg::Event(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<Hash> ::core::marker::StructuralPartialEq for FollowStreamMsg<Hash> {}
            #[automatically_derived]
            impl<Hash: ::core::cmp::PartialEq> ::core::cmp::PartialEq
            for FollowStreamMsg<Hash> {
                #[inline]
                fn eq(&self, other: &FollowStreamMsg<Hash>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                FollowStreamMsg::Ready(__self_0),
                                FollowStreamMsg::Ready(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FollowStreamMsg::Event(__self_0),
                                FollowStreamMsg::Event(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::cmp::Eq> ::core::cmp::Eq for FollowStreamMsg<Hash> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                    let _: ::core::cmp::AssertParamIsEq<FollowEvent<Hash>>;
                }
            }
            impl<Hash> FollowStreamMsg<Hash> {
                /// Return an event, or none if the message is a "ready" one.
                pub fn into_event(self) -> Option<FollowEvent<Hash>> {
                    match self {
                        FollowStreamMsg::Ready(_) => None,
                        FollowStreamMsg::Event(e) => Some(e),
                    }
                }
            }
            enum InnerStreamState<Hash> {
                /// We've just created the stream; we'll start Initializing it
                New,
                /// We're fetching the inner subscription. Move to Ready when we have one.
                Initializing(FollowEventStreamFut<Hash>),
                /// Report back the subscription ID here, and then start ReceivingEvents.
                Ready(Option<(FollowEventStream<Hash>, String)>),
                /// We are polling for, and receiving events from the stream.
                ReceivingEvents(FollowEventStream<Hash>),
                /// We received a stop event. We'll send one on and restart the stream.
                Stopped,
                /// The stream is finished and will not restart (likely due to an error).
                Finished,
            }
            impl<Hash> std::fmt::Debug for InnerStreamState<Hash> {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    match self {
                        Self::New => f.write_fmt(format_args!("New")),
                        Self::Initializing(_) => {
                            f.write_fmt(format_args!("Initializing(..)"))
                        }
                        Self::Ready(_) => f.write_fmt(format_args!("Ready(..)")),
                        Self::ReceivingEvents(_) => {
                            f.write_fmt(format_args!("ReceivingEvents(..)"))
                        }
                        Self::Stopped => f.write_fmt(format_args!("Stopped")),
                        Self::Finished => f.write_fmt(format_args!("Finished")),
                    }
                }
            }
            impl<Hash> FollowStream<Hash> {
                /// Create a new [`FollowStream`] given a function which returns the stream.
                pub fn new(stream_getter: FollowEventStreamGetter<Hash>) -> Self {
                    Self {
                        stream_getter,
                        stream: InnerStreamState::New,
                    }
                }
                /// Create a new [`FollowStream`] given the RPC methods.
                pub fn from_methods<T: Config>(
                    methods: UnstableRpcMethods<T>,
                ) -> FollowStream<T::Hash> {
                    FollowStream {
                        stream_getter: Box::new(move || {
                            let methods = methods.clone();
                            Box::pin(async move {
                                let stream = methods.chainhead_unstable_follow(true).await?;
                                let Some(sub_id) = stream
                                    .subscription_id()
                                    .map(ToOwned::to_owned) else {
                                return Err(
                                    Error::Other(
                                        "Subscription ID expected for chainHead_follow response, but not given"
                                            .to_owned(),
                                    ),
                                );
                            };
                                let stream: FollowEventStream<T::Hash> = Box::pin(stream);
                                Ok((stream, sub_id))
                            })
                        }),
                        stream: InnerStreamState::New,
                    }
                }
            }
            impl<Hash> std::marker::Unpin for FollowStream<Hash> {}
            impl<Hash> Stream for FollowStream<Hash> {
                type Item = Result<FollowStreamMsg<Hash>, Error>;
                fn poll_next(
                    self: Pin<&mut Self>,
                    cx: &mut Context<'_>,
                ) -> Poll<Option<Self::Item>> {
                    let this = self.get_mut();
                    loop {
                        match &mut this.stream {
                            InnerStreamState::New => {
                                let fut = (this.stream_getter)();
                                this.stream = InnerStreamState::Initializing(fut);
                                continue;
                            }
                            InnerStreamState::Initializing(fut) => {
                                match fut.poll_unpin(cx) {
                                    Poll::Pending => {
                                        return Poll::Pending;
                                    }
                                    Poll::Ready(Ok(sub_with_id)) => {
                                        this.stream = InnerStreamState::Ready(Some(sub_with_id));
                                        continue;
                                    }
                                    Poll::Ready(Err(e)) => {
                                        this.stream = InnerStreamState::Finished;
                                        return Poll::Ready(Some(Err(e)));
                                    }
                                }
                            }
                            InnerStreamState::Ready(stream) => {
                                let (sub, sub_id) = stream
                                    .take()
                                    .expect("should always be Some");
                                this.stream = InnerStreamState::ReceivingEvents(sub);
                                return Poll::Ready(
                                    Some(Ok(FollowStreamMsg::Ready(sub_id))),
                                );
                            }
                            InnerStreamState::ReceivingEvents(stream) => {
                                match stream.poll_next_unpin(cx) {
                                    Poll::Pending => {
                                        return Poll::Pending;
                                    }
                                    Poll::Ready(None) => {
                                        this.stream = InnerStreamState::Stopped;
                                        continue;
                                    }
                                    Poll::Ready(Some(Ok(ev))) => {
                                        if let FollowEvent::Stop = ev {
                                            this.stream = InnerStreamState::Stopped;
                                            continue;
                                        }
                                        return Poll::Ready(Some(Ok(FollowStreamMsg::Event(ev))));
                                    }
                                    Poll::Ready(Some(Err(e))) => {
                                        this.stream = InnerStreamState::Finished;
                                        return Poll::Ready(Some(Err(e)));
                                    }
                                }
                            }
                            InnerStreamState::Stopped => {
                                this.stream = InnerStreamState::New;
                                return Poll::Ready(
                                    Some(Ok(FollowStreamMsg::Event(FollowEvent::Stop))),
                                );
                            }
                            InnerStreamState::Finished => {
                                return Poll::Ready(None);
                            }
                        }
                    }
                }
            }
        }
        mod follow_stream_driver {
            use super::follow_stream_unpin::{
                BlockRef, FollowStreamMsg, FollowStreamUnpin,
            };
            use crate::backend::unstable::rpc_methods::{
                FollowEvent, Initialized, RuntimeEvent,
            };
            use crate::config::BlockHash;
            use crate::error::Error;
            use futures::stream::{Stream, StreamExt};
            use std::collections::{HashMap, HashSet, VecDeque};
            use std::ops::DerefMut;
            use std::pin::Pin;
            use std::sync::{Arc, Mutex};
            use std::task::{Context, Poll, Waker};
            /// A `Stream` which builds on `FollowStreamDriver`, and allows multiple subscribers to obtain events
            /// from the single underlying subscription (each being provided an `Initialized` message and all new
            /// blocks since then, as if they were each creating a unique `chainHead_follow` subscription). This
            /// is the "top" layer of our follow stream subscriptions, and the one that's interacted with elsewhere.
            pub struct FollowStreamDriver<Hash: BlockHash> {
                inner: FollowStreamUnpin<Hash>,
                shared: Shared<Hash>,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug + BlockHash> ::core::fmt::Debug
            for FollowStreamDriver<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "FollowStreamDriver",
                        "inner",
                        &self.inner,
                        "shared",
                        &&self.shared,
                    )
                }
            }
            impl<Hash: BlockHash> FollowStreamDriver<Hash> {
                /// Create a new [`FollowStreamDriver`]. This must be polled by some executor
                /// in order for any progress to be made. Things can subscribe to events.
                pub fn new(follow_unpin: FollowStreamUnpin<Hash>) -> Self {
                    Self {
                        inner: follow_unpin,
                        shared: Shared::default(),
                    }
                }
                /// Return a handle from which we can create new subscriptions to follow events.
                pub fn handle(&self) -> FollowStreamDriverHandle<Hash> {
                    FollowStreamDriverHandle {
                        shared: self.shared.clone(),
                    }
                }
            }
            impl<Hash: BlockHash> Stream for FollowStreamDriver<Hash> {
                type Item = Result<(), Error>;
                fn poll_next(
                    mut self: Pin<&mut Self>,
                    cx: &mut Context<'_>,
                ) -> Poll<Option<Self::Item>> {
                    match self.inner.poll_next_unpin(cx) {
                        Poll::Pending => Poll::Pending,
                        Poll::Ready(None) => {
                            self.shared.done();
                            Poll::Ready(None)
                        }
                        Poll::Ready(Some(Err(e))) => Poll::Ready(Some(Err(e))),
                        Poll::Ready(Some(Ok(item))) => {
                            self.shared.push_item(item);
                            Poll::Ready(Some(Ok(())))
                        }
                    }
                }
            }
            /// A handle that can be used to create subscribers, but that doesn't
            /// itself subscribe to events.
            pub struct FollowStreamDriverHandle<Hash: BlockHash> {
                shared: Shared<Hash>,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug + BlockHash> ::core::fmt::Debug
            for FollowStreamDriverHandle<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "FollowStreamDriverHandle",
                        "shared",
                        &&self.shared,
                    )
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone + BlockHash> ::core::clone::Clone
            for FollowStreamDriverHandle<Hash> {
                #[inline]
                fn clone(&self) -> FollowStreamDriverHandle<Hash> {
                    FollowStreamDriverHandle {
                        shared: ::core::clone::Clone::clone(&self.shared),
                    }
                }
            }
            impl<Hash: BlockHash> FollowStreamDriverHandle<Hash> {
                /// Subscribe to follow events.
                pub fn subscribe(&self) -> FollowStreamDriverSubscription<Hash> {
                    self.shared.subscribe()
                }
            }
            /// A subscription to events from the [`FollowStreamDriver`]. All subscriptions
            /// begin first with a `Ready` event containing the current subscription ID, and
            /// then with an `Initialized` event containing the latest finalized block and latest
            /// runtime information, and then any new/best block events and so on received since
            /// the latest finalized block.
            pub struct FollowStreamDriverSubscription<Hash: BlockHash> {
                id: usize,
                done: bool,
                shared: Shared<Hash>,
                local_items: VecDeque<FollowStreamMsg<BlockRef<Hash>>>,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug + BlockHash> ::core::fmt::Debug
            for FollowStreamDriverSubscription<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "FollowStreamDriverSubscription",
                        "id",
                        &self.id,
                        "done",
                        &self.done,
                        "shared",
                        &self.shared,
                        "local_items",
                        &&self.local_items,
                    )
                }
            }
            impl<Hash: BlockHash> Stream for FollowStreamDriverSubscription<Hash> {
                type Item = FollowStreamMsg<BlockRef<Hash>>;
                fn poll_next(
                    mut self: Pin<&mut Self>,
                    cx: &mut Context<'_>,
                ) -> Poll<Option<Self::Item>> {
                    if self.done {
                        return Poll::Ready(None);
                    }
                    loop {
                        if let Some(item) = self.local_items.pop_front() {
                            return Poll::Ready(Some(item));
                        }
                        let items = self
                            .shared
                            .take_items_and_save_waker(self.id, cx.waker());
                        let Some(items) = items else { self.done = true;
                        return Poll::Ready(None);
                    };
                        if items.is_empty() {
                            return Poll::Pending;
                        } else {
                            self.local_items = items;
                        }
                    }
                }
            }
            impl<Hash: BlockHash> FollowStreamDriverSubscription<Hash> {
                /// Return the current subscription ID. If the subscription has stopped, then this will
                /// wait until a new subscription has started with a new ID.
                pub async fn subscription_id(self) -> Option<String> {
                    let ready_event = self
                        .skip_while(|ev| std::future::ready(
                            !match ev {
                                FollowStreamMsg::Ready(_) => true,
                                _ => false,
                            },
                        ))
                        .next()
                        .await?;
                    match ready_event {
                        FollowStreamMsg::Ready(sub_id) => Some(sub_id),
                        _ => None,
                    }
                }
                /// Subscribe to the follow events, ignoring any other messages.
                pub fn events(
                    self,
                ) -> impl Stream<Item = FollowEvent<BlockRef<Hash>>> + Send + Sync {
                    self.filter_map(|ev| std::future::ready(ev.into_event()))
                }
            }
            impl<Hash: BlockHash> Clone for FollowStreamDriverSubscription<Hash> {
                fn clone(&self) -> Self {
                    self.shared.subscribe()
                }
            }
            impl<Hash: BlockHash> Drop for FollowStreamDriverSubscription<Hash> {
                fn drop(&mut self) {
                    self.shared.remove_sub(self.id);
                }
            }
            /// Locked shared state. The driver stream will access this state to push
            /// events to any subscribers, and subscribers will access it to pull the
            /// events destined for themselves.
            struct Shared<Hash: BlockHash>(Arc<Mutex<SharedState<Hash>>>);
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug + BlockHash> ::core::fmt::Debug
            for Shared<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Shared",
                        &&self.0,
                    )
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone + BlockHash> ::core::clone::Clone
            for Shared<Hash> {
                #[inline]
                fn clone(&self) -> Shared<Hash> {
                    Shared(::core::clone::Clone::clone(&self.0))
                }
            }
            struct SharedState<Hash: BlockHash> {
                done: bool,
                next_id: usize,
                subscribers: HashMap<usize, SubscriberDetails<Hash>>,
                /// Keep a buffer of all events that should be handed to a new subscription.
                block_events_for_new_subscriptions: VecDeque<
                    FollowEvent<BlockRef<Hash>>,
                >,
                current_subscription_id: Option<String>,
                current_init_message: Option<Initialized<BlockRef<Hash>>>,
                seen_runtime_events: HashMap<Hash, RuntimeEvent>,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug + BlockHash> ::core::fmt::Debug
            for SharedState<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "done",
                        "next_id",
                        "subscribers",
                        "block_events_for_new_subscriptions",
                        "current_subscription_id",
                        "current_init_message",
                        "seen_runtime_events",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.done,
                        &self.next_id,
                        &self.subscribers,
                        &self.block_events_for_new_subscriptions,
                        &self.current_subscription_id,
                        &self.current_init_message,
                        &&self.seen_runtime_events,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "SharedState",
                        names,
                        values,
                    )
                }
            }
            impl<Hash: BlockHash> Default for Shared<Hash> {
                fn default() -> Self {
                    Shared(
                        Arc::new(
                            Mutex::new(SharedState {
                                next_id: 1,
                                done: false,
                                subscribers: HashMap::new(),
                                current_init_message: None,
                                current_subscription_id: None,
                                seen_runtime_events: HashMap::new(),
                                block_events_for_new_subscriptions: VecDeque::new(),
                            }),
                        ),
                    )
                }
            }
            impl<Hash: BlockHash> Shared<Hash> {
                /// Set the shared state to "done"; no more items will be handed to it.
                pub fn done(&self) {
                    let mut shared = self.0.lock().unwrap();
                    shared.done = true;
                }
                /// Cleanup a subscription.
                pub fn remove_sub(&self, sub_id: usize) {
                    let mut shared = self.0.lock().unwrap();
                    shared.subscribers.remove(&sub_id);
                }
                /// Take items for some subscription ID and save the waker.
                pub fn take_items_and_save_waker(
                    &self,
                    sub_id: usize,
                    waker: &Waker,
                ) -> Option<VecDeque<FollowStreamMsg<BlockRef<Hash>>>> {
                    let mut shared = self.0.lock().unwrap();
                    let is_done = shared.done;
                    let details = shared.subscribers.get_mut(&sub_id)?;
                    if details.items.is_empty() && is_done {
                        return None;
                    }
                    let items = std::mem::take(&mut details.items);
                    if !is_done {
                        details.waker = Some(waker.clone());
                    }
                    Some(items)
                }
                /// Push a new item out to subscribers.
                pub fn push_item(&self, item: FollowStreamMsg<BlockRef<Hash>>) {
                    let mut shared = self.0.lock().unwrap();
                    let shared = shared.deref_mut();
                    for details in shared.subscribers.values_mut() {
                        details.items.push_back(item.clone());
                        if let Some(waker) = details.waker.take() {
                            waker.wake();
                        }
                    }
                    match item {
                        FollowStreamMsg::Ready(sub_id) => {
                            shared.current_subscription_id = Some(sub_id);
                        }
                        FollowStreamMsg::Event(FollowEvent::Initialized(ev)) => {
                            shared.current_init_message = Some(ev.clone());
                            shared.block_events_for_new_subscriptions.clear();
                        }
                        FollowStreamMsg::Event(FollowEvent::Finalized(finalized_ev)) => {
                            if let Some(init_message) = &mut shared.current_init_message
                            {
                                let newest_runtime = finalized_ev
                                    .finalized_block_hashes
                                    .iter()
                                    .rev()
                                    .filter_map(|h| {
                                        shared.seen_runtime_events.get(&h.hash()).cloned()
                                    })
                                    .next();
                                shared.seen_runtime_events.clear();
                                if let Some(finalized)
                                    = finalized_ev.finalized_block_hashes.last()
                                {
                                    init_message.finalized_block_hash = finalized.clone();
                                }
                                if let Some(runtime_ev) = newest_runtime {
                                    init_message.finalized_block_runtime = Some(runtime_ev);
                                }
                            }
                            let to_remove: HashSet<Hash> = finalized_ev
                                .finalized_block_hashes
                                .iter()
                                .chain(finalized_ev.pruned_block_hashes.iter())
                                .map(|h| h.hash())
                                .collect();
                            shared
                                .block_events_for_new_subscriptions
                                .retain(|ev| match ev {
                                    FollowEvent::NewBlock(new_block_ev) => {
                                        !to_remove.contains(&new_block_ev.block_hash.hash())
                                    }
                                    FollowEvent::BestBlockChanged(best_block_ev) => {
                                        !to_remove.contains(&best_block_ev.best_block_hash.hash())
                                    }
                                    _ => true,
                                });
                        }
                        FollowStreamMsg::Event(FollowEvent::NewBlock(new_block_ev)) => {
                            if let Some(runtime_event) = &new_block_ev.new_runtime {
                                shared
                                    .seen_runtime_events
                                    .insert(
                                        new_block_ev.block_hash.hash(),
                                        runtime_event.clone(),
                                    );
                            }
                            shared
                                .block_events_for_new_subscriptions
                                .push_back(FollowEvent::NewBlock(new_block_ev));
                        }
                        FollowStreamMsg::Event(
                            ev @ FollowEvent::BestBlockChanged(_),
                        ) => {
                            shared.block_events_for_new_subscriptions.push_back(ev);
                        }
                        FollowStreamMsg::Event(FollowEvent::Stop) => {
                            shared.block_events_for_new_subscriptions.clear();
                            shared.current_subscription_id = None;
                            shared.current_init_message = None;
                        }
                        _ => {}
                    }
                }
                /// Create a new subscription.
                pub fn subscribe(&self) -> FollowStreamDriverSubscription<Hash> {
                    let mut shared = self.0.lock().unwrap();
                    let id = shared.next_id;
                    shared.next_id += 1;
                    shared
                        .subscribers
                        .insert(
                            id,
                            SubscriberDetails {
                                items: VecDeque::new(),
                                waker: None,
                            },
                        );
                    let mut local_items = VecDeque::new();
                    if let Some(sub_id) = &shared.current_subscription_id {
                        local_items.push_back(FollowStreamMsg::Ready(sub_id.clone()));
                    }
                    if let Some(init_msg) = &shared.current_init_message {
                        local_items
                            .push_back(
                                FollowStreamMsg::Event(
                                    FollowEvent::Initialized(init_msg.clone()),
                                ),
                            );
                    }
                    for ev in &shared.block_events_for_new_subscriptions {
                        local_items.push_back(FollowStreamMsg::Event(ev.clone()));
                    }
                    drop(shared);
                    FollowStreamDriverSubscription {
                        id,
                        done: false,
                        shared: self.clone(),
                        local_items,
                    }
                }
            }
            /// Details for a given subscriber: any items it's not yet claimed,
            /// and a way to wake it up when there are more items for it.
            struct SubscriberDetails<Hash: BlockHash> {
                items: VecDeque<FollowStreamMsg<BlockRef<Hash>>>,
                waker: Option<Waker>,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug + BlockHash> ::core::fmt::Debug
            for SubscriberDetails<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "SubscriberDetails",
                        "items",
                        &self.items,
                        "waker",
                        &&self.waker,
                    )
                }
            }
        }
        mod follow_stream_unpin {
            use super::follow_stream::FollowStream;
            use super::UnstableRpcMethods;
            use crate::backend::unstable::rpc_methods::{
                BestBlockChanged, Finalized, FollowEvent, Initialized, NewBlock,
            };
            use crate::config::{BlockHash, Config};
            use crate::error::Error;
            use futures::stream::{FuturesUnordered, Stream, StreamExt};
            use std::collections::{HashMap, HashSet};
            use std::future::Future;
            use std::pin::Pin;
            use std::sync::{Arc, Mutex};
            use std::task::{Context, Poll, Waker};
            /// The type of stream item.
            pub use super::follow_stream::FollowStreamMsg;
            /// A `Stream` which builds on `FollowStream`, and handles pinning. It replaces any block hash seen in
            /// the follow events with a `BlockRef` which, when all clones are dropped, will lead to an "unpin" call
            /// for that block hash being queued. It will also automatically unpin any blocks that exceed a given max
            /// age, to try and prevent the underlying stream from ending (and _all_ blocks from being unpinned as a
            /// result). Put simply, it tries to keep every block pinned as long as possible until the block is no longer
            /// used anywhere.
            pub struct FollowStreamUnpin<Hash: BlockHash> {
                inner: FollowStream<Hash>,
                unpin_method: UnpinMethodHolder<Hash>,
                unpin_futs: FuturesUnordered<UnpinFut>,
                rel_block_num: usize,
                subscription_id: Option<Arc<str>>,
                max_block_life: usize,
                pinned: HashMap<Hash, PinnedDetails<Hash>>,
                unpin_flags: UnpinFlags<Hash>,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug + BlockHash> ::core::fmt::Debug
            for FollowStreamUnpin<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "inner",
                        "unpin_method",
                        "unpin_futs",
                        "rel_block_num",
                        "subscription_id",
                        "max_block_life",
                        "pinned",
                        "unpin_flags",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.inner,
                        &self.unpin_method,
                        &self.unpin_futs,
                        &self.rel_block_num,
                        &self.subscription_id,
                        &self.max_block_life,
                        &self.pinned,
                        &&self.unpin_flags,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "FollowStreamUnpin",
                        names,
                        values,
                    )
                }
            }
            struct UnpinMethodHolder<Hash>(UnpinMethod<Hash>);
            impl<Hash> std::fmt::Debug for UnpinMethodHolder<Hash> {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.write_fmt(
                        format_args!(
                            "UnpinMethodHolder(Box<dyn FnMut(Hash, Arc<str>) -> UnpinFut>)"
                        ),
                    )
                }
            }
            /// The type of the unpin method that we need to provide.
            pub type UnpinMethod<Hash> = Box<
                dyn FnMut(Hash, Arc<str>) -> UnpinFut + Send,
            >;
            /// The future returned from [`UnpinMethod`].
            pub type UnpinFut = Pin<Box<dyn Future<Output = ()> + Send + 'static>>;
            impl<Hash: BlockHash> std::marker::Unpin for FollowStreamUnpin<Hash> {}
            impl<Hash: BlockHash> Stream for FollowStreamUnpin<Hash> {
                type Item = Result<FollowStreamMsg<BlockRef<Hash>>, Error>;
                fn poll_next(
                    mut self: Pin<&mut Self>,
                    cx: &mut Context<'_>,
                ) -> Poll<Option<Self::Item>> {
                    let mut this = self.as_mut();
                    loop {
                        let unpin_futs_are_pending = match this
                            .unpin_futs
                            .poll_next_unpin(cx)
                        {
                            Poll::Ready(Some(())) => continue,
                            Poll::Ready(None) => false,
                            Poll::Pending => true,
                        };
                        let Poll::Ready(ev) = this.inner.poll_next_unpin(cx) else {
                        return Poll::Pending;
                    };
                        let Some(ev) = ev else {
                        return match unpin_futs_are_pending {
                            true => Poll::Pending,
                            false => Poll::Ready(None),
                        };
                    };
                        let ev = match ev {
                            Ok(ev) => ev,
                            Err(e) => {
                                return Poll::Ready(Some(Err(e)));
                            }
                        };
                        let ev = match ev {
                            FollowStreamMsg::Ready(subscription_id) => {
                                this.subscription_id = Some(subscription_id.clone().into());
                                FollowStreamMsg::Ready(subscription_id)
                            }
                            FollowStreamMsg::Event(
                                FollowEvent::Initialized(details),
                            ) => {
                                let rel_block_num = this.rel_block_num;
                                let block_ref = this
                                    .pin_unpinnable_block_at(
                                        rel_block_num,
                                        details.finalized_block_hash,
                                    );
                                FollowStreamMsg::Event(
                                    FollowEvent::Initialized(Initialized {
                                        finalized_block_hash: block_ref,
                                        finalized_block_runtime: details.finalized_block_runtime,
                                    }),
                                )
                            }
                            FollowStreamMsg::Event(FollowEvent::NewBlock(details)) => {
                                let parent_rel_block_num = this
                                    .pinned
                                    .get(&details.parent_block_hash)
                                    .map(|p| p.rel_block_num)
                                    .unwrap_or(this.rel_block_num);
                                let block_ref = this
                                    .pin_block_at(parent_rel_block_num + 1, details.block_hash);
                                let parent_block_ref = this
                                    .pin_block_at(
                                        parent_rel_block_num,
                                        details.parent_block_hash,
                                    );
                                FollowStreamMsg::Event(
                                    FollowEvent::NewBlock(NewBlock {
                                        block_hash: block_ref,
                                        parent_block_hash: parent_block_ref,
                                        new_runtime: details.new_runtime,
                                    }),
                                )
                            }
                            FollowStreamMsg::Event(
                                FollowEvent::BestBlockChanged(details),
                            ) => {
                                let rel_block_num = this.rel_block_num + 1;
                                let block_ref = this
                                    .pin_block_at(rel_block_num, details.best_block_hash);
                                FollowStreamMsg::Event(
                                    FollowEvent::BestBlockChanged(BestBlockChanged {
                                        best_block_hash: block_ref,
                                    }),
                                )
                            }
                            FollowStreamMsg::Event(FollowEvent::Finalized(details)) => {
                                let finalized_block_refs: Vec<_> = details
                                    .finalized_block_hashes
                                    .into_iter()
                                    .enumerate()
                                    .map(|(idx, hash)| {
                                        let rel_block_num = this.rel_block_num + idx + 1;
                                        this.pin_unpinnable_block_at(rel_block_num, hash)
                                    })
                                    .collect();
                                this.rel_block_num += finalized_block_refs.len();
                                let pruned_block_refs: Vec<_> = details
                                    .pruned_block_hashes
                                    .into_iter()
                                    .map(|hash| {
                                        let rel_block_num = this.rel_block_num + 1;
                                        this.pin_unpinnable_block_at(rel_block_num, hash)
                                    })
                                    .collect();
                                this.unpin_blocks(cx.waker());
                                FollowStreamMsg::Event(
                                    FollowEvent::Finalized(Finalized {
                                        finalized_block_hashes: finalized_block_refs,
                                        pruned_block_hashes: pruned_block_refs,
                                    }),
                                )
                            }
                            FollowStreamMsg::Event(FollowEvent::Stop) => {
                                this.subscription_id = None;
                                this.pinned.clear();
                                this.unpin_futs.clear();
                                this.unpin_flags.lock().unwrap().clear();
                                this.rel_block_num = 0;
                                FollowStreamMsg::Event(FollowEvent::Stop)
                            }
                            FollowStreamMsg::Event(
                                FollowEvent::OperationBodyDone(details),
                            ) => {
                                FollowStreamMsg::Event(
                                    FollowEvent::OperationBodyDone(details),
                                )
                            }
                            FollowStreamMsg::Event(
                                FollowEvent::OperationCallDone(details),
                            ) => {
                                FollowStreamMsg::Event(
                                    FollowEvent::OperationCallDone(details),
                                )
                            }
                            FollowStreamMsg::Event(
                                FollowEvent::OperationStorageItems(details),
                            ) => {
                                FollowStreamMsg::Event(
                                    FollowEvent::OperationStorageItems(details),
                                )
                            }
                            FollowStreamMsg::Event(
                                FollowEvent::OperationWaitingForContinue(details),
                            ) => {
                                FollowStreamMsg::Event(
                                    FollowEvent::OperationWaitingForContinue(details),
                                )
                            }
                            FollowStreamMsg::Event(
                                FollowEvent::OperationStorageDone(details),
                            ) => {
                                FollowStreamMsg::Event(
                                    FollowEvent::OperationStorageDone(details),
                                )
                            }
                            FollowStreamMsg::Event(
                                FollowEvent::OperationInaccessible(details),
                            ) => {
                                FollowStreamMsg::Event(
                                    FollowEvent::OperationInaccessible(details),
                                )
                            }
                            FollowStreamMsg::Event(
                                FollowEvent::OperationError(details),
                            ) => {
                                FollowStreamMsg::Event(FollowEvent::OperationError(details))
                            }
                        };
                        return Poll::Ready(Some(Ok(ev)));
                    }
                }
            }
            impl<Hash: BlockHash> FollowStreamUnpin<Hash> {
                /// Create a new [`FollowStreamUnpin`].
                pub fn new(
                    follow_stream: FollowStream<Hash>,
                    unpin_method: UnpinMethod<Hash>,
                    max_block_life: usize,
                ) -> Self {
                    Self {
                        inner: follow_stream,
                        unpin_method: UnpinMethodHolder(unpin_method),
                        max_block_life,
                        pinned: Default::default(),
                        subscription_id: None,
                        rel_block_num: 0,
                        unpin_flags: Default::default(),
                        unpin_futs: Default::default(),
                    }
                }
                /// Create a new [`FollowStreamUnpin`] given the RPC methods.
                pub fn from_methods<T: Config>(
                    follow_stream: FollowStream<T::Hash>,
                    methods: UnstableRpcMethods<T>,
                    max_block_life: usize,
                ) -> FollowStreamUnpin<T::Hash> {
                    let unpin_method = Box::new(move |hash: T::Hash, sub_id: Arc<str>| {
                        let methods = methods.clone();
                        let fut: UnpinFut = Box::pin(async move {
                            let _ = methods
                                .chainhead_unstable_unpin(&sub_id, hash)
                                .await;
                        });
                        fut
                    });
                    FollowStreamUnpin::new(follow_stream, unpin_method, max_block_life)
                }
                /// Is the block hash currently pinned.
                pub fn is_pinned(&self, hash: &Hash) -> bool {
                    self.pinned.contains_key(hash)
                }
                /// Pin a block, or return the reference to an already-pinned block. If the block has been registered to
                /// be unpinned, we'll clear those flags, so that it won't be unpinned. If the unpin request has already
                /// been sent though, then the block will be unpinned.
                fn pin_block_at(
                    &mut self,
                    rel_block_num: usize,
                    hash: Hash,
                ) -> BlockRef<Hash> {
                    self.pin_block_at_setting_unpinnable_flag(rel_block_num, hash, false)
                }
                /// Pin a block, or return the reference to an already-pinned block.
                ///
                /// This is the same as [`Self::pin_block_at`], except that it also marks the block as being unpinnable now,
                /// which should be done for any block that will no longer be seen in future events.
                fn pin_unpinnable_block_at(
                    &mut self,
                    rel_block_num: usize,
                    hash: Hash,
                ) -> BlockRef<Hash> {
                    self.pin_block_at_setting_unpinnable_flag(rel_block_num, hash, true)
                }
                fn pin_block_at_setting_unpinnable_flag(
                    &mut self,
                    rel_block_num: usize,
                    hash: Hash,
                    can_be_unpinned: bool,
                ) -> BlockRef<Hash> {
                    let entry = self
                        .pinned
                        .entry(hash)
                        .and_modify(|entry| {
                            entry
                                .can_be_unpinned = entry.can_be_unpinned || can_be_unpinned;
                            self.unpin_flags.lock().unwrap().remove(&hash);
                        })
                        .or_insert_with(|| PinnedDetails {
                            rel_block_num,
                            block_ref: BlockRef {
                                inner: Arc::new(BlockRefInner {
                                    hash,
                                    unpin_flags: self.unpin_flags.clone(),
                                }),
                            },
                            can_be_unpinned,
                        });
                    entry.block_ref.clone()
                }
                /// Unpin any blocks that are either too old, or have the unpin flag set and are old enough.
                fn unpin_blocks(&mut self, waker: &Waker) {
                    let mut unpin_flags = self.unpin_flags.lock().unwrap();
                    let rel_block_num = self.rel_block_num;
                    let Some(sub_id) = &self.subscription_id else { return;
                };
                    let mut blocks_to_unpin = ::alloc::vec::Vec::new();
                    for (hash, details) in &self.pinned {
                        if rel_block_num.saturating_sub(details.rel_block_num)
                            >= self.max_block_life
                            || (unpin_flags.contains(hash) && details.can_be_unpinned)
                        {
                            blocks_to_unpin.push(*hash);
                            unpin_flags.remove(hash);
                        }
                    }
                    drop(unpin_flags);
                    if blocks_to_unpin.is_empty() {
                        return;
                    }
                    for hash in blocks_to_unpin {
                        self.pinned.remove(&hash);
                        let fut = (self.unpin_method.0)(hash, sub_id.clone());
                        self.unpin_futs.push(fut);
                    }
                    waker.wake_by_ref();
                }
            }
            type UnpinFlags<Hash> = Arc<Mutex<HashSet<Hash>>>;
            struct PinnedDetails<Hash: BlockHash> {
                /// How old is the block?
                rel_block_num: usize,
                /// A block ref we can hand out to keep blocks pinned.
                /// Because we store one here until it's unpinned, the live count
                /// will only drop to 1 when no external refs are left.
                block_ref: BlockRef<Hash>,
                /// Has this block showed up in the list of pruned blocks, or has it
                /// been finalized? In this case, it can now been pinned as it won't
                /// show up again in future events (except as a "parent block" of some
                /// new block, which we're currently ignoring).
                can_be_unpinned: bool,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug + BlockHash> ::core::fmt::Debug
            for PinnedDetails<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "PinnedDetails",
                        "rel_block_num",
                        &self.rel_block_num,
                        "block_ref",
                        &self.block_ref,
                        "can_be_unpinned",
                        &&self.can_be_unpinned,
                    )
                }
            }
            /// All blocks reported will be wrapped in this.
            pub struct BlockRef<Hash: BlockHash> {
                inner: Arc<BlockRefInner<Hash>>,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug + BlockHash> ::core::fmt::Debug
            for BlockRef<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "BlockRef",
                        "inner",
                        &&self.inner,
                    )
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone + BlockHash> ::core::clone::Clone
            for BlockRef<Hash> {
                #[inline]
                fn clone(&self) -> BlockRef<Hash> {
                    BlockRef {
                        inner: ::core::clone::Clone::clone(&self.inner),
                    }
                }
            }
            struct BlockRefInner<Hash> {
                hash: Hash,
                unpin_flags: UnpinFlags<Hash>,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug for BlockRefInner<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "BlockRefInner",
                        "hash",
                        &self.hash,
                        "unpin_flags",
                        &&self.unpin_flags,
                    )
                }
            }
            impl<Hash: BlockHash> BlockRef<Hash> {
                /// Return the hash for this block.
                pub fn hash(&self) -> Hash {
                    self.inner.hash
                }
            }
            impl<Hash: BlockHash> PartialEq for BlockRef<Hash> {
                fn eq(&self, other: &Self) -> bool {
                    self.inner.hash == other.inner.hash
                }
            }
            impl<Hash: BlockHash> PartialEq<Hash> for BlockRef<Hash> {
                fn eq(&self, other: &Hash) -> bool {
                    &self.inner.hash == other
                }
            }
            impl<Hash: BlockHash> Drop for BlockRef<Hash> {
                fn drop(&mut self) {
                    if Arc::strong_count(&self.inner) == 2 {
                        if let Ok(mut unpin_flags) = self.inner.unpin_flags.lock() {
                            unpin_flags.insert(self.inner.hash);
                        }
                    }
                }
            }
        }
        mod storage_items {
            use super::follow_stream_driver::FollowStreamDriverHandle;
            use super::follow_stream_unpin::BlockRef;
            use super::rpc_methods::{
                FollowEvent, MethodResponse, StorageQuery, StorageResult,
                UnstableRpcMethods,
            };
            use crate::config::Config;
            use crate::error::{Error, RpcError};
            use futures::{FutureExt, Stream, StreamExt};
            use std::collections::VecDeque;
            use std::future::Future;
            use std::pin::Pin;
            use std::sync::Arc;
            use std::task::{Context, Poll};
            /// Obtain a stream of storage items given some query. this handles continuing
            /// and stopping under the hood, and returns a stream of `StorageResult`s.
            pub struct StorageItems<T: Config> {
                done: bool,
                operation_id: Arc<str>,
                buffered_responses: VecDeque<StorageResult>,
                continue_call: ContinueFutGetter,
                continue_fut: Option<ContinueFut>,
                follow_event_stream: FollowEventStream<T::Hash>,
            }
            impl<T: Config> StorageItems<T> {
                pub async fn from_methods(
                    queries: impl Iterator<Item = StorageQuery<&[u8]>>,
                    at: T::Hash,
                    follow_handle: &FollowStreamDriverHandle<T::Hash>,
                    methods: UnstableRpcMethods<T>,
                ) -> Result<Self, Error> {
                    let sub_id = super::get_subscription_id(follow_handle).await?;
                    let follow_events = follow_handle.subscribe().events();
                    let status = methods
                        .chainhead_unstable_storage(&sub_id, at, queries, None)
                        .await?;
                    let operation_id: Arc<str> = match status {
                        MethodResponse::LimitReached => {
                            return Err(
                                RpcError::request_rejected("limit reached").into(),
                            );
                        }
                        MethodResponse::Started(s) => s.operation_id.into(),
                    };
                    let continue_call: ContinueFutGetter = {
                        let operation_id = operation_id.clone();
                        Box::new(move || {
                            let sub_id = sub_id.clone();
                            let operation_id = operation_id.clone();
                            let methods = methods.clone();
                            Box::pin(async move {
                                methods
                                    .chainhead_unstable_continue(&sub_id, &operation_id)
                                    .await
                            })
                        })
                    };
                    Ok(
                        StorageItems::new(
                            operation_id,
                            continue_call,
                            Box::pin(follow_events),
                        ),
                    )
                }
                fn new(
                    operation_id: Arc<str>,
                    continue_call: ContinueFutGetter,
                    follow_event_stream: FollowEventStream<T::Hash>,
                ) -> Self {
                    Self {
                        done: false,
                        buffered_responses: VecDeque::new(),
                        operation_id,
                        continue_call,
                        continue_fut: None,
                        follow_event_stream,
                    }
                }
            }
            pub type FollowEventStream<Hash> = Pin<
                Box<dyn Stream<Item = FollowEvent<BlockRef<Hash>>> + Send + 'static>,
            >;
            pub type ContinueFutGetter = Box<dyn Fn() -> ContinueFut + Send + 'static>;
            pub type ContinueFut = Pin<
                Box<dyn Future<Output = Result<(), Error>> + Send + 'static>,
            >;
            impl<T: Config> Stream for StorageItems<T> {
                type Item = Result<StorageResult, Error>;
                fn poll_next(
                    mut self: Pin<&mut Self>,
                    cx: &mut Context<'_>,
                ) -> Poll<Option<Self::Item>> {
                    loop {
                        if self.done {
                            return Poll::Ready(None);
                        }
                        if let Some(item) = self.buffered_responses.pop_front() {
                            return Poll::Ready(Some(Ok(item)));
                        }
                        if let Some(mut fut) = self.continue_fut.take() {
                            match fut.poll_unpin(cx) {
                                Poll::Pending => {
                                    self.continue_fut = Some(fut);
                                    return Poll::Pending;
                                }
                                Poll::Ready(Err(e)) => {
                                    self.done = true;
                                    return Poll::Ready(Some(Err(e)));
                                }
                                Poll::Ready(Ok(())) => {}
                            }
                        }
                        let ev = match self.follow_event_stream.poll_next_unpin(cx) {
                            Poll::Pending => return Poll::Pending,
                            Poll::Ready(None) => return Poll::Ready(None),
                            Poll::Ready(Some(ev)) => ev,
                        };
                        match ev {
                            FollowEvent::OperationWaitingForContinue(
                                id,
                            ) if id.operation_id == *self.operation_id => {
                                self.continue_fut = Some((self.continue_call)());
                                continue;
                            }
                            FollowEvent::OperationStorageDone(
                                id,
                            ) if id.operation_id == *self.operation_id => {
                                self.done = true;
                                return Poll::Ready(None);
                            }
                            FollowEvent::OperationStorageItems(
                                items,
                            ) if items.operation_id == *self.operation_id => {
                                self.buffered_responses = items.items;
                                continue;
                            }
                            _ => {
                                continue;
                            }
                        }
                    }
                }
            }
        }
        pub mod rpc_methods {
            //! An interface to call the  API methods. See
            //! <https://github.com/paritytech/json-rpc-interface-spec/> for details of the API
            //! methods exposed here.
            use crate::backend::rpc::{rpc_params, RpcClient, RpcSubscription};
            use crate::config::BlockHash;
            use crate::{Config, Error};
            use derivative::Derivative;
            use futures::{Stream, StreamExt};
            use serde::{Deserialize, Serialize};
            use std::collections::{HashMap, VecDeque};
            use std::task::Poll;
            /// An interface to call the unstable RPC methods. This interface is instantiated with
            /// some `T: Config` trait which determines some of the types that the RPC methods will
            /// take or hand back.
            #[derivative(Clone(bound = ""), Debug(bound = ""))]
            pub struct UnstableRpcMethods<T> {
                client: RpcClient,
                _marker: std::marker::PhantomData<T>,
            }
            #[allow(unused_qualifications)]
            impl<T> ::std::clone::Clone for UnstableRpcMethods<T> {
                fn clone(&self) -> Self {
                    match *self {
                        UnstableRpcMethods {
                            client: ref __arg_0,
                            _marker: ref __arg_1,
                        } => {
                            UnstableRpcMethods {
                                client: (*__arg_0).clone(),
                                _marker: (*__arg_1).clone(),
                            }
                        }
                    }
                }
            }
            #[allow(unused_qualifications)]
            #[allow(clippy::unneeded_field_pattern)]
            impl<T> ::std::fmt::Debug for UnstableRpcMethods<T> {
                fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    match *self {
                        UnstableRpcMethods {
                            client: ref __arg_0,
                            _marker: ref __arg_1,
                        } => {
                            let mut __debug_trait_builder = __f
                                .debug_struct("UnstableRpcMethods");
                            let _ = __debug_trait_builder.field("client", &&(*__arg_0));
                            let _ = __debug_trait_builder.field("_marker", &&(*__arg_1));
                            __debug_trait_builder.finish()
                        }
                    }
                }
            }
            impl<T: Config> UnstableRpcMethods<T> {
                /// Instantiate the legacy RPC method interface.
                pub fn new(client: RpcClient) -> Self {
                    UnstableRpcMethods {
                        client,
                        _marker: std::marker::PhantomData,
                    }
                }
                /// Subscribe to `chainHead_unstable_follow` to obtain all reported blocks by the chain.
                ///
                /// The subscription ID can be used to make queries for the
                /// block's body ([`chainhead_unstable_body`](UnstableRpcMethods::chainhead_unstable_follow)),
                /// block's header ([`chainhead_unstable_header`](UnstableRpcMethods::chainhead_unstable_header)),
                /// block's storage ([`chainhead_unstable_storage`](UnstableRpcMethods::chainhead_unstable_storage)) and submitting
                /// runtime API calls at this block ([`chainhead_unstable_call`](UnstableRpcMethods::chainhead_unstable_call)).
                ///
                /// # Note
                ///
                /// When the user is no longer interested in a block, the user is responsible
                /// for calling the [`chainhead_unstable_unpin`](UnstableRpcMethods::chainhead_unstable_unpin) method.
                /// Failure to do so will result in the subscription being stopped by generating the `Stop` event.
                pub async fn chainhead_unstable_follow(
                    &self,
                    with_runtime: bool,
                ) -> Result<FollowSubscription<T::Hash>, Error> {
                    let sub = self
                        .client
                        .subscribe(
                            "chainHead_unstable_follow",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                                    .push(with_runtime)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                            },
                            "chainHead_unstable_unfollow",
                        )
                        .await?;
                    Ok(FollowSubscription {
                        sub,
                        done: false,
                    })
                }
                /// Resumes a storage fetch started with chainHead_unstable_storage after it has generated an
                /// `operationWaitingForContinue` event.
                ///
                /// Has no effect if the operationId is invalid or refers to an operation that has emitted a
                /// `{"event": "operationInaccessible"` event, or if the followSubscription is invalid or stale.
                pub async fn chainhead_unstable_continue(
                    &self,
                    follow_subscription: &str,
                    operation_id: &str,
                ) -> Result<(), Error> {
                    self.client
                        .request(
                            "chainHead_unstable_continue",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                                    .push(follow_subscription)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(operation_id)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                            },
                        )
                        .await?;
                    Ok(())
                }
                /// Stops an operation started with `chainHead_unstable_body`, `chainHead_unstable_call`, or
                /// `chainHead_unstable_storage. If the operation was still in progress, this interrupts it.
                /// If the operation was already finished, this call has no effect.
                ///
                /// Has no effect if the `followSubscription` is invalid or stale.
                pub async fn chainhead_unstable_stop_operation(
                    &self,
                    follow_subscription: &str,
                    operation_id: &str,
                ) -> Result<(), Error> {
                    self.client
                        .request(
                            "chainHead_unstable_stopOperation",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                                    .push(follow_subscription)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(operation_id)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                            },
                        )
                        .await?;
                    Ok(())
                }
                /// Call the `chainHead_unstable_body` method and return an operation ID to obtain the block's body.
                ///
                /// The response events are provided on the `chainHead_follow` subscription and identified by
                /// the returned operation ID.
                ///
                /// # Note
                ///
                /// The subscription ID is obtained from an open subscription created by
                /// [`chainhead_unstable_follow`](UnstableRpcMethods::chainhead_unstable_follow).
                pub async fn chainhead_unstable_body(
                    &self,
                    subscription_id: &str,
                    hash: T::Hash,
                ) -> Result<MethodResponse, Error> {
                    let response = self
                        .client
                        .request(
                            "chainHead_unstable_body",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                                    .push(subscription_id)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(hash)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                            },
                        )
                        .await?;
                    Ok(response)
                }
                /// Get the block's header using the `chainHead_unstable_header` method.
                ///
                /// # Note
                ///
                /// The subscription ID is obtained from an open subscription created by
                /// [`chainhead_unstable_follow`](UnstableRpcMethods::chainhead_unstable_follow).
                pub async fn chainhead_unstable_header(
                    &self,
                    subscription_id: &str,
                    hash: T::Hash,
                ) -> Result<Option<T::Header>, Error> {
                    let header: Option<Bytes> = self
                        .client
                        .request(
                            "chainHead_unstable_header",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                                    .push(subscription_id)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(hash)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                            },
                        )
                        .await?;
                    let header = header
                        .map(|h| codec::Decode::decode(&mut &*h.0))
                        .transpose()?;
                    Ok(header)
                }
                /// Call the `chainhead_unstable_storage` method and return an operation ID to obtain the block's storage.
                ///
                /// The response events are provided on the `chainHead_follow` subscription and identified by
                /// the returned operation ID.
                ///
                /// # Note
                ///
                /// The subscription ID is obtained from an open subscription created by
                /// [`chainhead_unstable_follow`](UnstableRpcMethods::chainhead_unstable_follow).
                pub async fn chainhead_unstable_storage(
                    &self,
                    subscription_id: &str,
                    hash: T::Hash,
                    items: impl IntoIterator<Item = StorageQuery<&[u8]>>,
                    child_key: Option<&[u8]>,
                ) -> Result<MethodResponse, Error> {
                    let items: Vec<StorageQuery<String>> = items
                        .into_iter()
                        .map(|item| StorageQuery {
                            key: to_hex(item.key),
                            query_type: item.query_type,
                        })
                        .collect();
                    let response = self
                        .client
                        .request(
                            "chainHead_unstable_storage",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                                    .push(subscription_id)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(hash)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(items)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(child_key.map(to_hex))
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                            },
                        )
                        .await?;
                    Ok(response)
                }
                /// Call the `chainhead_unstable_storage` method and return an operation ID to obtain the runtime API result.
                ///
                /// The response events are provided on the `chainHead_follow` subscription and identified by
                /// the returned operation ID.
                ///
                /// # Note
                ///
                /// The subscription ID is obtained from an open subscription created by
                /// [`chainhead_unstable_follow`](UnstableRpcMethods::chainhead_unstable_follow).
                pub async fn chainhead_unstable_call(
                    &self,
                    subscription_id: &str,
                    hash: T::Hash,
                    function: &str,
                    call_parameters: &[u8],
                ) -> Result<MethodResponse, Error> {
                    let response = self
                        .client
                        .request(
                            "chainHead_unstable_call",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                                    .push(subscription_id)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(hash)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(function)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(to_hex(call_parameters))
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                            },
                        )
                        .await?;
                    Ok(response)
                }
                /// Unpin a block reported by the `chainHead_follow` subscription.
                ///
                /// # Note
                ///
                /// The subscription ID is obtained from an open subscription created by
                /// [`chainhead_unstable_follow`](UnstableRpcMethods::chainhead_unstable_follow).
                pub async fn chainhead_unstable_unpin(
                    &self,
                    subscription_id: &str,
                    hash: T::Hash,
                ) -> Result<(), Error> {
                    self.client
                        .request(
                            "chainHead_unstable_unpin",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                                    .push(subscription_id)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                                    .push(hash)
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                            },
                        )
                        .await?;
                    Ok(())
                }
                /// Return the genesis hash.
                pub async fn chainspec_v1_genesis_hash(&self) -> Result<T::Hash, Error> {
                    let hash = self
                        .client
                        .request(
                            "chainSpec_v1_genesisHash",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                        )
                        .await?;
                    Ok(hash)
                }
                /// Return a string containing the human-readable name of the chain.
                pub async fn chainspec_v1_chain_name(&self) -> Result<String, Error> {
                    let hash = self
                        .client
                        .request(
                            "chainSpec_v1_chainName",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                        )
                        .await?;
                    Ok(hash)
                }
                /// Returns the JSON payload found in the chain specification under the key properties.
                /// No guarantee is offered about the content of this object, and so it's up to the caller
                /// to decide what to deserialize it into.
                pub async fn chainspec_v1_properties<Props: serde::de::DeserializeOwned>(
                    &self,
                ) -> Result<Props, Error> {
                    self.client
                        .request(
                            "chainSpec_v1_properties",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                        )
                        .await
                }
                /// Returns an array of strings indicating the names of all the JSON-RPC functions supported by
                /// the JSON-RPC server.
                pub async fn rpc_methods(&self) -> Result<Vec<String>, Error> {
                    self.client
                        .request(
                            "rpc_methods",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                            },
                        )
                        .await
                }
                /// Attempt to submit a transaction, returning events about its progress.
                pub async fn transaction_unstable_submit_and_watch(
                    &self,
                    tx: &[u8],
                ) -> Result<TransactionSubscription<T::Hash>, Error> {
                    let sub = self
                        .client
                        .subscribe(
                            "transactionWatch_unstable_submitAndWatch",
                            {
                                #[allow(unused_mut)]
                                let mut params = crate::backend::rpc::RpcParams::new();
                                params
                                    .push(to_hex(tx))
                                    .expect(
                                        "values passed to rpc_params! must be serializable to JSON",
                                    );
                                params
                            },
                            "transactionWatch_unstable_unwatch",
                        )
                        .await?;
                    Ok(TransactionSubscription {
                        sub,
                        done: false,
                    })
                }
            }
            /// This represents events generated by the `follow` method.
            ///
            /// The block events are generated in the following order:
            /// 1. Initialized - generated only once to signal the latest finalized block
            /// 2. NewBlock - a new block was added.
            /// 3. BestBlockChanged - indicate that the best block is now the one from this event. The block was
            ///    announced priorly with the `NewBlock` event.
            /// 4. Finalized - State the finalized and pruned blocks.
            ///
            /// The following events are related to operations:
            /// - OperationBodyDone: The response of the `chainHead_body`
            /// - OperationCallDone: The response of the `chainHead_call`
            /// - OperationStorageItems: Items produced by the `chianHead_storage`
            /// - OperationWaitingForContinue: Generated after OperationStorageItems and requires the user to
            ///   call `chainHead_continue`
            /// - OperationStorageDone: The `chainHead_storage` method has produced all the results
            /// - OperationInaccessible: The server was unable to provide the result, retries might succeed in
            ///   the future
            /// - OperationError: The server encountered an error, retries will not succeed
            ///
            /// The stop event indicates that the JSON-RPC server was unable to provide a consistent list of
            /// the blocks at the head of the chain.
            #[serde(rename_all = "camelCase")]
            #[serde(tag = "event")]
            pub enum FollowEvent<Hash> {
                /// The latest finalized block.
                ///
                /// This event is generated only once.
                Initialized(Initialized<Hash>),
                /// A new non-finalized block was added.
                NewBlock(NewBlock<Hash>),
                /// The best block of the chain.
                BestBlockChanged(BestBlockChanged<Hash>),
                /// A list of finalized and pruned blocks.
                Finalized(Finalized<Hash>),
                /// The response of the `chainHead_body` method.
                OperationBodyDone(OperationBodyDone),
                /// The response of the `chainHead_call` method.
                OperationCallDone(OperationCallDone),
                /// Yield one or more items found in the storage.
                OperationStorageItems(OperationStorageItems),
                /// Ask the user to call `chainHead_continue` to produce more events
                /// regarding the operation id.
                OperationWaitingForContinue(OperationId),
                /// The responses of the `chainHead_storage` method have been produced.
                OperationStorageDone(OperationId),
                /// The RPC server was unable to provide the response of the following operation id.
                ///
                /// Repeating the same operation in the future might succeed.
                OperationInaccessible(OperationId),
                /// The RPC server encountered an error while processing an operation id.
                ///
                /// Repeating the same operation in the future will not succeed.
                OperationError(OperationError),
                /// The subscription is dropped and no further events
                /// will be generated.
                Stop,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug for FollowEvent<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        FollowEvent::Initialized(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Initialized",
                                &__self_0,
                            )
                        }
                        FollowEvent::NewBlock(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "NewBlock",
                                &__self_0,
                            )
                        }
                        FollowEvent::BestBlockChanged(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "BestBlockChanged",
                                &__self_0,
                            )
                        }
                        FollowEvent::Finalized(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Finalized",
                                &__self_0,
                            )
                        }
                        FollowEvent::OperationBodyDone(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "OperationBodyDone",
                                &__self_0,
                            )
                        }
                        FollowEvent::OperationCallDone(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "OperationCallDone",
                                &__self_0,
                            )
                        }
                        FollowEvent::OperationStorageItems(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "OperationStorageItems",
                                &__self_0,
                            )
                        }
                        FollowEvent::OperationWaitingForContinue(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "OperationWaitingForContinue",
                                &__self_0,
                            )
                        }
                        FollowEvent::OperationStorageDone(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "OperationStorageDone",
                                &__self_0,
                            )
                        }
                        FollowEvent::OperationInaccessible(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "OperationInaccessible",
                                &__self_0,
                            )
                        }
                        FollowEvent::OperationError(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "OperationError",
                                &__self_0,
                            )
                        }
                        FollowEvent::Stop => ::core::fmt::Formatter::write_str(f, "Stop"),
                    }
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone> ::core::clone::Clone for FollowEvent<Hash> {
                #[inline]
                fn clone(&self) -> FollowEvent<Hash> {
                    match self {
                        FollowEvent::Initialized(__self_0) => {
                            FollowEvent::Initialized(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FollowEvent::NewBlock(__self_0) => {
                            FollowEvent::NewBlock(::core::clone::Clone::clone(__self_0))
                        }
                        FollowEvent::BestBlockChanged(__self_0) => {
                            FollowEvent::BestBlockChanged(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FollowEvent::Finalized(__self_0) => {
                            FollowEvent::Finalized(::core::clone::Clone::clone(__self_0))
                        }
                        FollowEvent::OperationBodyDone(__self_0) => {
                            FollowEvent::OperationBodyDone(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FollowEvent::OperationCallDone(__self_0) => {
                            FollowEvent::OperationCallDone(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FollowEvent::OperationStorageItems(__self_0) => {
                            FollowEvent::OperationStorageItems(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FollowEvent::OperationWaitingForContinue(__self_0) => {
                            FollowEvent::OperationWaitingForContinue(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FollowEvent::OperationStorageDone(__self_0) => {
                            FollowEvent::OperationStorageDone(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FollowEvent::OperationInaccessible(__self_0) => {
                            FollowEvent::OperationInaccessible(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FollowEvent::OperationError(__self_0) => {
                            FollowEvent::OperationError(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        FollowEvent::Stop => FollowEvent::Stop,
                    }
                }
            }
            #[automatically_derived]
            impl<Hash> ::core::marker::StructuralPartialEq for FollowEvent<Hash> {}
            #[automatically_derived]
            impl<Hash: ::core::cmp::PartialEq> ::core::cmp::PartialEq
            for FollowEvent<Hash> {
                #[inline]
                fn eq(&self, other: &FollowEvent<Hash>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                FollowEvent::Initialized(__self_0),
                                FollowEvent::Initialized(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FollowEvent::NewBlock(__self_0),
                                FollowEvent::NewBlock(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FollowEvent::BestBlockChanged(__self_0),
                                FollowEvent::BestBlockChanged(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FollowEvent::Finalized(__self_0),
                                FollowEvent::Finalized(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FollowEvent::OperationBodyDone(__self_0),
                                FollowEvent::OperationBodyDone(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FollowEvent::OperationCallDone(__self_0),
                                FollowEvent::OperationCallDone(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FollowEvent::OperationStorageItems(__self_0),
                                FollowEvent::OperationStorageItems(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FollowEvent::OperationWaitingForContinue(__self_0),
                                FollowEvent::OperationWaitingForContinue(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FollowEvent::OperationStorageDone(__self_0),
                                FollowEvent::OperationStorageDone(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FollowEvent::OperationInaccessible(__self_0),
                                FollowEvent::OperationInaccessible(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                FollowEvent::OperationError(__self_0),
                                FollowEvent::OperationError(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => true,
                        }
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::cmp::Eq> ::core::cmp::Eq for FollowEvent<Hash> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Initialized<Hash>>;
                    let _: ::core::cmp::AssertParamIsEq<NewBlock<Hash>>;
                    let _: ::core::cmp::AssertParamIsEq<BestBlockChanged<Hash>>;
                    let _: ::core::cmp::AssertParamIsEq<Finalized<Hash>>;
                    let _: ::core::cmp::AssertParamIsEq<OperationBodyDone>;
                    let _: ::core::cmp::AssertParamIsEq<OperationCallDone>;
                    let _: ::core::cmp::AssertParamIsEq<OperationStorageItems>;
                    let _: ::core::cmp::AssertParamIsEq<OperationId>;
                    let _: ::core::cmp::AssertParamIsEq<OperationError>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, Hash> _serde::Deserialize<'de> for FollowEvent<Hash>
                where
                    Hash: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __field8,
                            __field9,
                            __field10,
                            __field11,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    7u64 => _serde::__private::Ok(__Field::__field7),
                                    8u64 => _serde::__private::Ok(__Field::__field8),
                                    9u64 => _serde::__private::Ok(__Field::__field9),
                                    10u64 => _serde::__private::Ok(__Field::__field10),
                                    11u64 => _serde::__private::Ok(__Field::__field11),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 12",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "initialized" => _serde::__private::Ok(__Field::__field0),
                                    "newBlock" => _serde::__private::Ok(__Field::__field1),
                                    "bestBlockChanged" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    "finalized" => _serde::__private::Ok(__Field::__field3),
                                    "operationBodyDone" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    "operationCallDone" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    "operationStorageItems" => {
                                        _serde::__private::Ok(__Field::__field6)
                                    }
                                    "operationWaitingForContinue" => {
                                        _serde::__private::Ok(__Field::__field7)
                                    }
                                    "operationStorageDone" => {
                                        _serde::__private::Ok(__Field::__field8)
                                    }
                                    "operationInaccessible" => {
                                        _serde::__private::Ok(__Field::__field9)
                                    }
                                    "operationError" => {
                                        _serde::__private::Ok(__Field::__field10)
                                    }
                                    "stop" => _serde::__private::Ok(__Field::__field11),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"initialized" => _serde::__private::Ok(__Field::__field0),
                                    b"newBlock" => _serde::__private::Ok(__Field::__field1),
                                    b"bestBlockChanged" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    b"finalized" => _serde::__private::Ok(__Field::__field3),
                                    b"operationBodyDone" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    b"operationCallDone" => {
                                        _serde::__private::Ok(__Field::__field5)
                                    }
                                    b"operationStorageItems" => {
                                        _serde::__private::Ok(__Field::__field6)
                                    }
                                    b"operationWaitingForContinue" => {
                                        _serde::__private::Ok(__Field::__field7)
                                    }
                                    b"operationStorageDone" => {
                                        _serde::__private::Ok(__Field::__field8)
                                    }
                                    b"operationInaccessible" => {
                                        _serde::__private::Ok(__Field::__field9)
                                    }
                                    b"operationError" => {
                                        _serde::__private::Ok(__Field::__field10)
                                    }
                                    b"stop" => _serde::__private::Ok(__Field::__field11),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "initialized",
                            "newBlock",
                            "bestBlockChanged",
                            "finalized",
                            "operationBodyDone",
                            "operationCallDone",
                            "operationStorageItems",
                            "operationWaitingForContinue",
                            "operationStorageDone",
                            "operationInaccessible",
                            "operationError",
                            "stop",
                        ];
                        let (__tag, __content) = _serde::Deserializer::deserialize_any(
                            __deserializer,
                            _serde::__private::de::TaggedContentVisitor::<
                                __Field,
                            >::new("event", "internally tagged enum FollowEvent"),
                        )?;
                        let __deserializer = _serde::__private::de::ContentDeserializer::<
                            __D::Error,
                        >::new(__content);
                        match __tag {
                            __Field::__field0 => {
                                _serde::__private::Result::map(
                                    <Initialized<
                                        Hash,
                                    > as _serde::Deserialize>::deserialize(__deserializer),
                                    FollowEvent::Initialized,
                                )
                            }
                            __Field::__field1 => {
                                _serde::__private::Result::map(
                                    <NewBlock<
                                        Hash,
                                    > as _serde::Deserialize>::deserialize(__deserializer),
                                    FollowEvent::NewBlock,
                                )
                            }
                            __Field::__field2 => {
                                _serde::__private::Result::map(
                                    <BestBlockChanged<
                                        Hash,
                                    > as _serde::Deserialize>::deserialize(__deserializer),
                                    FollowEvent::BestBlockChanged,
                                )
                            }
                            __Field::__field3 => {
                                _serde::__private::Result::map(
                                    <Finalized<
                                        Hash,
                                    > as _serde::Deserialize>::deserialize(__deserializer),
                                    FollowEvent::Finalized,
                                )
                            }
                            __Field::__field4 => {
                                _serde::__private::Result::map(
                                    <OperationBodyDone as _serde::Deserialize>::deserialize(
                                        __deserializer,
                                    ),
                                    FollowEvent::OperationBodyDone,
                                )
                            }
                            __Field::__field5 => {
                                _serde::__private::Result::map(
                                    <OperationCallDone as _serde::Deserialize>::deserialize(
                                        __deserializer,
                                    ),
                                    FollowEvent::OperationCallDone,
                                )
                            }
                            __Field::__field6 => {
                                _serde::__private::Result::map(
                                    <OperationStorageItems as _serde::Deserialize>::deserialize(
                                        __deserializer,
                                    ),
                                    FollowEvent::OperationStorageItems,
                                )
                            }
                            __Field::__field7 => {
                                _serde::__private::Result::map(
                                    <OperationId as _serde::Deserialize>::deserialize(
                                        __deserializer,
                                    ),
                                    FollowEvent::OperationWaitingForContinue,
                                )
                            }
                            __Field::__field8 => {
                                _serde::__private::Result::map(
                                    <OperationId as _serde::Deserialize>::deserialize(
                                        __deserializer,
                                    ),
                                    FollowEvent::OperationStorageDone,
                                )
                            }
                            __Field::__field9 => {
                                _serde::__private::Result::map(
                                    <OperationId as _serde::Deserialize>::deserialize(
                                        __deserializer,
                                    ),
                                    FollowEvent::OperationInaccessible,
                                )
                            }
                            __Field::__field10 => {
                                _serde::__private::Result::map(
                                    <OperationError as _serde::Deserialize>::deserialize(
                                        __deserializer,
                                    ),
                                    FollowEvent::OperationError,
                                )
                            }
                            __Field::__field11 => {
                                _serde::Deserializer::deserialize_any(
                                    __deserializer,
                                    _serde::__private::de::InternallyTaggedUnitVisitor::new(
                                        "FollowEvent",
                                        "Stop",
                                    ),
                                )?;
                                _serde::__private::Ok(FollowEvent::Stop)
                            }
                        }
                    }
                }
            };
            /// Contain information about the latest finalized block.
            ///
            /// # Note
            ///
            /// This is the first event generated by the `follow` subscription
            /// and is submitted only once.
            #[serde(rename_all = "camelCase")]
            pub struct Initialized<Hash> {
                /// The hash of the latest finalized block.
                pub finalized_block_hash: Hash,
                /// The runtime version of the finalized block.
                ///
                /// # Note
                ///
                /// This is present only if the `with_runtime` flag is set for
                /// the `follow` subscription.
                pub finalized_block_runtime: Option<RuntimeEvent>,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug for Initialized<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Initialized",
                        "finalized_block_hash",
                        &self.finalized_block_hash,
                        "finalized_block_runtime",
                        &&self.finalized_block_runtime,
                    )
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone> ::core::clone::Clone for Initialized<Hash> {
                #[inline]
                fn clone(&self) -> Initialized<Hash> {
                    Initialized {
                        finalized_block_hash: ::core::clone::Clone::clone(
                            &self.finalized_block_hash,
                        ),
                        finalized_block_runtime: ::core::clone::Clone::clone(
                            &self.finalized_block_runtime,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<Hash> ::core::marker::StructuralPartialEq for Initialized<Hash> {}
            #[automatically_derived]
            impl<Hash: ::core::cmp::PartialEq> ::core::cmp::PartialEq
            for Initialized<Hash> {
                #[inline]
                fn eq(&self, other: &Initialized<Hash>) -> bool {
                    self.finalized_block_hash == other.finalized_block_hash
                        && self.finalized_block_runtime == other.finalized_block_runtime
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::cmp::Eq> ::core::cmp::Eq for Initialized<Hash> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Hash>;
                    let _: ::core::cmp::AssertParamIsEq<Option<RuntimeEvent>>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, Hash> _serde::Deserialize<'de> for Initialized<Hash>
                where
                    Hash: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "finalizedBlockHash" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    "finalizedBlockRuntime" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"finalizedBlockHash" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    b"finalizedBlockRuntime" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            marker: _serde::__private::PhantomData<Initialized<Hash>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de, Hash> _serde::de::Visitor<'de> for __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            type Value = Initialized<Hash>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Initialized",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Hash,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Initialized with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Option<RuntimeEvent>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Initialized with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Initialized {
                                    finalized_block_hash: __field0,
                                    finalized_block_runtime: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Hash> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Option<RuntimeEvent>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "finalizedBlockHash",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Hash>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "finalizedBlockRuntime",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<RuntimeEvent>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("finalizedBlockHash")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field(
                                            "finalizedBlockRuntime",
                                        )?
                                    }
                                };
                                _serde::__private::Ok(Initialized {
                                    finalized_block_hash: __field0,
                                    finalized_block_runtime: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "finalizedBlockHash",
                            "finalizedBlockRuntime",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Initialized",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Initialized<Hash>>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// The runtime event generated if the `follow` subscription
            /// has set the `with_runtime` flag.
            #[serde(rename_all = "camelCase")]
            #[serde(tag = "type")]
            pub enum RuntimeEvent {
                /// The runtime version of this block.
                Valid(RuntimeVersionEvent),
                /// The runtime could not be obtained due to an error.
                Invalid(ErrorEvent),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for RuntimeEvent {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        RuntimeEvent::Valid(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Valid",
                                &__self_0,
                            )
                        }
                        RuntimeEvent::Invalid(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Invalid",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RuntimeEvent {
                #[inline]
                fn clone(&self) -> RuntimeEvent {
                    match self {
                        RuntimeEvent::Valid(__self_0) => {
                            RuntimeEvent::Valid(::core::clone::Clone::clone(__self_0))
                        }
                        RuntimeEvent::Invalid(__self_0) => {
                            RuntimeEvent::Invalid(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for RuntimeEvent {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for RuntimeEvent {
                #[inline]
                fn eq(&self, other: &RuntimeEvent) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                RuntimeEvent::Valid(__self_0),
                                RuntimeEvent::Valid(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                RuntimeEvent::Invalid(__self_0),
                                RuntimeEvent::Invalid(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for RuntimeEvent {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<RuntimeVersionEvent>;
                    let _: ::core::cmp::AssertParamIsEq<ErrorEvent>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RuntimeEvent {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "valid" => _serde::__private::Ok(__Field::__field0),
                                    "invalid" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"valid" => _serde::__private::Ok(__Field::__field0),
                                    b"invalid" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &["valid", "invalid"];
                        let (__tag, __content) = _serde::Deserializer::deserialize_any(
                            __deserializer,
                            _serde::__private::de::TaggedContentVisitor::<
                                __Field,
                            >::new("type", "internally tagged enum RuntimeEvent"),
                        )?;
                        let __deserializer = _serde::__private::de::ContentDeserializer::<
                            __D::Error,
                        >::new(__content);
                        match __tag {
                            __Field::__field0 => {
                                _serde::__private::Result::map(
                                    <RuntimeVersionEvent as _serde::Deserialize>::deserialize(
                                        __deserializer,
                                    ),
                                    RuntimeEvent::Valid,
                                )
                            }
                            __Field::__field1 => {
                                _serde::__private::Result::map(
                                    <ErrorEvent as _serde::Deserialize>::deserialize(
                                        __deserializer,
                                    ),
                                    RuntimeEvent::Invalid,
                                )
                            }
                        }
                    }
                }
            };
            /// The runtime specification of the current block.
            ///
            /// This event is generated for:
            ///   - the first announced block by the follow subscription
            ///   - blocks that suffered a change in runtime compared with their parents
            #[serde(rename_all = "camelCase")]
            pub struct RuntimeVersionEvent {
                /// Details about this runtime.
                pub spec: RuntimeSpec,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for RuntimeVersionEvent {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "RuntimeVersionEvent",
                        "spec",
                        &&self.spec,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RuntimeVersionEvent {
                #[inline]
                fn clone(&self) -> RuntimeVersionEvent {
                    RuntimeVersionEvent {
                        spec: ::core::clone::Clone::clone(&self.spec),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for RuntimeVersionEvent {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for RuntimeVersionEvent {
                #[inline]
                fn eq(&self, other: &RuntimeVersionEvent) -> bool {
                    self.spec == other.spec
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for RuntimeVersionEvent {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<RuntimeSpec>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RuntimeVersionEvent {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "spec" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"spec" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<RuntimeVersionEvent>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RuntimeVersionEvent;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct RuntimeVersionEvent",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    RuntimeSpec,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct RuntimeVersionEvent with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(RuntimeVersionEvent {
                                    spec: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<RuntimeSpec> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("spec"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    RuntimeSpec,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("spec")?
                                    }
                                };
                                _serde::__private::Ok(RuntimeVersionEvent {
                                    spec: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["spec"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "RuntimeVersionEvent",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    RuntimeVersionEvent,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// This contains the runtime version information necessary to make transactions, and is obtained from
            /// the "initialized" event of `chainHead_follow` if the `withRuntime` flag is set.
            #[serde(rename_all = "camelCase")]
            pub struct RuntimeSpec {
                /// Opaque string indicating the name of the chain.
                pub spec_name: String,
                /// Opaque string indicating the name of the implementation of the chain.
                pub impl_name: String,
                /// Opaque integer. The JSON-RPC client can assume that the Runtime API call to `Metadata_metadata`
                /// will always produce the same output as long as the specVersion is the same.
                pub spec_version: u32,
                /// Opaque integer. Whenever the runtime code changes in a backwards-compatible way, the implVersion
                /// is modified while the specVersion is left untouched.
                pub impl_version: u32,
                /// Opaque integer. Necessary when building the bytes of a transaction. Transactions that have been
                /// generated with a different `transaction_version` are incompatible.
                pub transaction_version: u32,
                /// Object containing a list of "entry point APIs" supported by the runtime. Each key is an opaque string
                /// indicating the API, and each value is an integer version number. Before making a runtime call (using
                /// chainHead_call), you should make sure that this list contains the entry point API corresponding to the
                /// call and with a known version number.
                ///
                /// **Note:** In Substrate, the keys in the apis field consists of the hexadecimal-encoded 8-bytes blake2
                /// hash of the name of the API. For example, the `TaggedTransactionQueue` API is 0xd2bc9897eed08f15.
                #[serde(with = "hashmap_as_tuple_list")]
                pub apis: HashMap<String, u32>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for RuntimeSpec {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "spec_name",
                        "impl_name",
                        "spec_version",
                        "impl_version",
                        "transaction_version",
                        "apis",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.spec_name,
                        &self.impl_name,
                        &self.spec_version,
                        &self.impl_version,
                        &self.transaction_version,
                        &&self.apis,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "RuntimeSpec",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RuntimeSpec {
                #[inline]
                fn clone(&self) -> RuntimeSpec {
                    RuntimeSpec {
                        spec_name: ::core::clone::Clone::clone(&self.spec_name),
                        impl_name: ::core::clone::Clone::clone(&self.impl_name),
                        spec_version: ::core::clone::Clone::clone(&self.spec_version),
                        impl_version: ::core::clone::Clone::clone(&self.impl_version),
                        transaction_version: ::core::clone::Clone::clone(
                            &self.transaction_version,
                        ),
                        apis: ::core::clone::Clone::clone(&self.apis),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for RuntimeSpec {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for RuntimeSpec {
                #[inline]
                fn eq(&self, other: &RuntimeSpec) -> bool {
                    self.spec_name == other.spec_name
                        && self.impl_name == other.impl_name
                        && self.spec_version == other.spec_version
                        && self.impl_version == other.impl_version
                        && self.transaction_version == other.transaction_version
                        && self.apis == other.apis
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for RuntimeSpec {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                    let _: ::core::cmp::AssertParamIsEq<HashMap<String, u32>>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RuntimeSpec {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "specName" => _serde::__private::Ok(__Field::__field0),
                                    "implName" => _serde::__private::Ok(__Field::__field1),
                                    "specVersion" => _serde::__private::Ok(__Field::__field2),
                                    "implVersion" => _serde::__private::Ok(__Field::__field3),
                                    "transactionVersion" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    "apis" => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"specName" => _serde::__private::Ok(__Field::__field0),
                                    b"implName" => _serde::__private::Ok(__Field::__field1),
                                    b"specVersion" => _serde::__private::Ok(__Field::__field2),
                                    b"implVersion" => _serde::__private::Ok(__Field::__field3),
                                    b"transactionVersion" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    b"apis" => _serde::__private::Ok(__Field::__field5),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<RuntimeSpec>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RuntimeSpec;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct RuntimeSpec",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct RuntimeSpec with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct RuntimeSpec with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    u32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct RuntimeSpec with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    u32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct RuntimeSpec with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    u32,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct RuntimeSpec with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field5 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: HashMap<String, u32>,
                                        phantom: _serde::__private::PhantomData<RuntimeSpec>,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: hashmap_as_tuple_list::deserialize(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                5usize,
                                                &"struct RuntimeSpec with 6 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(RuntimeSpec {
                                    spec_name: __field0,
                                    impl_name: __field1,
                                    spec_version: __field2,
                                    impl_version: __field3,
                                    transaction_version: __field4,
                                    apis: __field5,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<u32> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<u32> = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<u32> = _serde::__private::None;
                                let mut __field5: _serde::__private::Option<
                                    HashMap<String, u32>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "specName",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "implName",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "specVersion",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "implVersion",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "transactionVersion",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field5 => {
                                            if _serde::__private::Option::is_some(&__field5) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("apis"),
                                                );
                                            }
                                            __field5 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de> {
                                                    value: HashMap<String, u32>,
                                                    phantom: _serde::__private::PhantomData<RuntimeSpec>,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: hashmap_as_tuple_list::deserialize(__deserializer)?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("specName")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("implName")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("specVersion")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("implVersion")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("transactionVersion")?
                                    }
                                };
                                let __field5 = match __field5 {
                                    _serde::__private::Some(__field5) => __field5,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field("apis"),
                                        );
                                    }
                                };
                                _serde::__private::Ok(RuntimeSpec {
                                    spec_name: __field0,
                                    impl_name: __field1,
                                    spec_version: __field2,
                                    impl_version: __field3,
                                    transaction_version: __field4,
                                    apis: __field5,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "specName",
                            "implName",
                            "specVersion",
                            "implVersion",
                            "transactionVersion",
                            "apis",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "RuntimeSpec",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<RuntimeSpec>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// The operation could not be processed due to an error.
            #[serde(rename_all = "camelCase")]
            pub struct ErrorEvent {
                /// Reason of the error.
                pub error: String,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for ErrorEvent {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "ErrorEvent",
                        "error",
                        &&self.error,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ErrorEvent {
                #[inline]
                fn clone(&self) -> ErrorEvent {
                    ErrorEvent {
                        error: ::core::clone::Clone::clone(&self.error),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ErrorEvent {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ErrorEvent {
                #[inline]
                fn eq(&self, other: &ErrorEvent) -> bool {
                    self.error == other.error
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ErrorEvent {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ErrorEvent {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "error" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"error" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ErrorEvent>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ErrorEvent;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ErrorEvent",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ErrorEvent with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ErrorEvent { error: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("error"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("error")?
                                    }
                                };
                                _serde::__private::Ok(ErrorEvent { error: __field0 })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["error"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ErrorEvent",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ErrorEvent>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// Indicate a new non-finalized block.
            #[serde(rename_all = "camelCase")]
            pub struct NewBlock<Hash> {
                /// The hash of the new block.
                pub block_hash: Hash,
                /// The parent hash of the new block.
                pub parent_block_hash: Hash,
                /// The runtime version of the new block.
                ///
                /// # Note
                ///
                /// This is present only if the `with_runtime` flag is set for
                /// the `follow` subscription.
                pub new_runtime: Option<RuntimeEvent>,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug for NewBlock<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "NewBlock",
                        "block_hash",
                        &self.block_hash,
                        "parent_block_hash",
                        &self.parent_block_hash,
                        "new_runtime",
                        &&self.new_runtime,
                    )
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone> ::core::clone::Clone for NewBlock<Hash> {
                #[inline]
                fn clone(&self) -> NewBlock<Hash> {
                    NewBlock {
                        block_hash: ::core::clone::Clone::clone(&self.block_hash),
                        parent_block_hash: ::core::clone::Clone::clone(
                            &self.parent_block_hash,
                        ),
                        new_runtime: ::core::clone::Clone::clone(&self.new_runtime),
                    }
                }
            }
            #[automatically_derived]
            impl<Hash> ::core::marker::StructuralPartialEq for NewBlock<Hash> {}
            #[automatically_derived]
            impl<Hash: ::core::cmp::PartialEq> ::core::cmp::PartialEq
            for NewBlock<Hash> {
                #[inline]
                fn eq(&self, other: &NewBlock<Hash>) -> bool {
                    self.block_hash == other.block_hash
                        && self.parent_block_hash == other.parent_block_hash
                        && self.new_runtime == other.new_runtime
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::cmp::Eq> ::core::cmp::Eq for NewBlock<Hash> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Hash>;
                    let _: ::core::cmp::AssertParamIsEq<Option<RuntimeEvent>>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, Hash> _serde::Deserialize<'de> for NewBlock<Hash>
                where
                    Hash: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "blockHash" => _serde::__private::Ok(__Field::__field0),
                                    "parentBlockHash" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    "newRuntime" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"blockHash" => _serde::__private::Ok(__Field::__field0),
                                    b"parentBlockHash" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    b"newRuntime" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            marker: _serde::__private::PhantomData<NewBlock<Hash>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de, Hash> _serde::de::Visitor<'de> for __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            type Value = NewBlock<Hash>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct NewBlock",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Hash,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct NewBlock with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Hash,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct NewBlock with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Option<RuntimeEvent>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct NewBlock with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(NewBlock {
                                    block_hash: __field0,
                                    parent_block_hash: __field1,
                                    new_runtime: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Hash> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Hash> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Option<RuntimeEvent>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "blockHash",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Hash>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "parentBlockHash",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Hash>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "newRuntime",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<RuntimeEvent>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("blockHash")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("parentBlockHash")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("newRuntime")?
                                    }
                                };
                                _serde::__private::Ok(NewBlock {
                                    block_hash: __field0,
                                    parent_block_hash: __field1,
                                    new_runtime: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "blockHash",
                            "parentBlockHash",
                            "newRuntime",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "NewBlock",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<NewBlock<Hash>>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// Indicate the block hash of the new best block.
            #[serde(rename_all = "camelCase")]
            pub struct BestBlockChanged<Hash> {
                /// The block hash of the new best block.
                pub best_block_hash: Hash,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug
            for BestBlockChanged<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "BestBlockChanged",
                        "best_block_hash",
                        &&self.best_block_hash,
                    )
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone> ::core::clone::Clone
            for BestBlockChanged<Hash> {
                #[inline]
                fn clone(&self) -> BestBlockChanged<Hash> {
                    BestBlockChanged {
                        best_block_hash: ::core::clone::Clone::clone(
                            &self.best_block_hash,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<Hash> ::core::marker::StructuralPartialEq for BestBlockChanged<Hash> {}
            #[automatically_derived]
            impl<Hash: ::core::cmp::PartialEq> ::core::cmp::PartialEq
            for BestBlockChanged<Hash> {
                #[inline]
                fn eq(&self, other: &BestBlockChanged<Hash>) -> bool {
                    self.best_block_hash == other.best_block_hash
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::cmp::Eq> ::core::cmp::Eq for BestBlockChanged<Hash> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Hash>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, Hash> _serde::Deserialize<'de> for BestBlockChanged<Hash>
                where
                    Hash: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "bestBlockHash" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"bestBlockHash" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            marker: _serde::__private::PhantomData<
                                BestBlockChanged<Hash>,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de, Hash> _serde::de::Visitor<'de> for __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            type Value = BestBlockChanged<Hash>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct BestBlockChanged",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Hash,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct BestBlockChanged with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(BestBlockChanged {
                                    best_block_hash: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Hash> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "bestBlockHash",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Hash>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("bestBlockHash")?
                                    }
                                };
                                _serde::__private::Ok(BestBlockChanged {
                                    best_block_hash: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["bestBlockHash"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "BestBlockChanged",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    BestBlockChanged<Hash>,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// Indicate the finalized and pruned block hashes.
            #[serde(rename_all = "camelCase")]
            pub struct Finalized<Hash> {
                /// Block hashes that are finalized.
                pub finalized_block_hashes: Vec<Hash>,
                /// Block hashes that are pruned (removed).
                pub pruned_block_hashes: Vec<Hash>,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug for Finalized<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Finalized",
                        "finalized_block_hashes",
                        &self.finalized_block_hashes,
                        "pruned_block_hashes",
                        &&self.pruned_block_hashes,
                    )
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone> ::core::clone::Clone for Finalized<Hash> {
                #[inline]
                fn clone(&self) -> Finalized<Hash> {
                    Finalized {
                        finalized_block_hashes: ::core::clone::Clone::clone(
                            &self.finalized_block_hashes,
                        ),
                        pruned_block_hashes: ::core::clone::Clone::clone(
                            &self.pruned_block_hashes,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl<Hash> ::core::marker::StructuralPartialEq for Finalized<Hash> {}
            #[automatically_derived]
            impl<Hash: ::core::cmp::PartialEq> ::core::cmp::PartialEq
            for Finalized<Hash> {
                #[inline]
                fn eq(&self, other: &Finalized<Hash>) -> bool {
                    self.finalized_block_hashes == other.finalized_block_hashes
                        && self.pruned_block_hashes == other.pruned_block_hashes
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::cmp::Eq> ::core::cmp::Eq for Finalized<Hash> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Vec<Hash>>;
                    let _: ::core::cmp::AssertParamIsEq<Vec<Hash>>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, Hash> _serde::Deserialize<'de> for Finalized<Hash>
                where
                    Hash: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "finalizedBlockHashes" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    "prunedBlockHashes" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"finalizedBlockHashes" => {
                                        _serde::__private::Ok(__Field::__field0)
                                    }
                                    b"prunedBlockHashes" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            marker: _serde::__private::PhantomData<Finalized<Hash>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de, Hash> _serde::de::Visitor<'de> for __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            type Value = Finalized<Hash>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Finalized",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Vec<Hash>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Finalized with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<Hash>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Finalized with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Finalized {
                                    finalized_block_hashes: __field0,
                                    pruned_block_hashes: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Vec<Hash>> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<Hash>> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "finalizedBlockHashes",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<Hash>>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "prunedBlockHashes",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<Hash>>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field(
                                            "finalizedBlockHashes",
                                        )?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("prunedBlockHashes")?
                                    }
                                };
                                _serde::__private::Ok(Finalized {
                                    finalized_block_hashes: __field0,
                                    pruned_block_hashes: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "finalizedBlockHashes",
                            "prunedBlockHashes",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Finalized",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Finalized<Hash>>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// Indicate the operation id of the event.
            #[serde(rename_all = "camelCase")]
            pub struct OperationId {
                /// The operation id of the event.
                pub operation_id: String,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for OperationId {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "OperationId",
                        "operation_id",
                        &&self.operation_id,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for OperationId {
                #[inline]
                fn clone(&self) -> OperationId {
                    OperationId {
                        operation_id: ::core::clone::Clone::clone(&self.operation_id),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for OperationId {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for OperationId {
                #[inline]
                fn eq(&self, other: &OperationId) -> bool {
                    self.operation_id == other.operation_id
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for OperationId {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for OperationId {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "operationId" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"operationId" => _serde::__private::Ok(__Field::__field0),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<OperationId>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = OperationId;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct OperationId",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct OperationId with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(OperationId {
                                    operation_id: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "operationId",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("operationId")?
                                    }
                                };
                                _serde::__private::Ok(OperationId {
                                    operation_id: __field0,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["operationId"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "OperationId",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<OperationId>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// The response of the `chainHead_body` method.
            #[serde(rename_all = "camelCase")]
            pub struct OperationBodyDone {
                /// The operation id of the event.
                pub operation_id: String,
                /// Array of hexadecimal-encoded scale-encoded extrinsics found in the block.
                pub value: Vec<Bytes>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for OperationBodyDone {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "OperationBodyDone",
                        "operation_id",
                        &self.operation_id,
                        "value",
                        &&self.value,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for OperationBodyDone {
                #[inline]
                fn clone(&self) -> OperationBodyDone {
                    OperationBodyDone {
                        operation_id: ::core::clone::Clone::clone(&self.operation_id),
                        value: ::core::clone::Clone::clone(&self.value),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for OperationBodyDone {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for OperationBodyDone {
                #[inline]
                fn eq(&self, other: &OperationBodyDone) -> bool {
                    self.operation_id == other.operation_id && self.value == other.value
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for OperationBodyDone {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                    let _: ::core::cmp::AssertParamIsEq<Vec<Bytes>>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for OperationBodyDone {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "operationId" => _serde::__private::Ok(__Field::__field0),
                                    "value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"operationId" => _serde::__private::Ok(__Field::__field0),
                                    b"value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<OperationBodyDone>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = OperationBodyDone;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct OperationBodyDone",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct OperationBodyDone with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Vec<Bytes>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct OperationBodyDone with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(OperationBodyDone {
                                    operation_id: __field0,
                                    value: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<Bytes>> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "operationId",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Vec<Bytes>>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("operationId")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("value")?
                                    }
                                };
                                _serde::__private::Ok(OperationBodyDone {
                                    operation_id: __field0,
                                    value: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "operationId",
                            "value",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "OperationBodyDone",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<OperationBodyDone>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// The response of the `chainHead_call` method.
            #[serde(rename_all = "camelCase")]
            pub struct OperationCallDone {
                /// The operation id of the event.
                pub operation_id: String,
                /// Hexadecimal-encoded output of the runtime function call.
                pub output: Bytes,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for OperationCallDone {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "OperationCallDone",
                        "operation_id",
                        &self.operation_id,
                        "output",
                        &&self.output,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for OperationCallDone {
                #[inline]
                fn clone(&self) -> OperationCallDone {
                    OperationCallDone {
                        operation_id: ::core::clone::Clone::clone(&self.operation_id),
                        output: ::core::clone::Clone::clone(&self.output),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for OperationCallDone {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for OperationCallDone {
                #[inline]
                fn eq(&self, other: &OperationCallDone) -> bool {
                    self.operation_id == other.operation_id
                        && self.output == other.output
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for OperationCallDone {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                    let _: ::core::cmp::AssertParamIsEq<Bytes>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for OperationCallDone {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "operationId" => _serde::__private::Ok(__Field::__field0),
                                    "output" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"operationId" => _serde::__private::Ok(__Field::__field0),
                                    b"output" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<OperationCallDone>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = OperationCallDone;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct OperationCallDone",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct OperationCallDone with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Bytes,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct OperationCallDone with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(OperationCallDone {
                                    operation_id: __field0,
                                    output: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Bytes> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "operationId",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("output"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Bytes>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("operationId")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("output")?
                                    }
                                };
                                _serde::__private::Ok(OperationCallDone {
                                    operation_id: __field0,
                                    output: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "operationId",
                            "output",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "OperationCallDone",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<OperationCallDone>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// The response of the `chainHead_call` method.
            #[serde(rename_all = "camelCase")]
            pub struct OperationStorageItems {
                /// The operation id of the event.
                pub operation_id: String,
                /// The resulting items.
                pub items: VecDeque<StorageResult>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for OperationStorageItems {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "OperationStorageItems",
                        "operation_id",
                        &self.operation_id,
                        "items",
                        &&self.items,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for OperationStorageItems {
                #[inline]
                fn clone(&self) -> OperationStorageItems {
                    OperationStorageItems {
                        operation_id: ::core::clone::Clone::clone(&self.operation_id),
                        items: ::core::clone::Clone::clone(&self.items),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for OperationStorageItems {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for OperationStorageItems {
                #[inline]
                fn eq(&self, other: &OperationStorageItems) -> bool {
                    self.operation_id == other.operation_id && self.items == other.items
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for OperationStorageItems {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                    let _: ::core::cmp::AssertParamIsEq<VecDeque<StorageResult>>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for OperationStorageItems {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "operationId" => _serde::__private::Ok(__Field::__field0),
                                    "items" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"operationId" => _serde::__private::Ok(__Field::__field0),
                                    b"items" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                OperationStorageItems,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = OperationStorageItems;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct OperationStorageItems",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct OperationStorageItems with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    VecDeque<StorageResult>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct OperationStorageItems with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(OperationStorageItems {
                                    operation_id: __field0,
                                    items: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    VecDeque<StorageResult>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "operationId",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("items"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    VecDeque<StorageResult>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("operationId")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("items")?
                                    }
                                };
                                _serde::__private::Ok(OperationStorageItems {
                                    operation_id: __field0,
                                    items: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "operationId",
                            "items",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "OperationStorageItems",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    OperationStorageItems,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// Indicate a problem during the operation.
            #[serde(rename_all = "camelCase")]
            pub struct OperationError {
                /// The operation id of the event.
                pub operation_id: String,
                /// The reason of the error.
                pub error: String,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for OperationError {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "OperationError",
                        "operation_id",
                        &self.operation_id,
                        "error",
                        &&self.error,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for OperationError {
                #[inline]
                fn clone(&self) -> OperationError {
                    OperationError {
                        operation_id: ::core::clone::Clone::clone(&self.operation_id),
                        error: ::core::clone::Clone::clone(&self.error),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for OperationError {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for OperationError {
                #[inline]
                fn eq(&self, other: &OperationError) -> bool {
                    self.operation_id == other.operation_id && self.error == other.error
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for OperationError {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for OperationError {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "operationId" => _serde::__private::Ok(__Field::__field0),
                                    "error" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"operationId" => _serde::__private::Ok(__Field::__field0),
                                    b"error" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<OperationError>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = OperationError;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct OperationError",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct OperationError with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct OperationError with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(OperationError {
                                    operation_id: __field0,
                                    error: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "operationId",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("error"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("operationId")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("error")?
                                    }
                                };
                                _serde::__private::Ok(OperationError {
                                    operation_id: __field0,
                                    error: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "operationId",
                            "error",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "OperationError",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<OperationError>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// The storage result.
            #[serde(rename_all = "camelCase")]
            pub struct StorageResult {
                /// The hex-encoded key of the result.
                pub key: Bytes,
                /// The result of the query.
                #[serde(flatten)]
                pub result: StorageResultType,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StorageResult {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "StorageResult",
                        "key",
                        &self.key,
                        "result",
                        &&self.result,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for StorageResult {
                #[inline]
                fn clone(&self) -> StorageResult {
                    StorageResult {
                        key: ::core::clone::Clone::clone(&self.key),
                        result: ::core::clone::Clone::clone(&self.result),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for StorageResult {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for StorageResult {
                #[inline]
                fn eq(&self, other: &StorageResult) -> bool {
                    self.key == other.key && self.result == other.result
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for StorageResult {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Bytes>;
                    let _: ::core::cmp::AssertParamIsEq<StorageResultType>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for StorageResult {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field<'de> {
                            __field0,
                            __other(_serde::__private::de::Content<'de>),
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field<'de>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_bool<__E>(
                                self,
                                __value: bool,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::Bool(__value),
                                    ),
                                )
                            }
                            fn visit_i8<__E>(
                                self,
                                __value: i8,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::I8(__value),
                                    ),
                                )
                            }
                            fn visit_i16<__E>(
                                self,
                                __value: i16,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::I16(__value),
                                    ),
                                )
                            }
                            fn visit_i32<__E>(
                                self,
                                __value: i32,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::I32(__value),
                                    ),
                                )
                            }
                            fn visit_i64<__E>(
                                self,
                                __value: i64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::I64(__value),
                                    ),
                                )
                            }
                            fn visit_u8<__E>(
                                self,
                                __value: u8,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::U8(__value),
                                    ),
                                )
                            }
                            fn visit_u16<__E>(
                                self,
                                __value: u16,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::U16(__value),
                                    ),
                                )
                            }
                            fn visit_u32<__E>(
                                self,
                                __value: u32,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::U32(__value),
                                    ),
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::U64(__value),
                                    ),
                                )
                            }
                            fn visit_f32<__E>(
                                self,
                                __value: f32,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::F32(__value),
                                    ),
                                )
                            }
                            fn visit_f64<__E>(
                                self,
                                __value: f64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::F64(__value),
                                    ),
                                )
                            }
                            fn visit_char<__E>(
                                self,
                                __value: char,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(
                                        _serde::__private::de::Content::Char(__value),
                                    ),
                                )
                            }
                            fn visit_unit<__E>(
                                self,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                _serde::__private::Ok(
                                    __Field::__other(_serde::__private::de::Content::Unit),
                                )
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "key" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        let __value = _serde::__private::de::Content::String(
                                            _serde::__private::ToString::to_string(__value),
                                        );
                                        _serde::__private::Ok(__Field::__other(__value))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"key" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        let __value = _serde::__private::de::Content::ByteBuf(
                                            __value.to_vec(),
                                        );
                                        _serde::__private::Ok(__Field::__other(__value))
                                    }
                                }
                            }
                            fn visit_borrowed_str<__E>(
                                self,
                                __value: &'de str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "key" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        let __value = _serde::__private::de::Content::Str(__value);
                                        _serde::__private::Ok(__Field::__other(__value))
                                    }
                                }
                            }
                            fn visit_borrowed_bytes<__E>(
                                self,
                                __value: &'de [u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"key" => _serde::__private::Ok(__Field::__field0),
                                    _ => {
                                        let __value = _serde::__private::de::Content::Bytes(
                                            __value,
                                        );
                                        _serde::__private::Ok(__Field::__other(__value))
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field<'de> {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<StorageResult>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = StorageResult;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct StorageResult",
                                )
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Bytes> = _serde::__private::None;
                                let mut __collect = _serde::__private::Vec::<
                                    _serde::__private::Option<
                                        (
                                            _serde::__private::de::Content,
                                            _serde::__private::de::Content,
                                        ),
                                    >,
                                >::new();
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Bytes>(&mut __map)?,
                                            );
                                        }
                                        __Field::__other(__name) => {
                                            __collect
                                                .push(
                                                    _serde::__private::Some((
                                                        __name,
                                                        _serde::de::MapAccess::next_value(&mut __map)?,
                                                    )),
                                                );
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("key")?
                                    }
                                };
                                let __field1: StorageResultType = _serde::de::Deserialize::deserialize(
                                    _serde::__private::de::FlatMapDeserializer(
                                        &mut __collect,
                                        _serde::__private::PhantomData,
                                    ),
                                )?;
                                _serde::__private::Ok(StorageResult {
                                    key: __field0,
                                    result: __field1,
                                })
                            }
                        }
                        _serde::Deserializer::deserialize_map(
                            __deserializer,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<StorageResult>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// The type of the storage query.
            #[serde(rename_all = "camelCase")]
            pub enum StorageResultType {
                /// Fetch the value of the provided key.
                Value(Bytes),
                /// Fetch the hash of the value of the provided key.
                Hash(Bytes),
                /// Fetch the closest descendant merkle value.
                ClosestDescendantMerkleValue(Bytes),
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StorageResultType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        StorageResultType::Value(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Value",
                                &__self_0,
                            )
                        }
                        StorageResultType::Hash(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Hash",
                                &__self_0,
                            )
                        }
                        StorageResultType::ClosestDescendantMerkleValue(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "ClosestDescendantMerkleValue",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for StorageResultType {
                #[inline]
                fn clone(&self) -> StorageResultType {
                    match self {
                        StorageResultType::Value(__self_0) => {
                            StorageResultType::Value(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        StorageResultType::Hash(__self_0) => {
                            StorageResultType::Hash(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        StorageResultType::ClosestDescendantMerkleValue(__self_0) => {
                            StorageResultType::ClosestDescendantMerkleValue(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for StorageResultType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for StorageResultType {
                #[inline]
                fn eq(&self, other: &StorageResultType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                StorageResultType::Value(__self_0),
                                StorageResultType::Value(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                StorageResultType::Hash(__self_0),
                                StorageResultType::Hash(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                StorageResultType::ClosestDescendantMerkleValue(__self_0),
                                StorageResultType::ClosestDescendantMerkleValue(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for StorageResultType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Bytes>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for StorageResultType {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "value" => _serde::__private::Ok(__Field::__field0),
                                    "hash" => _serde::__private::Ok(__Field::__field1),
                                    "closestDescendantMerkleValue" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"value" => _serde::__private::Ok(__Field::__field0),
                                    b"hash" => _serde::__private::Ok(__Field::__field1),
                                    b"closestDescendantMerkleValue" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<StorageResultType>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = StorageResultType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum StorageResultType",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Bytes,
                                            >(__variant),
                                            StorageResultType::Value,
                                        )
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Bytes,
                                            >(__variant),
                                            StorageResultType::Hash,
                                        )
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Bytes,
                                            >(__variant),
                                            StorageResultType::ClosestDescendantMerkleValue,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "value",
                            "hash",
                            "closestDescendantMerkleValue",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "StorageResultType",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<StorageResultType>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// The method response of `chainHead_body`, `chainHead_call` and `chainHead_storage`.
            #[serde(rename_all = "camelCase")]
            #[serde(tag = "result")]
            pub enum MethodResponse {
                /// The method has started.
                Started(MethodResponseStarted),
                /// The RPC server cannot handle the request at the moment.
                LimitReached,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MethodResponse {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        MethodResponse::Started(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Started",
                                &__self_0,
                            )
                        }
                        MethodResponse::LimitReached => {
                            ::core::fmt::Formatter::write_str(f, "LimitReached")
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MethodResponse {
                #[inline]
                fn clone(&self) -> MethodResponse {
                    match self {
                        MethodResponse::Started(__self_0) => {
                            MethodResponse::Started(
                                ::core::clone::Clone::clone(__self_0),
                            )
                        }
                        MethodResponse::LimitReached => MethodResponse::LimitReached,
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for MethodResponse {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for MethodResponse {
                #[inline]
                fn eq(&self, other: &MethodResponse) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                MethodResponse::Started(__self_0),
                                MethodResponse::Started(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => true,
                        }
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for MethodResponse {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<MethodResponseStarted>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for MethodResponse {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "started" => _serde::__private::Ok(__Field::__field0),
                                    "limitReached" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"started" => _serde::__private::Ok(__Field::__field0),
                                    b"limitReached" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "started",
                            "limitReached",
                        ];
                        let (__tag, __content) = _serde::Deserializer::deserialize_any(
                            __deserializer,
                            _serde::__private::de::TaggedContentVisitor::<
                                __Field,
                            >::new("result", "internally tagged enum MethodResponse"),
                        )?;
                        let __deserializer = _serde::__private::de::ContentDeserializer::<
                            __D::Error,
                        >::new(__content);
                        match __tag {
                            __Field::__field0 => {
                                _serde::__private::Result::map(
                                    <MethodResponseStarted as _serde::Deserialize>::deserialize(
                                        __deserializer,
                                    ),
                                    MethodResponse::Started,
                                )
                            }
                            __Field::__field1 => {
                                _serde::Deserializer::deserialize_any(
                                    __deserializer,
                                    _serde::__private::de::InternallyTaggedUnitVisitor::new(
                                        "MethodResponse",
                                        "LimitReached",
                                    ),
                                )?;
                                _serde::__private::Ok(MethodResponse::LimitReached)
                            }
                        }
                    }
                }
            };
            /// The `started` result of a method.
            #[serde(rename_all = "camelCase")]
            pub struct MethodResponseStarted {
                /// The operation id of the response.
                pub operation_id: String,
                /// The number of items from the back of the `chainHead_storage` that have been discarded.
                pub discarded_items: Option<usize>,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for MethodResponseStarted {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "MethodResponseStarted",
                        "operation_id",
                        &self.operation_id,
                        "discarded_items",
                        &&self.discarded_items,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for MethodResponseStarted {
                #[inline]
                fn clone(&self) -> MethodResponseStarted {
                    MethodResponseStarted {
                        operation_id: ::core::clone::Clone::clone(&self.operation_id),
                        discarded_items: ::core::clone::Clone::clone(
                            &self.discarded_items,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for MethodResponseStarted {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for MethodResponseStarted {
                #[inline]
                fn eq(&self, other: &MethodResponseStarted) -> bool {
                    self.operation_id == other.operation_id
                        && self.discarded_items == other.discarded_items
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for MethodResponseStarted {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                    let _: ::core::cmp::AssertParamIsEq<Option<usize>>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for MethodResponseStarted {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "operationId" => _serde::__private::Ok(__Field::__field0),
                                    "discardedItems" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"operationId" => _serde::__private::Ok(__Field::__field0),
                                    b"discardedItems" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                MethodResponseStarted,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = MethodResponseStarted;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct MethodResponseStarted",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct MethodResponseStarted with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Option<usize>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct MethodResponseStarted with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(MethodResponseStarted {
                                    operation_id: __field0,
                                    discarded_items: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Option<usize>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "operationId",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "discardedItems",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<usize>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("operationId")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("discardedItems")?
                                    }
                                };
                                _serde::__private::Ok(MethodResponseStarted {
                                    operation_id: __field0,
                                    discarded_items: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "operationId",
                            "discardedItems",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "MethodResponseStarted",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    MethodResponseStarted,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// The storage item received as parameter.
            #[serde(rename_all = "camelCase")]
            pub struct StorageQuery<Key> {
                /// The provided key.
                pub key: Key,
                /// The type of the storage query.
                #[serde(rename = "type")]
                pub query_type: StorageQueryType,
            }
            #[automatically_derived]
            impl<Key: ::core::fmt::Debug> ::core::fmt::Debug for StorageQuery<Key> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "StorageQuery",
                        "key",
                        &self.key,
                        "query_type",
                        &&self.query_type,
                    )
                }
            }
            #[automatically_derived]
            impl<Key: ::core::clone::Clone> ::core::clone::Clone for StorageQuery<Key> {
                #[inline]
                fn clone(&self) -> StorageQuery<Key> {
                    StorageQuery {
                        key: ::core::clone::Clone::clone(&self.key),
                        query_type: ::core::clone::Clone::clone(&self.query_type),
                    }
                }
            }
            #[automatically_derived]
            impl<Key> ::core::marker::StructuralPartialEq for StorageQuery<Key> {}
            #[automatically_derived]
            impl<Key: ::core::cmp::PartialEq> ::core::cmp::PartialEq
            for StorageQuery<Key> {
                #[inline]
                fn eq(&self, other: &StorageQuery<Key>) -> bool {
                    self.key == other.key && self.query_type == other.query_type
                }
            }
            #[automatically_derived]
            impl<Key: ::core::cmp::Eq> ::core::cmp::Eq for StorageQuery<Key> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Key>;
                    let _: ::core::cmp::AssertParamIsEq<StorageQueryType>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<Key> _serde::Serialize for StorageQuery<Key>
                where
                    Key: _serde::Serialize,
                {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "StorageQuery",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "key",
                            &self.key,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            &self.query_type,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, Key> _serde::Deserialize<'de> for StorageQuery<Key>
                where
                    Key: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "key" => _serde::__private::Ok(__Field::__field0),
                                    "type" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"key" => _serde::__private::Ok(__Field::__field0),
                                    b"type" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, Key>
                        where
                            Key: _serde::Deserialize<'de>,
                        {
                            marker: _serde::__private::PhantomData<StorageQuery<Key>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de, Key> _serde::de::Visitor<'de> for __Visitor<'de, Key>
                        where
                            Key: _serde::Deserialize<'de>,
                        {
                            type Value = StorageQuery<Key>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct StorageQuery",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Key,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct StorageQuery with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    StorageQueryType,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct StorageQuery with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(StorageQuery {
                                    key: __field0,
                                    query_type: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Key> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    StorageQueryType,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Key>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("type"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    StorageQueryType,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("key")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("type")?
                                    }
                                };
                                _serde::__private::Ok(StorageQuery {
                                    key: __field0,
                                    query_type: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["key", "type"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "StorageQuery",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<StorageQuery<Key>>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// The type of the storage query.
            #[serde(rename_all = "camelCase")]
            pub enum StorageQueryType {
                /// Fetch the value of the provided key.
                Value,
                /// Fetch the hash of the value of the provided key.
                Hash,
                /// Fetch the closest descendant merkle value.
                ClosestDescendantMerkleValue,
                /// Fetch the values of all descendants of they provided key.
                DescendantsValues,
                /// Fetch the hashes of the values of all descendants of they provided key.
                DescendantsHashes,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for StorageQueryType {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            StorageQueryType::Value => "Value",
                            StorageQueryType::Hash => "Hash",
                            StorageQueryType::ClosestDescendantMerkleValue => {
                                "ClosestDescendantMerkleValue"
                            }
                            StorageQueryType::DescendantsValues => "DescendantsValues",
                            StorageQueryType::DescendantsHashes => "DescendantsHashes",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for StorageQueryType {
                #[inline]
                fn clone(&self) -> StorageQueryType {
                    match self {
                        StorageQueryType::Value => StorageQueryType::Value,
                        StorageQueryType::Hash => StorageQueryType::Hash,
                        StorageQueryType::ClosestDescendantMerkleValue => {
                            StorageQueryType::ClosestDescendantMerkleValue
                        }
                        StorageQueryType::DescendantsValues => {
                            StorageQueryType::DescendantsValues
                        }
                        StorageQueryType::DescendantsHashes => {
                            StorageQueryType::DescendantsHashes
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for StorageQueryType {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for StorageQueryType {
                #[inline]
                fn eq(&self, other: &StorageQueryType) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for StorageQueryType {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for StorageQueryType {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            StorageQueryType::Value => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "StorageQueryType",
                                    0u32,
                                    "value",
                                )
                            }
                            StorageQueryType::Hash => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "StorageQueryType",
                                    1u32,
                                    "hash",
                                )
                            }
                            StorageQueryType::ClosestDescendantMerkleValue => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "StorageQueryType",
                                    2u32,
                                    "closestDescendantMerkleValue",
                                )
                            }
                            StorageQueryType::DescendantsValues => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "StorageQueryType",
                                    3u32,
                                    "descendantsValues",
                                )
                            }
                            StorageQueryType::DescendantsHashes => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "StorageQueryType",
                                    4u32,
                                    "descendantsHashes",
                                )
                            }
                        }
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for StorageQueryType {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 5",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "value" => _serde::__private::Ok(__Field::__field0),
                                    "hash" => _serde::__private::Ok(__Field::__field1),
                                    "closestDescendantMerkleValue" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    "descendantsValues" => {
                                        _serde::__private::Ok(__Field::__field3)
                                    }
                                    "descendantsHashes" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"value" => _serde::__private::Ok(__Field::__field0),
                                    b"hash" => _serde::__private::Ok(__Field::__field1),
                                    b"closestDescendantMerkleValue" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    b"descendantsValues" => {
                                        _serde::__private::Ok(__Field::__field3)
                                    }
                                    b"descendantsHashes" => {
                                        _serde::__private::Ok(__Field::__field4)
                                    }
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<StorageQueryType>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = StorageQueryType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum StorageQueryType",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(StorageQueryType::Value)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(StorageQueryType::Hash)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(
                                            StorageQueryType::ClosestDescendantMerkleValue,
                                        )
                                    }
                                    (__Field::__field3, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(StorageQueryType::DescendantsValues)
                                    }
                                    (__Field::__field4, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(StorageQueryType::DescendantsHashes)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "value",
                            "hash",
                            "closestDescendantMerkleValue",
                            "descendantsValues",
                            "descendantsHashes",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "StorageQueryType",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<StorageQueryType>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// A subscription which returns follow events, and ends when a Stop event occurs.
            pub struct FollowSubscription<Hash> {
                sub: RpcSubscription<FollowEvent<Hash>>,
                done: bool,
            }
            impl<Hash: BlockHash> FollowSubscription<Hash> {
                /// Fetch the next item in the stream.
                pub async fn next(&mut self) -> Option<<Self as Stream>::Item> {
                    <Self as StreamExt>::next(self).await
                }
                /// Fetch the subscription ID for the stream.
                pub fn subscription_id(&self) -> Option<&str> {
                    self.sub.subscription_id()
                }
            }
            impl<Hash: BlockHash> Stream for FollowSubscription<Hash> {
                type Item = <RpcSubscription<FollowEvent<Hash>> as Stream>::Item;
                fn poll_next(
                    mut self: std::pin::Pin<&mut Self>,
                    cx: &mut std::task::Context<'_>,
                ) -> std::task::Poll<Option<Self::Item>> {
                    if self.done {
                        return Poll::Ready(None);
                    }
                    let res = self.sub.poll_next_unpin(cx);
                    if let Poll::Ready(Some(Ok(FollowEvent::Stop))) = &res {
                        self.done = true;
                    }
                    res
                }
            }
            /// A subscription which returns transaction status events, stopping
            /// when no more events will be sent.
            pub struct TransactionSubscription<Hash> {
                sub: RpcSubscription<TransactionStatus<Hash>>,
                done: bool,
            }
            impl<Hash: BlockHash> TransactionSubscription<Hash> {
                /// Fetch the next item in the stream.
                pub async fn next(&mut self) -> Option<<Self as Stream>::Item> {
                    <Self as StreamExt>::next(self).await
                }
            }
            impl<Hash: BlockHash> Stream for TransactionSubscription<Hash> {
                type Item = <RpcSubscription<TransactionStatus<Hash>> as Stream>::Item;
                fn poll_next(
                    mut self: std::pin::Pin<&mut Self>,
                    cx: &mut std::task::Context<'_>,
                ) -> std::task::Poll<Option<Self::Item>> {
                    if self.done {
                        return Poll::Ready(None);
                    }
                    let res = self.sub.poll_next_unpin(cx);
                    if let Poll::Ready(Some(Ok(res))) = &res {
                        if match res {
                            TransactionStatus::Dropped { .. }
                            | TransactionStatus::Error { .. }
                            | TransactionStatus::Invalid { .. }
                            | TransactionStatus::Finalized { .. } => true,
                            _ => false,
                        } {
                            self.done = true;
                        }
                    }
                    res
                }
            }
            /// Transaction progress events
            #[serde(rename_all = "camelCase")]
            #[serde(tag = "event")]
            pub enum TransactionStatus<Hash> {
                /// Transaction is part of the future queue.
                Validated,
                /// The transaction has been broadcast to other nodes.
                Broadcasted {
                    /// Number of peers it's been broadcast to.
                    num_peers: u32,
                },
                /// Transaction has been included in block with given details.
                /// Null is returned if the transaction is no longer in any block
                /// of the best chain.
                BestChainBlockIncluded {
                    /// Details of the block it's been seen in.
                    block: Option<TransactionBlockDetails<Hash>>,
                },
                /// The transaction is in a block that's been finalized.
                Finalized {
                    /// Details of the block it's been seen in.
                    block: TransactionBlockDetails<Hash>,
                },
                /// Something went wrong in the node.
                Error {
                    /// Human readable message; what went wrong.
                    error: String,
                },
                /// Transaction is invalid (bad nonce, signature etc).
                Invalid {
                    /// Human readable message; why was it invalid.
                    error: String,
                },
                /// The transaction was dropped.
                Dropped {
                    /// Was the transaction broadcasted to other nodes before being dropped?
                    broadcasted: bool,
                    /// Human readable message; why was it dropped.
                    error: String,
                },
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug
            for TransactionStatus<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        TransactionStatus::Validated => {
                            ::core::fmt::Formatter::write_str(f, "Validated")
                        }
                        TransactionStatus::Broadcasted { num_peers: __self_0 } => {
                            ::core::fmt::Formatter::debug_struct_field1_finish(
                                f,
                                "Broadcasted",
                                "num_peers",
                                &__self_0,
                            )
                        }
                        TransactionStatus::BestChainBlockIncluded { block: __self_0 } => {
                            ::core::fmt::Formatter::debug_struct_field1_finish(
                                f,
                                "BestChainBlockIncluded",
                                "block",
                                &__self_0,
                            )
                        }
                        TransactionStatus::Finalized { block: __self_0 } => {
                            ::core::fmt::Formatter::debug_struct_field1_finish(
                                f,
                                "Finalized",
                                "block",
                                &__self_0,
                            )
                        }
                        TransactionStatus::Error { error: __self_0 } => {
                            ::core::fmt::Formatter::debug_struct_field1_finish(
                                f,
                                "Error",
                                "error",
                                &__self_0,
                            )
                        }
                        TransactionStatus::Invalid { error: __self_0 } => {
                            ::core::fmt::Formatter::debug_struct_field1_finish(
                                f,
                                "Invalid",
                                "error",
                                &__self_0,
                            )
                        }
                        TransactionStatus::Dropped {
                            broadcasted: __self_0,
                            error: __self_1,
                        } => {
                            ::core::fmt::Formatter::debug_struct_field2_finish(
                                f,
                                "Dropped",
                                "broadcasted",
                                __self_0,
                                "error",
                                &__self_1,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone> ::core::clone::Clone
            for TransactionStatus<Hash> {
                #[inline]
                fn clone(&self) -> TransactionStatus<Hash> {
                    match self {
                        TransactionStatus::Validated => TransactionStatus::Validated,
                        TransactionStatus::Broadcasted { num_peers: __self_0 } => {
                            TransactionStatus::Broadcasted {
                                num_peers: ::core::clone::Clone::clone(__self_0),
                            }
                        }
                        TransactionStatus::BestChainBlockIncluded { block: __self_0 } => {
                            TransactionStatus::BestChainBlockIncluded {
                                block: ::core::clone::Clone::clone(__self_0),
                            }
                        }
                        TransactionStatus::Finalized { block: __self_0 } => {
                            TransactionStatus::Finalized {
                                block: ::core::clone::Clone::clone(__self_0),
                            }
                        }
                        TransactionStatus::Error { error: __self_0 } => {
                            TransactionStatus::Error {
                                error: ::core::clone::Clone::clone(__self_0),
                            }
                        }
                        TransactionStatus::Invalid { error: __self_0 } => {
                            TransactionStatus::Invalid {
                                error: ::core::clone::Clone::clone(__self_0),
                            }
                        }
                        TransactionStatus::Dropped {
                            broadcasted: __self_0,
                            error: __self_1,
                        } => {
                            TransactionStatus::Dropped {
                                broadcasted: ::core::clone::Clone::clone(__self_0),
                                error: ::core::clone::Clone::clone(__self_1),
                            }
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<Hash> ::core::marker::StructuralPartialEq for TransactionStatus<Hash> {}
            #[automatically_derived]
            impl<Hash: ::core::cmp::PartialEq> ::core::cmp::PartialEq
            for TransactionStatus<Hash> {
                #[inline]
                fn eq(&self, other: &TransactionStatus<Hash>) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                TransactionStatus::Broadcasted { num_peers: __self_0 },
                                TransactionStatus::Broadcasted { num_peers: __arg1_0 },
                            ) => *__self_0 == *__arg1_0,
                            (
                                TransactionStatus::BestChainBlockIncluded {
                                    block: __self_0,
                                },
                                TransactionStatus::BestChainBlockIncluded {
                                    block: __arg1_0,
                                },
                            ) => *__self_0 == *__arg1_0,
                            (
                                TransactionStatus::Finalized { block: __self_0 },
                                TransactionStatus::Finalized { block: __arg1_0 },
                            ) => *__self_0 == *__arg1_0,
                            (
                                TransactionStatus::Error { error: __self_0 },
                                TransactionStatus::Error { error: __arg1_0 },
                            ) => *__self_0 == *__arg1_0,
                            (
                                TransactionStatus::Invalid { error: __self_0 },
                                TransactionStatus::Invalid { error: __arg1_0 },
                            ) => *__self_0 == *__arg1_0,
                            (
                                TransactionStatus::Dropped {
                                    broadcasted: __self_0,
                                    error: __self_1,
                                },
                                TransactionStatus::Dropped {
                                    broadcasted: __arg1_0,
                                    error: __arg1_1,
                                },
                            ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                            _ => true,
                        }
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::cmp::Eq> ::core::cmp::Eq for TransactionStatus<Hash> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                    let _: ::core::cmp::AssertParamIsEq<
                        Option<TransactionBlockDetails<Hash>>,
                    >;
                    let _: ::core::cmp::AssertParamIsEq<TransactionBlockDetails<Hash>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                    let _: ::core::cmp::AssertParamIsEq<bool>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, Hash> _serde::Deserialize<'de> for TransactionStatus<Hash>
                where
                    Hash: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    5u64 => _serde::__private::Ok(__Field::__field5),
                                    6u64 => _serde::__private::Ok(__Field::__field6),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 7",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "validated" => _serde::__private::Ok(__Field::__field0),
                                    "broadcasted" => _serde::__private::Ok(__Field::__field1),
                                    "bestChainBlockIncluded" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    "finalized" => _serde::__private::Ok(__Field::__field3),
                                    "error" => _serde::__private::Ok(__Field::__field4),
                                    "invalid" => _serde::__private::Ok(__Field::__field5),
                                    "dropped" => _serde::__private::Ok(__Field::__field6),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"validated" => _serde::__private::Ok(__Field::__field0),
                                    b"broadcasted" => _serde::__private::Ok(__Field::__field1),
                                    b"bestChainBlockIncluded" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    b"finalized" => _serde::__private::Ok(__Field::__field3),
                                    b"error" => _serde::__private::Ok(__Field::__field4),
                                    b"invalid" => _serde::__private::Ok(__Field::__field5),
                                    b"dropped" => _serde::__private::Ok(__Field::__field6),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "validated",
                            "broadcasted",
                            "bestChainBlockIncluded",
                            "finalized",
                            "error",
                            "invalid",
                            "dropped",
                        ];
                        let (__tag, __content) = _serde::Deserializer::deserialize_any(
                            __deserializer,
                            _serde::__private::de::TaggedContentVisitor::<
                                __Field,
                            >::new("event", "internally tagged enum TransactionStatus"),
                        )?;
                        let __deserializer = _serde::__private::de::ContentDeserializer::<
                            __D::Error,
                        >::new(__content);
                        match __tag {
                            __Field::__field0 => {
                                _serde::Deserializer::deserialize_any(
                                    __deserializer,
                                    _serde::__private::de::InternallyTaggedUnitVisitor::new(
                                        "TransactionStatus",
                                        "Validated",
                                    ),
                                )?;
                                _serde::__private::Ok(TransactionStatus::Validated)
                            }
                            __Field::__field1 => {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "num_peers" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"num_peers" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de, Hash>
                                where
                                    Hash: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::__private::PhantomData<
                                        TransactionStatus<Hash>,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de, Hash> _serde::de::Visitor<'de>
                                for __Visitor<'de, Hash>
                                where
                                    Hash: _serde::Deserialize<'de>,
                                {
                                    type Value = TransactionStatus<Hash>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant TransactionStatus::Broadcasted",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            u32,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant TransactionStatus::Broadcasted with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(TransactionStatus::Broadcasted {
                                            num_peers: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "num_peers",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                                    );
                                                }
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("num_peers")?
                                            }
                                        };
                                        _serde::__private::Ok(TransactionStatus::Broadcasted {
                                            num_peers: __field0,
                                        })
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &["num_peers"];
                                _serde::Deserializer::deserialize_any(
                                    __deserializer,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<
                                            TransactionStatus<Hash>,
                                        >,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            __Field::__field2 => {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "block" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"block" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de, Hash>
                                where
                                    Hash: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::__private::PhantomData<
                                        TransactionStatus<Hash>,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de, Hash> _serde::de::Visitor<'de>
                                for __Visitor<'de, Hash>
                                where
                                    Hash: _serde::Deserialize<'de>,
                                {
                                    type Value = TransactionStatus<Hash>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant TransactionStatus::BestChainBlockIncluded",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            Option<TransactionBlockDetails<Hash>>,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant TransactionStatus::BestChainBlockIncluded with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(TransactionStatus::BestChainBlockIncluded {
                                            block: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            Option<TransactionBlockDetails<Hash>>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field("block"),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<
                                                            Option<TransactionBlockDetails<Hash>>,
                                                        >(&mut __map)?,
                                                    );
                                                }
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("block")?
                                            }
                                        };
                                        _serde::__private::Ok(TransactionStatus::BestChainBlockIncluded {
                                            block: __field0,
                                        })
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &["block"];
                                _serde::Deserializer::deserialize_any(
                                    __deserializer,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<
                                            TransactionStatus<Hash>,
                                        >,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            __Field::__field3 => {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "block" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"block" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de, Hash>
                                where
                                    Hash: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::__private::PhantomData<
                                        TransactionStatus<Hash>,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de, Hash> _serde::de::Visitor<'de>
                                for __Visitor<'de, Hash>
                                where
                                    Hash: _serde::Deserialize<'de>,
                                {
                                    type Value = TransactionStatus<Hash>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant TransactionStatus::Finalized",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            TransactionBlockDetails<Hash>,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant TransactionStatus::Finalized with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(TransactionStatus::Finalized {
                                            block: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            TransactionBlockDetails<Hash>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field("block"),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<
                                                            TransactionBlockDetails<Hash>,
                                                        >(&mut __map)?,
                                                    );
                                                }
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("block")?
                                            }
                                        };
                                        _serde::__private::Ok(TransactionStatus::Finalized {
                                            block: __field0,
                                        })
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &["block"];
                                _serde::Deserializer::deserialize_any(
                                    __deserializer,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<
                                            TransactionStatus<Hash>,
                                        >,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            __Field::__field4 => {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "error" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"error" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de, Hash>
                                where
                                    Hash: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::__private::PhantomData<
                                        TransactionStatus<Hash>,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de, Hash> _serde::de::Visitor<'de>
                                for __Visitor<'de, Hash>
                                where
                                    Hash: _serde::Deserialize<'de>,
                                {
                                    type Value = TransactionStatus<Hash>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant TransactionStatus::Error",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant TransactionStatus::Error with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(TransactionStatus::Error {
                                            error: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field("error"),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                    );
                                                }
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("error")?
                                            }
                                        };
                                        _serde::__private::Ok(TransactionStatus::Error {
                                            error: __field0,
                                        })
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &["error"];
                                _serde::Deserializer::deserialize_any(
                                    __deserializer,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<
                                            TransactionStatus<Hash>,
                                        >,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            __Field::__field5 => {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "error" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"error" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de, Hash>
                                where
                                    Hash: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::__private::PhantomData<
                                        TransactionStatus<Hash>,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de, Hash> _serde::de::Visitor<'de>
                                for __Visitor<'de, Hash>
                                where
                                    Hash: _serde::Deserialize<'de>,
                                {
                                    type Value = TransactionStatus<Hash>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant TransactionStatus::Invalid",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant TransactionStatus::Invalid with 1 element",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(TransactionStatus::Invalid {
                                            error: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field("error"),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                    );
                                                }
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("error")?
                                            }
                                        };
                                        _serde::__private::Ok(TransactionStatus::Invalid {
                                            error: __field0,
                                        })
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &["error"];
                                _serde::Deserializer::deserialize_any(
                                    __deserializer,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<
                                            TransactionStatus<Hash>,
                                        >,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            __Field::__field6 => {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                #[doc(hidden)]
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "broadcasted" => _serde::__private::Ok(__Field::__field0),
                                            "error" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"broadcasted" => _serde::__private::Ok(__Field::__field0),
                                            b"error" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                #[doc(hidden)]
                                struct __Visitor<'de, Hash>
                                where
                                    Hash: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::__private::PhantomData<
                                        TransactionStatus<Hash>,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de, Hash> _serde::de::Visitor<'de>
                                for __Visitor<'de, Hash>
                                where
                                    Hash: _serde::Deserialize<'de>,
                                {
                                    type Value = TransactionStatus<Hash>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant TransactionStatus::Dropped",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 = match _serde::de::SeqAccess::next_element::<
                                            bool,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        0usize,
                                                        &"struct variant TransactionStatus::Dropped with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        let __field1 = match _serde::de::SeqAccess::next_element::<
                                            String,
                                        >(&mut __seq)? {
                                            _serde::__private::Some(__value) => __value,
                                            _serde::__private::None => {
                                                return _serde::__private::Err(
                                                    _serde::de::Error::invalid_length(
                                                        1usize,
                                                        &"struct variant TransactionStatus::Dropped with 2 elements",
                                                    ),
                                                );
                                            }
                                        };
                                        _serde::__private::Ok(TransactionStatus::Dropped {
                                            broadcasted: __field0,
                                            error: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                                        while let _serde::__private::Some(__key)
                                            = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                                "broadcasted",
                                                            ),
                                                        );
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1) {
                                                        return _serde::__private::Err(
                                                            <__A::Error as _serde::de::Error>::duplicate_field("error"),
                                                        );
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                                    );
                                                }
                                                _ => {
                                                    let _ = _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(&mut __map)?;
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("broadcasted")?
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                _serde::__private::de::missing_field("error")?
                                            }
                                        };
                                        _serde::__private::Ok(TransactionStatus::Dropped {
                                            broadcasted: __field0,
                                            error: __field1,
                                        })
                                    }
                                }
                                #[doc(hidden)]
                                const FIELDS: &'static [&'static str] = &[
                                    "broadcasted",
                                    "error",
                                ];
                                _serde::Deserializer::deserialize_any(
                                    __deserializer,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<
                                            TransactionStatus<Hash>,
                                        >,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                        }
                    }
                }
            };
            /// Details of a block that a transaction is seen in.
            pub struct TransactionBlockDetails<Hash> {
                /// The block hash.
                pub hash: Hash,
                /// The index of the transaction in the block.
                #[serde(with = "unsigned_number_as_string")]
                pub index: u64,
            }
            #[automatically_derived]
            impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug
            for TransactionBlockDetails<Hash> {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "TransactionBlockDetails",
                        "hash",
                        &self.hash,
                        "index",
                        &&self.index,
                    )
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::clone::Clone> ::core::clone::Clone
            for TransactionBlockDetails<Hash> {
                #[inline]
                fn clone(&self) -> TransactionBlockDetails<Hash> {
                    TransactionBlockDetails {
                        hash: ::core::clone::Clone::clone(&self.hash),
                        index: ::core::clone::Clone::clone(&self.index),
                    }
                }
            }
            #[automatically_derived]
            impl<Hash> ::core::marker::StructuralPartialEq
            for TransactionBlockDetails<Hash> {}
            #[automatically_derived]
            impl<Hash: ::core::cmp::PartialEq> ::core::cmp::PartialEq
            for TransactionBlockDetails<Hash> {
                #[inline]
                fn eq(&self, other: &TransactionBlockDetails<Hash>) -> bool {
                    self.hash == other.hash && self.index == other.index
                }
            }
            #[automatically_derived]
            impl<Hash: ::core::cmp::Eq> ::core::cmp::Eq
            for TransactionBlockDetails<Hash> {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Hash>;
                    let _: ::core::cmp::AssertParamIsEq<u64>;
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, Hash> _serde::Deserialize<'de>
                for TransactionBlockDetails<Hash>
                where
                    Hash: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "hash" => _serde::__private::Ok(__Field::__field0),
                                    "index" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"hash" => _serde::__private::Ok(__Field::__field0),
                                    b"index" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            marker: _serde::__private::PhantomData<
                                TransactionBlockDetails<Hash>,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de, Hash> _serde::de::Visitor<'de> for __Visitor<'de, Hash>
                        where
                            Hash: _serde::Deserialize<'de>,
                        {
                            type Value = TransactionBlockDetails<Hash>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct TransactionBlockDetails",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Hash,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct TransactionBlockDetails with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de, Hash>
                                    where
                                        Hash: _serde::Deserialize<'de>,
                                    {
                                        value: u64,
                                        phantom: _serde::__private::PhantomData<
                                            TransactionBlockDetails<Hash>,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de, Hash> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de, Hash>
                                    where
                                        Hash: _serde::Deserialize<'de>,
                                    {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: unsigned_number_as_string::deserialize(
                                                    __deserializer,
                                                )?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de, Hash>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct TransactionBlockDetails with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TransactionBlockDetails {
                                    hash: __field0,
                                    index: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Hash> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                                while let _serde::__private::Some(__key)
                                    = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("hash"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Hash>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("index"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some({
                                                #[doc(hidden)]
                                                struct __DeserializeWith<'de, Hash>
                                                where
                                                    Hash: _serde::Deserialize<'de>,
                                                {
                                                    value: u64,
                                                    phantom: _serde::__private::PhantomData<
                                                        TransactionBlockDetails<Hash>,
                                                    >,
                                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                                }
                                                impl<'de, Hash> _serde::Deserialize<'de>
                                                for __DeserializeWith<'de, Hash>
                                                where
                                                    Hash: _serde::Deserialize<'de>,
                                                {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::__private::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde::__private::Ok(__DeserializeWith {
                                                            value: unsigned_number_as_string::deserialize(
                                                                __deserializer,
                                                            )?,
                                                            phantom: _serde::__private::PhantomData,
                                                            lifetime: _serde::__private::PhantomData,
                                                        })
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de, Hash>,
                                                >(&mut __map) {
                                                    _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("hash")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::missing_field("index"),
                                        );
                                    }
                                };
                                _serde::__private::Ok(TransactionBlockDetails {
                                    hash: __field0,
                                    index: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["hash", "index"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "TransactionBlockDetails",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    TransactionBlockDetails<Hash>,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// Hex-serialized shim for `Vec<u8>`.
            pub struct Bytes(#[serde(with = "impl_serde::serialize")] pub Vec<u8>);
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Bytes {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Bytes {
                #[inline]
                fn eq(&self, other: &Bytes) -> bool {
                    self.0 == other.0
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Bytes {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Bytes {
                #[inline]
                fn clone(&self) -> Bytes {
                    Bytes(::core::clone::Clone::clone(&self.0))
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Bytes {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        _serde::Serializer::serialize_newtype_struct(
                            __serializer,
                            "Bytes",
                            {
                                #[doc(hidden)]
                                struct __SerializeWith<'__a> {
                                    values: (&'__a Vec<u8>,),
                                    phantom: _serde::__private::PhantomData<Bytes>,
                                }
                                impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                    fn serialize<__S>(
                                        &self,
                                        __s: __S,
                                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                    where
                                        __S: _serde::Serializer,
                                    {
                                        impl_serde::serialize::serialize(self.values.0, __s)
                                    }
                                }
                                &__SerializeWith {
                                    values: (&self.0,),
                                    phantom: _serde::__private::PhantomData::<Bytes>,
                                }
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Bytes {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Bytes>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Bytes;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "tuple struct Bytes",
                                )
                            }
                            #[inline]
                            fn visit_newtype_struct<__E>(
                                self,
                                __e: __E,
                            ) -> _serde::__private::Result<Self::Value, __E::Error>
                            where
                                __E: _serde::Deserializer<'de>,
                            {
                                let __field0: Vec<u8> = impl_serde::serialize::deserialize(
                                    __e,
                                )?;
                                _serde::__private::Ok(Bytes(__field0))
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match {
                                    #[doc(hidden)]
                                    struct __DeserializeWith<'de> {
                                        value: Vec<u8>,
                                        phantom: _serde::__private::PhantomData<Bytes>,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::Deserialize<'de>
                                    for __DeserializeWith<'de> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::__private::Ok(__DeserializeWith {
                                                value: impl_serde::serialize::deserialize(__deserializer)?,
                                                phantom: _serde::__private::PhantomData,
                                                lifetime: _serde::__private::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::__private::Option::map(
                                        _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de>,
                                        >(&mut __seq)?,
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"tuple struct Bytes with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Bytes(__field0))
                            }
                        }
                        _serde::Deserializer::deserialize_newtype_struct(
                            __deserializer,
                            "Bytes",
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Bytes>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            impl ::core::hash::Hash for Bytes {
                #[inline]
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Bytes {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Bytes,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Bytes {
                #[inline]
                fn cmp(&self, other: &Bytes) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.0, &other.0)
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Bytes {
                #[inline]
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Bytes",
                        &&self.0,
                    )
                }
            }
            impl std::ops::Deref for Bytes {
                type Target = [u8];
                fn deref(&self) -> &[u8] {
                    &self.0[..]
                }
            }
            impl From<Vec<u8>> for Bytes {
                fn from(s: Vec<u8>) -> Self {
                    Bytes(s)
                }
            }
            fn to_hex(bytes: impl AsRef<[u8]>) -> String {
                {
                    let res = ::alloc::fmt::format(
                        format_args!("0x{0}", hex::encode(bytes.as_ref())),
                    );
                    res
                }
            }
            /// Attempt to deserialize either a string or integer into an integer.
            /// See <https://github.com/paritytech/json-rpc-interface-spec/issues/83>
            pub(crate) mod unsigned_number_as_string {
                use serde::de::{Deserializer, Visitor};
                use std::fmt;
                /// Deserialize a number from a string or number.
                pub fn deserialize<'de, N: From<u64>, D>(
                    deserializer: D,
                ) -> Result<N, D::Error>
                where
                    D: Deserializer<'de>,
                {
                    deserializer.deserialize_any(NumberVisitor(std::marker::PhantomData))
                }
                struct NumberVisitor<N>(std::marker::PhantomData<N>);
                impl<'de, N: From<u64>> Visitor<'de> for NumberVisitor<N> {
                    type Value = N;
                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                        formatter
                            .write_str("an unsigned integer or a string containing one")
                    }
                    fn visit_str<E: serde::de::Error>(
                        self,
                        v: &str,
                    ) -> Result<Self::Value, E> {
                        let n: u64 = v.parse().map_err(serde::de::Error::custom)?;
                        Ok(n.into())
                    }
                    fn visit_u64<E: serde::de::Error>(
                        self,
                        v: u64,
                    ) -> Result<Self::Value, E> {
                        Ok(v.into())
                    }
                }
            }
            /// A temporary shim to decode "spec.apis" if it comes back as an array like:
            ///
            /// ```text
            /// [["0xABC", 1], ["0xCDE", 2]]
            /// ```
            ///
            /// The expected format (which this also supports deserializing from) is:
            ///
            /// ```text
            /// { "0xABC": 1, "0xCDE": 2 }
            /// ```
            ///
            /// We can delete this when the correct format is being returned.
            ///
            /// Adapted from <https://tikv.github.io/doc/serde_with/rust/hashmap_as_tuple_list>
            pub(crate) mod hashmap_as_tuple_list {
                use serde::de::{Deserialize, Deserializer, SeqAccess, Visitor};
                use std::collections::HashMap;
                use std::fmt;
                use std::hash::{BuildHasher, Hash};
                use std::marker::PhantomData;
                /// Deserialize a [`HashMap`] from a list of tuples or object
                pub fn deserialize<'de, K, V, BH, D>(
                    deserializer: D,
                ) -> Result<HashMap<K, V, BH>, D::Error>
                where
                    D: Deserializer<'de>,
                    K: Eq + Hash + Deserialize<'de>,
                    V: Deserialize<'de>,
                    BH: BuildHasher + Default,
                {
                    deserializer.deserialize_any(HashMapVisitor(PhantomData))
                }
                #[allow(clippy::type_complexity)]
                struct HashMapVisitor<K, V, BH>(PhantomData<fn() -> HashMap<K, V, BH>>);
                impl<'de, K, V, BH> Visitor<'de> for HashMapVisitor<K, V, BH>
                where
                    K: Deserialize<'de> + Eq + Hash,
                    V: Deserialize<'de>,
                    BH: BuildHasher + Default,
                {
                    type Value = HashMap<K, V, BH>;
                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                        formatter.write_str("a list of key-value pairs")
                    }
                    fn visit_map<A>(self, mut m: A) -> Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        let mut map = HashMap::with_capacity_and_hasher(
                            m.size_hint().unwrap_or(0),
                            BH::default(),
                        );
                        while let Some((key, value)) = m.next_entry()? {
                            map.insert(key, value);
                        }
                        Ok(map)
                    }
                    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
                    where
                        A: SeqAccess<'de>,
                    {
                        let mut map = HashMap::with_capacity_and_hasher(
                            seq.size_hint().unwrap_or(0),
                            BH::default(),
                        );
                        while let Some((key, value)) = seq.next_element()? {
                            map.insert(key, value);
                        }
                        Ok(map)
                    }
                }
            }
        }
        use self::rpc_methods::{
            FollowEvent, MethodResponse, RuntimeEvent, StorageQuery, StorageQueryType,
            StorageResultType,
        };
        use crate::backend::{
            rpc::RpcClient, Backend, BlockRef, BlockRefT, RuntimeVersion,
            StorageResponse, StreamOf, StreamOfResults, TransactionStatus,
        };
        use crate::config::BlockHash;
        use crate::error::{Error, RpcError};
        use crate::Config;
        use async_trait::async_trait;
        use follow_stream_driver::{FollowStreamDriver, FollowStreamDriverHandle};
        use futures::{Stream, StreamExt};
        use std::collections::HashMap;
        use std::sync::Arc;
        use std::task::Poll;
        use storage_items::StorageItems;
        pub use rpc_methods::UnstableRpcMethods;
        /// Configure and build an [`UnstableBackend`].
        pub struct UnstableBackendBuilder<T> {
            max_block_life: usize,
            _marker: std::marker::PhantomData<T>,
        }
        impl<T: Config> Default for UnstableBackendBuilder<T> {
            fn default() -> Self {
                Self::new()
            }
        }
        impl<T: Config> UnstableBackendBuilder<T> {
            /// Create a new [`UnstableBackendBuilder`].
            pub fn new() -> Self {
                Self {
                    max_block_life: usize::MAX,
                    _marker: std::marker::PhantomData,
                }
            }
            /// The age of a block is defined here as the difference between the current finalized block number
            /// and the block number of a given block. Once the difference equals or exceeds the number given
            /// here, the block is unpinned.
            ///
            /// By default, we will never automatically unpin blocks, but if the number of pinned blocks that we
            /// keep hold of exceeds the number that the server can tolerate, then a `stop` event is generated and
            /// we are forced to resubscribe, losing any pinned blocks.
            pub fn max_block_life(mut self, max_block_life: usize) -> Self {
                self.max_block_life = max_block_life;
                self
            }
            /// Given an [`RpcClient`] to use to make requests, this returns a tuple of an [`UnstableBackend`],
            /// which implements the [`Backend`] trait, and an [`UnstableBackendDriver`] which must be polled in
            /// order for the backend to make progress.
            pub fn build(
                self,
                client: RpcClient,
            ) -> (UnstableBackend<T>, UnstableBackendDriver<T>) {
                let rpc_methods = UnstableRpcMethods::new(client);
                let follow_stream = follow_stream::FollowStream::<
                    T::Hash,
                >::from_methods(rpc_methods.clone());
                let follow_stream_unpin = follow_stream_unpin::FollowStreamUnpin::<
                    T::Hash,
                >::from_methods(follow_stream, rpc_methods.clone(), self.max_block_life);
                let follow_stream_driver = FollowStreamDriver::new(follow_stream_unpin);
                let backend = UnstableBackend {
                    methods: rpc_methods,
                    follow_handle: follow_stream_driver.handle(),
                };
                let driver = UnstableBackendDriver {
                    driver: follow_stream_driver,
                };
                (backend, driver)
            }
        }
        /// Driver for the [`UnstableBackend`]. This must be polled in order for the
        /// backend to make progress.
        pub struct UnstableBackendDriver<T: Config> {
            driver: FollowStreamDriver<T::Hash>,
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug + Config> ::core::fmt::Debug
        for UnstableBackendDriver<T>
        where
            T::Hash: ::core::fmt::Debug,
        {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "UnstableBackendDriver",
                    "driver",
                    &&self.driver,
                )
            }
        }
        impl<T: Config> Stream for UnstableBackendDriver<T> {
            type Item = <FollowStreamDriver<T::Hash> as Stream>::Item;
            fn poll_next(
                mut self: std::pin::Pin<&mut Self>,
                cx: &mut std::task::Context<'_>,
            ) -> std::task::Poll<Option<Self::Item>> {
                self.driver.poll_next_unpin(cx)
            }
        }
        /// The unstable backend.
        pub struct UnstableBackend<T: Config> {
            methods: UnstableRpcMethods<T>,
            follow_handle: FollowStreamDriverHandle<T::Hash>,
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug + Config> ::core::fmt::Debug for UnstableBackend<T>
        where
            T::Hash: ::core::fmt::Debug,
        {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "UnstableBackend",
                    "methods",
                    &self.methods,
                    "follow_handle",
                    &&self.follow_handle,
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone + Config> ::core::clone::Clone
        for UnstableBackend<T>
        where
            T::Hash: ::core::clone::Clone,
        {
            #[inline]
            fn clone(&self) -> UnstableBackend<T> {
                UnstableBackend {
                    methods: ::core::clone::Clone::clone(&self.methods),
                    follow_handle: ::core::clone::Clone::clone(&self.follow_handle),
                }
            }
        }
        impl<T: Config> UnstableBackend<T> {
            /// Configure and construct an [`UnstableBackend`] and the associated [`UnstableBackendDriver`].
            pub fn builder() -> UnstableBackendBuilder<T> {
                UnstableBackendBuilder::new()
            }
            /// Stream block headers based on the provided filter fn
            async fn stream_headers<F, I>(
                &self,
                f: F,
            ) -> Result<StreamOfResults<(T::Header, BlockRef<T::Hash>)>, Error>
            where
                F: Fn(FollowEvent<follow_stream_unpin::BlockRef<T::Hash>>) -> I + Copy
                    + Send + 'static,
                I: IntoIterator<Item = follow_stream_unpin::BlockRef<T::Hash>> + Send
                    + 'static,
                <I as IntoIterator>::IntoIter: Send,
            {
                let sub_id = get_subscription_id(&self.follow_handle).await?;
                let sub_id = Arc::new(sub_id);
                let methods = self.methods.clone();
                let headers = self
                    .follow_handle
                    .subscribe()
                    .events()
                    .flat_map(move |ev| {
                        let sub_id = sub_id.clone();
                        let methods = methods.clone();
                        let block_refs = f(ev).into_iter();
                        futures::stream::iter(block_refs)
                            .filter_map(move |block_ref| {
                                let sub_id = sub_id.clone();
                                let methods = methods.clone();
                                async move {
                                    let res = methods
                                        .chainhead_unstable_header(&sub_id, block_ref.hash())
                                        .await
                                        .transpose()?;
                                    let header = match res {
                                        Ok(header) => header,
                                        Err(e) => return Some(Err(e)),
                                    };
                                    Some(Ok((header, block_ref.into())))
                                }
                            })
                    });
                Ok(StreamOf(Box::pin(headers)))
            }
        }
        impl<Hash: BlockHash + 'static> BlockRefT
        for follow_stream_unpin::BlockRef<Hash> {}
        impl<Hash: BlockHash + 'static> From<follow_stream_unpin::BlockRef<Hash>>
        for BlockRef<Hash> {
            fn from(b: follow_stream_unpin::BlockRef<Hash>) -> Self {
                BlockRef::new(b.hash(), b)
            }
        }
        impl<T: Config> super::sealed::Sealed for UnstableBackend<T> {}
        impl<T: Config + Send + Sync + 'static> Backend<T> for UnstableBackend<T> {
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn storage_fetch_values<'life0, 'async_trait>(
                &'life0 self,
                keys: Vec<Vec<u8>>,
                at: T::Hash,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<StreamOfResults<StorageResponse>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<StreamOfResults<StorageResponse>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let keys = keys;
                    let at = at;
                    let __ret: Result<StreamOfResults<StorageResponse>, Error> = {
                        let queries = keys
                            .iter()
                            .map(|key| StorageQuery {
                                key: &**key,
                                query_type: StorageQueryType::Value,
                            });
                        let storage_items = StorageItems::from_methods(
                                queries,
                                at,
                                &__self.follow_handle,
                                __self.methods.clone(),
                            )
                            .await?;
                        let storage_result_stream = storage_items
                            .filter_map(|val| async move {
                                let val = match val {
                                    Ok(val) => val,
                                    Err(e) => return Some(Err(e)),
                                };
                                let StorageResultType::Value(result) = val.result else {
                                return None;
                            };
                                Some(
                                    Ok(StorageResponse {
                                        key: val.key.0,
                                        value: result.0,
                                    }),
                                )
                            });
                        Ok(StreamOf(Box::pin(storage_result_stream)))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn storage_fetch_descendant_keys<'life0, 'async_trait>(
                &'life0 self,
                key: Vec<u8>,
                at: T::Hash,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<StreamOfResults<Vec<u8>>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<StreamOfResults<Vec<u8>>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let key = key;
                    let at = at;
                    let __ret: Result<StreamOfResults<Vec<u8>>, Error> = {
                        let query = StorageQuery {
                            key: &*key,
                            query_type: StorageQueryType::DescendantsHashes,
                        };
                        let storage_items = StorageItems::from_methods(
                                std::iter::once(query),
                                at,
                                &__self.follow_handle,
                                __self.methods.clone(),
                            )
                            .await?;
                        let storage_result_stream = storage_items
                            .map(|val| val.map(|v| v.key.0));
                        Ok(StreamOf(Box::pin(storage_result_stream)))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn storage_fetch_descendant_values<'life0, 'async_trait>(
                &'life0 self,
                key: Vec<u8>,
                at: T::Hash,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<StreamOfResults<StorageResponse>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<StreamOfResults<StorageResponse>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let key = key;
                    let at = at;
                    let __ret: Result<StreamOfResults<StorageResponse>, Error> = {
                        let query = StorageQuery {
                            key: &*key,
                            query_type: StorageQueryType::DescendantsValues,
                        };
                        let storage_items = StorageItems::from_methods(
                                std::iter::once(query),
                                at,
                                &__self.follow_handle,
                                __self.methods.clone(),
                            )
                            .await?;
                        let storage_result_stream = storage_items
                            .filter_map(|val| async move {
                                let val = match val {
                                    Ok(val) => val,
                                    Err(e) => return Some(Err(e)),
                                };
                                let StorageResultType::Value(result) = val.result else {
                                return None;
                            };
                                Some(
                                    Ok(StorageResponse {
                                        key: val.key.0,
                                        value: result.0,
                                    }),
                                )
                            });
                        Ok(StreamOf(Box::pin(storage_result_stream)))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn genesis_hash<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<T::Hash, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<T::Hash, Error>> {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<T::Hash, Error> = {
                        __self.methods.chainspec_v1_genesis_hash().await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn block_header<'life0, 'async_trait>(
                &'life0 self,
                at: T::Hash,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<Option<T::Header>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<Option<T::Header>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let at = at;
                    let __ret: Result<Option<T::Header>, Error> = {
                        let sub_id = get_subscription_id(&__self.follow_handle).await?;
                        __self.methods.chainhead_unstable_header(&sub_id, at).await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn block_body<'life0, 'async_trait>(
                &'life0 self,
                at: T::Hash,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<Option<Vec<Vec<u8>>>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<Option<Vec<Vec<u8>>>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let at = at;
                    let __ret: Result<Option<Vec<Vec<u8>>>, Error> = {
                        let sub_id = get_subscription_id(&__self.follow_handle).await?;
                        let follow_events = __self.follow_handle.subscribe().events();
                        let status = __self
                            .methods
                            .chainhead_unstable_body(&sub_id, at)
                            .await?;
                        let operation_id = match status {
                            MethodResponse::LimitReached => {
                                return Err(
                                    RpcError::request_rejected("limit reached").into(),
                                );
                            }
                            MethodResponse::Started(s) => s.operation_id,
                        };
                        let mut exts_stream = follow_events
                            .filter_map(|ev| {
                                let FollowEvent::OperationBodyDone(body) = ev else {
                                return std::future::ready(None);
                            };
                                if body.operation_id != operation_id {
                                    return std::future::ready(None);
                                }
                                let exts: Vec<_> = body
                                    .value
                                    .into_iter()
                                    .map(|ext| ext.0)
                                    .collect();
                                std::future::ready(Some(exts))
                            });
                        Ok(exts_stream.next().await)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn latest_finalized_block_ref<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<BlockRef<T::Hash>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<BlockRef<T::Hash>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<BlockRef<T::Hash>, Error> = {
                        let next_ref: Option<BlockRef<T::Hash>> = __self
                            .follow_handle
                            .subscribe()
                            .events()
                            .filter_map(|ev| {
                                let out = match ev {
                                    FollowEvent::Initialized(init) => {
                                        Some(init.finalized_block_hash.into())
                                    }
                                    _ => None,
                                };
                                std::future::ready(out)
                            })
                            .next()
                            .await;
                        next_ref.ok_or_else(|| RpcError::SubscriptionDropped.into())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn current_runtime_version<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<RuntimeVersion, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<RuntimeVersion, Error>> {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<RuntimeVersion, Error> = {
                        let runtime_version = __self
                            .stream_runtime_version()
                            .await?
                            .next()
                            .await;
                        match runtime_version {
                            None => Err(Error::Rpc(RpcError::SubscriptionDropped)),
                            Some(Err(e)) => Err(e),
                            Some(Ok(version)) => Ok(version),
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn stream_runtime_version<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<StreamOfResults<RuntimeVersion>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<StreamOfResults<RuntimeVersion>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<StreamOfResults<RuntimeVersion>, Error> = {
                        let mut runtimes = HashMap::new();
                        let runtime_stream = __self
                            .follow_handle
                            .subscribe()
                            .events()
                            .filter_map(move |ev| {
                                let output = match ev {
                                    FollowEvent::Initialized(ev) => {
                                        runtimes.remove(&ev.finalized_block_hash.hash());
                                        ev.finalized_block_runtime
                                    }
                                    FollowEvent::NewBlock(ev) => {
                                        if let Some(runtime) = ev.new_runtime {
                                            runtimes.insert(ev.block_hash.hash(), runtime);
                                        }
                                        None
                                    }
                                    FollowEvent::Finalized(ev) => {
                                        let next_runtime = {
                                            let mut it = ev
                                                .finalized_block_hashes
                                                .iter()
                                                .rev()
                                                .filter_map(|h| runtimes.get(&h.hash()).cloned())
                                                .peekable();
                                            let next = it.next();
                                            if it.peek().is_some() {
                                                {
                                                    use ::tracing::__macro_support::Callsite as _;
                                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                        static META: ::tracing::Metadata<'static> = {
                                                            ::tracing_core::metadata::Metadata::new(
                                                                "event subxt/src/backend/unstable/mod.rs:377",
                                                                "subxt",
                                                                ::tracing::Level::WARN,
                                                                ::core::option::Option::Some(
                                                                    "subxt/src/backend/unstable/mod.rs",
                                                                ),
                                                                ::core::option::Option::Some(377u32),
                                                                ::core::option::Option::Some("subxt::backend::unstable"),
                                                                ::tracing_core::field::FieldSet::new(
                                                                    &["message"],
                                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                                ),
                                                                ::tracing::metadata::Kind::EVENT,
                                                            )
                                                        };
                                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                                    };
                                                    let enabled = ::tracing::Level::WARN
                                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                        && ::tracing::Level::WARN
                                                            <= ::tracing::level_filters::LevelFilter::current()
                                                        && {
                                                            let interest = __CALLSITE.interest();
                                                            !interest.is_never()
                                                                && ::tracing::__macro_support::__is_enabled(
                                                                    __CALLSITE.metadata(),
                                                                    interest,
                                                                )
                                                        };
                                                    if enabled {
                                                        (|value_set: ::tracing::field::ValueSet| {
                                                            let meta = __CALLSITE.metadata();
                                                            ::tracing::Event::dispatch(meta, &value_set);
                                                        })({
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                                            __CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &::core::iter::Iterator::next(&mut iter)
                                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                                            ::core::option::Option::Some(
                                                                                &format_args!(
                                                                                    "Several runtime upgrades in the finalized blocks but only the latest runtime upgrade is returned"
                                                                                ) as &dyn Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        });
                                                    } else {
                                                    }
                                                };
                                            }
                                            next
                                        };
                                        for block in ev
                                            .finalized_block_hashes
                                            .iter()
                                            .chain(ev.pruned_block_hashes.iter())
                                        {
                                            runtimes.remove(&block.hash());
                                        }
                                        next_runtime
                                    }
                                    _ => None,
                                };
                                let runtime_event = match output {
                                    None => return std::future::ready(None),
                                    Some(ev) => ev,
                                };
                                let runtime_details = match runtime_event {
                                    RuntimeEvent::Invalid(err) => {
                                        return std::future::ready(
                                            Some(Err(Error::Other(err.error))),
                                        );
                                    }
                                    RuntimeEvent::Valid(ev) => ev,
                                };
                                std::future::ready(
                                    Some(
                                        Ok(RuntimeVersion {
                                            spec_version: runtime_details.spec.spec_version,
                                            transaction_version: runtime_details
                                                .spec
                                                .transaction_version,
                                        }),
                                    ),
                                )
                            });
                        Ok(StreamOf(Box::pin(runtime_stream)))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn stream_all_block_headers<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<
                            StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                            Error,
                        >,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<
                                StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                                Error,
                            >,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<
                        StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                        Error,
                    > = {
                        __self
                            .stream_headers(|ev| match ev {
                                FollowEvent::Initialized(ev) => {
                                    Some(ev.finalized_block_hash)
                                }
                                FollowEvent::NewBlock(ev) => Some(ev.block_hash),
                                _ => None,
                            })
                            .await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn stream_best_block_headers<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<
                            StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                            Error,
                        >,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<
                                StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                                Error,
                            >,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<
                        StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                        Error,
                    > = {
                        __self
                            .stream_headers(|ev| match ev {
                                FollowEvent::Initialized(ev) => {
                                    Some(ev.finalized_block_hash)
                                }
                                FollowEvent::BestBlockChanged(ev) => {
                                    Some(ev.best_block_hash)
                                }
                                _ => None,
                            })
                            .await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn stream_finalized_block_headers<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<
                            StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                            Error,
                        >,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<
                                StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                                Error,
                            >,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<
                        StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                        Error,
                    > = {
                        __self
                            .stream_headers(|ev| match ev {
                                FollowEvent::Initialized(ev) => {
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([ev.finalized_block_hash]),
                                    )
                                }
                                FollowEvent::Finalized(ev) => ev.finalized_block_hashes,
                                _ => ::alloc::vec::Vec::new(),
                            })
                            .await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn submit_transaction<'life0, 'life1, 'async_trait>(
                &'life0 self,
                extrinsic: &'life1 [u8],
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<
                            StreamOfResults<TransactionStatus<T::Hash>>,
                            Error,
                        >,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<StreamOfResults<TransactionStatus<T::Hash>>, Error>,
                        > {
                        return __ret;
                    }
                    let __self = self;
                    let __ret: Result<
                        StreamOfResults<TransactionStatus<T::Hash>>,
                        Error,
                    > = {
                        enum SeenBlockMarker {
                            New,
                            Finalized,
                        }
                        let mut seen_blocks_sub = __self
                            .follow_handle
                            .subscribe()
                            .events();
                        let mut tx_progress = __self
                            .methods
                            .transaction_unstable_submit_and_watch(extrinsic)
                            .await?;
                        let mut seen_blocks = HashMap::new();
                        let mut done = false;
                        let mut finalized_hash: Option<T::Hash> = None;
                        let start_instant = instant::Instant::now();
                        let err_other = |s: &str| Some(Err(Error::Other(s.into())));
                        let tx_stream = futures::stream::poll_fn(move |cx| {
                            loop {
                                if done {
                                    return Poll::Ready(None);
                                }
                                if start_instant.elapsed().as_secs() > 240 {
                                    return Poll::Ready(
                                        err_other(
                                            "Timeout waiting for the transaction to be finalized",
                                        ),
                                    );
                                }
                                let follow_ev_poll = match seen_blocks_sub
                                    .poll_next_unpin(cx)
                                {
                                    Poll::Ready(None) => {
                                        return Poll::Ready(
                                            err_other("chainHead_follow stream ended unexpectedly"),
                                        );
                                    }
                                    Poll::Ready(Some(follow_ev)) => Poll::Ready(follow_ev),
                                    Poll::Pending => Poll::Pending,
                                };
                                let follow_ev_is_pending = follow_ev_poll.is_pending();
                                if let Poll::Ready(follow_ev) = follow_ev_poll {
                                    match follow_ev {
                                        FollowEvent::NewBlock(ev) => {
                                            if finalized_hash.is_none() {
                                                seen_blocks
                                                    .insert(
                                                        ev.block_hash.hash(),
                                                        (SeenBlockMarker::New, ev.block_hash),
                                                    );
                                            }
                                        }
                                        FollowEvent::Finalized(ev) => {
                                            for block_ref in ev.finalized_block_hashes {
                                                seen_blocks
                                                    .insert(
                                                        block_ref.hash(),
                                                        (SeenBlockMarker::Finalized, block_ref),
                                                    );
                                            }
                                        }
                                        FollowEvent::Stop => {
                                            return Poll::Ready(
                                                err_other(
                                                    "chainHead_follow emitted 'stop' event during transaction submission",
                                                ),
                                            );
                                        }
                                        _ => {}
                                    }
                                    continue;
                                }
                                if let Some(hash) = &finalized_hash {
                                    if let Some((SeenBlockMarker::Finalized, block_ref))
                                        = seen_blocks.remove(hash)
                                    {
                                        done = true;
                                        let ev = TransactionStatus::InFinalizedBlock {
                                            hash: block_ref.into(),
                                        };
                                        return Poll::Ready(Some(Ok(ev)));
                                    } else {
                                        seen_blocks.clear();
                                        if follow_ev_is_pending {
                                            return Poll::Pending;
                                        } else {
                                            continue;
                                        }
                                    }
                                }
                                let tx_progress_ev = match tx_progress.poll_next_unpin(cx) {
                                    Poll::Pending => return Poll::Pending,
                                    Poll::Ready(None) => {
                                        return Poll::Ready(
                                            err_other(
                                                "No more transaction progress events, but we haven't seen a Finalized one yet",
                                            ),
                                        );
                                    }
                                    Poll::Ready(Some(Err(e))) => {
                                        return Poll::Ready(Some(Err(e)));
                                    }
                                    Poll::Ready(Some(Ok(ev))) => ev,
                                };
                                let tx_progress_ev = match tx_progress_ev {
                                    rpc_methods::TransactionStatus::Finalized { block } => {
                                        finalized_hash = Some(block.hash);
                                        continue;
                                    }
                                    rpc_methods::TransactionStatus::BestChainBlockIncluded {
                                        block: Some(block),
                                    } => {
                                        let block_ref = match seen_blocks.get(&block.hash) {
                                            Some((_, block_ref)) => block_ref.clone().into(),
                                            None => BlockRef::from_hash(block.hash),
                                        };
                                        TransactionStatus::InBestBlock {
                                            hash: block_ref,
                                        }
                                    }
                                    rpc_methods::TransactionStatus::BestChainBlockIncluded {
                                        block: None,
                                    } => TransactionStatus::NoLongerInBestBlock,
                                    rpc_methods::TransactionStatus::Broadcasted {
                                        num_peers,
                                    } => {
                                        TransactionStatus::Broadcasted {
                                            num_peers,
                                        }
                                    }
                                    rpc_methods::TransactionStatus::Dropped { error, .. } => {
                                        TransactionStatus::Dropped {
                                            message: error,
                                        }
                                    }
                                    rpc_methods::TransactionStatus::Error { error } => {
                                        TransactionStatus::Dropped {
                                            message: error,
                                        }
                                    }
                                    rpc_methods::TransactionStatus::Invalid { error } => {
                                        TransactionStatus::Invalid {
                                            message: error,
                                        }
                                    }
                                    rpc_methods::TransactionStatus::Validated => {
                                        TransactionStatus::Validated
                                    }
                                };
                                return Poll::Ready(Some(Ok(tx_progress_ev)));
                            }
                        });
                        Ok(StreamOf(Box::pin(tx_stream)))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn call<'life0, 'life1, 'life2, 'async_trait>(
                &'life0 self,
                method: &'life1 str,
                call_parameters: Option<&'life2 [u8]>,
                at: T::Hash,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<Vec<u8>, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<Vec<u8>, Error>> {
                        return __ret;
                    }
                    let __self = self;
                    let call_parameters = call_parameters;
                    let at = at;
                    let __ret: Result<Vec<u8>, Error> = {
                        let sub_id = get_subscription_id(&__self.follow_handle).await?;
                        let follow_events = __self.follow_handle.subscribe().events();
                        let call_parameters = call_parameters.unwrap_or(&[]);
                        let status = __self
                            .methods
                            .chainhead_unstable_call(
                                &sub_id,
                                at,
                                method,
                                call_parameters,
                            )
                            .await?;
                        let operation_id = match status {
                            MethodResponse::LimitReached => {
                                return Err(
                                    RpcError::request_rejected("limit reached").into(),
                                );
                            }
                            MethodResponse::Started(s) => s.operation_id,
                        };
                        let mut call_data_stream = follow_events
                            .filter_map(|ev| {
                                let FollowEvent::OperationCallDone(body) = ev else {
                                return std::future::ready(None);
                            };
                                if body.operation_id != operation_id {
                                    return std::future::ready(None);
                                }
                                std::future::ready(Some(body.output.0))
                            });
                        call_data_stream
                            .next()
                            .await
                            .ok_or_else(|| RpcError::SubscriptionDropped.into())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
        /// A helper to obtain a subscription ID.
        async fn get_subscription_id<Hash: BlockHash>(
            follow_handle: &FollowStreamDriverHandle<Hash>,
        ) -> Result<String, Error> {
            let Some(sub_id) = follow_handle.subscribe().subscription_id().await else {
            return Err(RpcError::SubscriptionDropped.into());
        };
            Ok(sub_id)
        }
    }
    use crate::error::Error;
    use crate::metadata::Metadata;
    use crate::Config;
    use async_trait::async_trait;
    use codec::{Decode, Encode};
    use futures::{Stream, StreamExt};
    use std::pin::Pin;
    use std::sync::Arc;
    /// Prevent the backend trait being implemented externally.
    #[doc(hidden)]
    pub(crate) mod sealed {
        pub trait Sealed {}
    }
    /// This trait exposes the interface that Subxt will use to communicate with
    /// a backend. Its goal is to be as minimal as possible.
    pub trait Backend<T: Config>: sealed::Sealed + Send + Sync + 'static {
        /// Fetch values from storage.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn storage_fetch_values<'life0, 'async_trait>(
            &'life0 self,
            keys: Vec<Vec<u8>>,
            at: T::Hash,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<StreamOfResults<StorageResponse>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Fetch keys underneath the given key from storage.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn storage_fetch_descendant_keys<'life0, 'async_trait>(
            &'life0 self,
            key: Vec<u8>,
            at: T::Hash,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<StreamOfResults<Vec<u8>>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Fetch values underneath the given key from storage.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn storage_fetch_descendant_values<'life0, 'async_trait>(
            &'life0 self,
            key: Vec<u8>,
            at: T::Hash,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<StreamOfResults<StorageResponse>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Fetch the genesis hash
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn genesis_hash<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<T::Hash, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Get a block header
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn block_header<'life0, 'async_trait>(
            &'life0 self,
            at: T::Hash,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Option<T::Header>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Return the extrinsics found in the block. Each extrinsic is represented
        /// by a vector of bytes which has _not_ been SCALE decoded (in other words, the
        /// first bytes in the vector will decode to the compact encoded length of the extrinsic)
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn block_body<'life0, 'async_trait>(
            &'life0 self,
            at: T::Hash,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Option<Vec<Vec<u8>>>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Get the most recent finalized block hash.
        /// Note: needed only in blocks client for finalized block stream; can prolly be removed.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn latest_finalized_block_ref<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<BlockRef<T::Hash>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Get information about the current runtime.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn current_runtime_version<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<RuntimeVersion, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// A stream of all new runtime versions as they occur.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn stream_runtime_version<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<StreamOfResults<RuntimeVersion>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// A stream of all new block headers as they arrive.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn stream_all_block_headers<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<
                        StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                        Error,
                    >,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// A stream of best block headers.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn stream_best_block_headers<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<
                        StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                        Error,
                    >,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// A stream of finalized block headers.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn stream_finalized_block_headers<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<
                        StreamOfResults<(T::Header, BlockRef<T::Hash>)>,
                        Error,
                    >,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Submit a transaction. This will return a stream of events about it.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn submit_transaction<'life0, 'life1, 'async_trait>(
            &'life0 self,
            bytes: &'life1 [u8],
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<StreamOfResults<TransactionStatus<T::Hash>>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
        /// Make a call to some runtime API.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn call<'life0, 'life1, 'life2, 'async_trait>(
            &'life0 self,
            method: &'life1 str,
            call_parameters: Option<&'life2 [u8]>,
            at: T::Hash,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Vec<u8>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            'life2: 'async_trait,
            Self: 'async_trait;
    }
    /// helpeful utility methods derived from those provided on [`Backend`]
    pub trait BackendExt<T: Config>: Backend<T> {
        /// Fetch a single value from storage.
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::diverging_sub_expression,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn storage_fetch_value<'life0, 'async_trait>(
            &'life0 self,
            key: Vec<u8>,
            at: T::Hash,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Option<Vec<u8>>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: ::core::marker::Sync + 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<Option<Vec<u8>>, Error>> {
                    return __ret;
                }
                let __self = self;
                let key = key;
                let at = at;
                let __ret: Result<Option<Vec<u8>>, Error> = {
                    __self
                        .storage_fetch_values(
                            <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([key]),
                            ),
                            at,
                        )
                        .await?
                        .next()
                        .await
                        .transpose()
                        .map(|o| o.map(|s| s.value))
                };
                #[allow(unreachable_code)] __ret
            })
        }
        /// The same as a [`Backend::call()`], but it will also attempt to decode the
        /// result into the given type, which is a fairly common operation.
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::diverging_sub_expression,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn call_decoding<'life0, 'life1, 'life2, 'async_trait, D>(
            &'life0 self,
            method: &'life1 str,
            call_parameters: Option<&'life2 [u8]>,
            at: T::Hash,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<D, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            D: 'async_trait + codec::Decode,
            'life0: 'async_trait,
            'life1: 'async_trait,
            'life2: 'async_trait,
            Self: ::core::marker::Sync + 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<D, Error>> {
                    return __ret;
                }
                let __self = self;
                let call_parameters = call_parameters;
                let at = at;
                let __ret: Result<D, Error> = {
                    let bytes = __self.call(method, call_parameters, at).await?;
                    let res = D::decode(&mut &*bytes)?;
                    Ok(res)
                };
                #[allow(unreachable_code)] __ret
            })
        }
        /// Return the metadata at some version.
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::diverging_sub_expression,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn metadata_at_version<'life0, 'async_trait>(
            &'life0 self,
            version: u32,
            at: T::Hash,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Metadata, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: ::core::marker::Sync + 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<Metadata, Error>> {
                    return __ret;
                }
                let __self = self;
                let version = version;
                let at = at;
                let __ret: Result<Metadata, Error> = {
                    let param = version.encode();
                    let opaque: Option<frame_metadata::OpaqueMetadata> = __self
                        .call_decoding("Metadata_metadata_at_version", Some(&param), at)
                        .await?;
                    let Some(opaque) = opaque else {
                    return Err(Error::Other("Metadata version not found".into()));
                };
                    let metadata: Metadata = Decode::decode(&mut &opaque.0[..])?;
                    Ok(metadata)
                };
                #[allow(unreachable_code)] __ret
            })
        }
        /// Return V14 metadata from the legacy `Metadata_metadata` call.
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::diverging_sub_expression,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn legacy_metadata<'life0, 'async_trait>(
            &'life0 self,
            at: T::Hash,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Metadata, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: ::core::marker::Sync + 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<Metadata, Error>> {
                    return __ret;
                }
                let __self = self;
                let at = at;
                let __ret: Result<Metadata, Error> = {
                    let opaque: frame_metadata::OpaqueMetadata = __self
                        .call_decoding("Metadata_metadata", None, at)
                        .await?;
                    let metadata: Metadata = Decode::decode(&mut &opaque.0[..])?;
                    Ok(metadata)
                };
                #[allow(unreachable_code)] __ret
            })
        }
    }
    impl<B: Backend<T> + ?Sized, T: Config> BackendExt<T> for B {}
    /// An opaque struct which, while alive, indicates that some references to a block
    /// still exist. This gives the backend the opportunity to keep the corresponding block
    /// details around for a while if it likes and is able to. No guarantees can be made about
    /// how long the corresponding details might be available for, but if no references to a block
    /// exist, then the backend is free to discard any details for it.
    pub struct BlockRef<H> {
        hash: H,
        _pointer: Option<Arc<dyn BlockRefT>>,
    }
    #[automatically_derived]
    impl<H: ::core::clone::Clone> ::core::clone::Clone for BlockRef<H> {
        #[inline]
        fn clone(&self) -> BlockRef<H> {
            BlockRef {
                hash: ::core::clone::Clone::clone(&self.hash),
                _pointer: ::core::clone::Clone::clone(&self._pointer),
            }
        }
    }
    impl<H> From<H> for BlockRef<H> {
        fn from(value: H) -> Self {
            BlockRef::from_hash(value)
        }
    }
    impl<H: PartialEq> PartialEq for BlockRef<H> {
        fn eq(&self, other: &Self) -> bool {
            self.hash == other.hash
        }
    }
    impl<H: Eq> Eq for BlockRef<H> {}
    impl<H: PartialOrd> PartialOrd for BlockRef<H> {
        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
            self.hash.partial_cmp(&other.hash)
        }
    }
    impl<H: Ord> Ord for BlockRef<H> {
        fn cmp(&self, other: &Self) -> std::cmp::Ordering {
            self.hash.cmp(&other.hash)
        }
    }
    impl<H: std::fmt::Debug> std::fmt::Debug for BlockRef<H> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.debug_tuple("BlockRef").field(&self.hash).finish()
        }
    }
    impl<H: std::hash::Hash> std::hash::Hash for BlockRef<H> {
        fn hash<Hasher: std::hash::Hasher>(&self, state: &mut Hasher) {
            self.hash.hash(state);
        }
    }
    impl<H> BlockRef<H> {
        /// A [`BlockRef`] that doesn't reference a given block, but does have an associated hash.
        /// This is used in the legacy backend, which has no notion of pinning blocks.
        pub fn from_hash(hash: H) -> Self {
            Self { hash, _pointer: None }
        }
        /// Construct a [`BlockRef`] from an instance of the underlying trait. It's expected
        /// that the [`Backend`] implementation will call this if it wants to track which blocks
        /// are potentially in use.
        pub fn new<P: BlockRefT>(hash: H, inner: P) -> Self {
            Self {
                hash,
                _pointer: Some(Arc::new(inner)),
            }
        }
        /// Return the hash of the referenced block.
        pub fn hash(&self) -> H
        where
            H: Copy,
        {
            self.hash
        }
    }
    /// A trait that a [`Backend`] can implement to know when some block
    /// can be unpinned: when this is dropped, there are no remaining references
    /// to the block that it's associated with.
    pub trait BlockRefT: Send + Sync + 'static {}
    /// A stream of some item.
    pub struct StreamOf<T>(Pin<Box<dyn Stream<Item = T> + Send + 'static>>);
    impl<T> Stream for StreamOf<T> {
        type Item = T;
        fn poll_next(
            mut self: std::pin::Pin<&mut Self>,
            cx: &mut std::task::Context<'_>,
        ) -> std::task::Poll<Option<Self::Item>> {
            self.0.poll_next_unpin(cx)
        }
    }
    impl<T> std::fmt::Debug for StreamOf<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.debug_tuple("StreamOf").field(&"<stream>").finish()
        }
    }
    impl<T> StreamOf<T> {
        /// Construct a new stream.
        pub fn new(inner: Pin<Box<dyn Stream<Item = T> + Send + 'static>>) -> Self {
            StreamOf(inner)
        }
        /// Returns the next item in the stream. This is just a wrapper around
        /// [`StreamExt::next()`] so that you can avoid the extra import.
        pub async fn next(&mut self) -> Option<T> {
            StreamExt::next(self).await
        }
    }
    /// A stream of [`Result<Item, Error>`].
    pub type StreamOfResults<T> = StreamOf<Result<T, Error>>;
    /// Runtime version information needed to submit transactions.
    pub struct RuntimeVersion {
        /// Version of the runtime specification. A full-node will not attempt to use its native
        /// runtime in substitute for the on-chain Wasm runtime unless all of `spec_name`,
        /// `spec_version` and `authoring_version` are the same between Wasm and native.
        pub spec_version: u32,
        /// All existing dispatches are fully compatible when this number doesn't change. If this
        /// number changes, then `spec_version` must change, also.
        ///
        /// This number must change when an existing dispatchable (module ID, dispatch ID) is changed,
        /// either through an alteration in its user-level semantics, a parameter
        /// added/removed/changed, a dispatchable being removed, a module being removed, or a
        /// dispatchable/module changing its index.
        ///
        /// It need *not* change when a new module is added or when a dispatchable is added.
        pub transaction_version: u32,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RuntimeVersion {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "RuntimeVersion",
                "spec_version",
                &self.spec_version,
                "transaction_version",
                &&self.transaction_version,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RuntimeVersion {
        #[inline]
        fn clone(&self) -> RuntimeVersion {
            RuntimeVersion {
                spec_version: ::core::clone::Clone::clone(&self.spec_version),
                transaction_version: ::core::clone::Clone::clone(
                    &self.transaction_version,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RuntimeVersion {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RuntimeVersion {
        #[inline]
        fn eq(&self, other: &RuntimeVersion) -> bool {
            self.spec_version == other.spec_version
                && self.transaction_version == other.transaction_version
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for RuntimeVersion {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    /// The status of the transaction.
    ///
    /// If the status is [`TransactionStatus::InFinalizedBlock`], [`TransactionStatus::Error`],
    /// [`TransactionStatus::Invalid`] or [`TransactionStatus::Dropped`], then no future
    /// events will be emitted.
    pub enum TransactionStatus<Hash> {
        /// Transaction is part of the future queue.
        Validated,
        /// The transaction has been broadcast to other nodes.
        Broadcasted {
            /// Number of peers it's been broadcast to.
            num_peers: u32,
        },
        /// Transaction is no longer in a best block.
        NoLongerInBestBlock,
        /// Transaction has been included in block with given hash.
        InBestBlock {
            /// Block hash the transaction is in.
            hash: BlockRef<Hash>,
        },
        /// Transaction has been finalized by a finality-gadget, e.g GRANDPA
        InFinalizedBlock {
            /// Block hash the transaction is in.
            hash: BlockRef<Hash>,
        },
        /// Something went wrong in the node.
        Error {
            /// Human readable message; what went wrong.
            message: String,
        },
        /// Transaction is invalid (bad nonce, signature etc).
        Invalid {
            /// Human readable message; why was it invalid.
            message: String,
        },
        /// The transaction was dropped.
        Dropped {
            /// Human readable message; why was it dropped.
            message: String,
        },
    }
    #[automatically_derived]
    impl<Hash: ::core::fmt::Debug> ::core::fmt::Debug for TransactionStatus<Hash> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TransactionStatus::Validated => {
                    ::core::fmt::Formatter::write_str(f, "Validated")
                }
                TransactionStatus::Broadcasted { num_peers: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Broadcasted",
                        "num_peers",
                        &__self_0,
                    )
                }
                TransactionStatus::NoLongerInBestBlock => {
                    ::core::fmt::Formatter::write_str(f, "NoLongerInBestBlock")
                }
                TransactionStatus::InBestBlock { hash: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "InBestBlock",
                        "hash",
                        &__self_0,
                    )
                }
                TransactionStatus::InFinalizedBlock { hash: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "InFinalizedBlock",
                        "hash",
                        &__self_0,
                    )
                }
                TransactionStatus::Error { message: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Error",
                        "message",
                        &__self_0,
                    )
                }
                TransactionStatus::Invalid { message: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Invalid",
                        "message",
                        &__self_0,
                    )
                }
                TransactionStatus::Dropped { message: __self_0 } => {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Dropped",
                        "message",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<Hash: ::core::clone::Clone> ::core::clone::Clone for TransactionStatus<Hash> {
        #[inline]
        fn clone(&self) -> TransactionStatus<Hash> {
            match self {
                TransactionStatus::Validated => TransactionStatus::Validated,
                TransactionStatus::Broadcasted { num_peers: __self_0 } => {
                    TransactionStatus::Broadcasted {
                        num_peers: ::core::clone::Clone::clone(__self_0),
                    }
                }
                TransactionStatus::NoLongerInBestBlock => {
                    TransactionStatus::NoLongerInBestBlock
                }
                TransactionStatus::InBestBlock { hash: __self_0 } => {
                    TransactionStatus::InBestBlock {
                        hash: ::core::clone::Clone::clone(__self_0),
                    }
                }
                TransactionStatus::InFinalizedBlock { hash: __self_0 } => {
                    TransactionStatus::InFinalizedBlock {
                        hash: ::core::clone::Clone::clone(__self_0),
                    }
                }
                TransactionStatus::Error { message: __self_0 } => {
                    TransactionStatus::Error {
                        message: ::core::clone::Clone::clone(__self_0),
                    }
                }
                TransactionStatus::Invalid { message: __self_0 } => {
                    TransactionStatus::Invalid {
                        message: ::core::clone::Clone::clone(__self_0),
                    }
                }
                TransactionStatus::Dropped { message: __self_0 } => {
                    TransactionStatus::Dropped {
                        message: ::core::clone::Clone::clone(__self_0),
                    }
                }
            }
        }
    }
    #[automatically_derived]
    impl<Hash> ::core::marker::StructuralPartialEq for TransactionStatus<Hash> {}
    #[automatically_derived]
    impl<Hash: ::core::cmp::PartialEq> ::core::cmp::PartialEq
    for TransactionStatus<Hash> {
        #[inline]
        fn eq(&self, other: &TransactionStatus<Hash>) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        TransactionStatus::Broadcasted { num_peers: __self_0 },
                        TransactionStatus::Broadcasted { num_peers: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        TransactionStatus::InBestBlock { hash: __self_0 },
                        TransactionStatus::InBestBlock { hash: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        TransactionStatus::InFinalizedBlock { hash: __self_0 },
                        TransactionStatus::InFinalizedBlock { hash: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        TransactionStatus::Error { message: __self_0 },
                        TransactionStatus::Error { message: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        TransactionStatus::Invalid { message: __self_0 },
                        TransactionStatus::Invalid { message: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    (
                        TransactionStatus::Dropped { message: __self_0 },
                        TransactionStatus::Dropped { message: __arg1_0 },
                    ) => *__self_0 == *__arg1_0,
                    _ => true,
                }
        }
    }
    #[automatically_derived]
    impl<Hash: ::core::cmp::Eq> ::core::cmp::Eq for TransactionStatus<Hash> {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
            let _: ::core::cmp::AssertParamIsEq<BlockRef<Hash>>;
            let _: ::core::cmp::AssertParamIsEq<BlockRef<Hash>>;
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    /// A response from calls like [`Backend::storage_fetch_values`] or
    /// [`Backend::storage_fetch_descendant_values`].
    pub struct StorageResponse {
        /// The key.
        pub key: Vec<u8>,
        /// The associated value.
        pub value: Vec<u8>,
    }
}
pub mod blocks {
    //! This module exposes the necessary functionality for working with events.
    mod block_types {
        use crate::{
            backend::BlockRef,
            blocks::{extrinsic_types::ExtrinsicPartTypeIds, Extrinsics},
            client::{OfflineClientT, OnlineClientT},
            config::{Config, Header},
            error::{BlockError, DecodeError, Error},
            events, runtime_api::RuntimeApi, storage::Storage,
        };
        use codec::{Decode, Encode};
        use futures::lock::Mutex as AsyncMutex;
        use std::sync::Arc;
        /// A representation of a block.
        pub struct Block<T: Config, C> {
            header: T::Header,
            block_ref: BlockRef<T::Hash>,
            client: C,
            cached_events: CachedEvents<T>,
        }
        pub(crate) type CachedEvents<T> = Arc<AsyncMutex<Option<events::Events<T>>>>;
        impl<T, C> Block<T, C>
        where
            T: Config,
            C: OfflineClientT<T>,
        {
            pub(crate) fn new(
                header: T::Header,
                block_ref: BlockRef<T::Hash>,
                client: C,
            ) -> Self {
                Block {
                    header,
                    block_ref,
                    client,
                    cached_events: Default::default(),
                }
            }
            /// Return a reference to the given block. While this reference is kept alive,
            /// the backend will (if possible) endeavour to keep hold of the block.
            pub fn reference(&self) -> BlockRef<T::Hash> {
                self.block_ref.clone()
            }
            /// Return the block hash.
            pub fn hash(&self) -> T::Hash {
                self.block_ref.hash()
            }
            /// Return the block number.
            pub fn number(&self) -> <T::Header as crate::config::Header>::Number {
                self.header().number()
            }
            /// Return the entire block header.
            pub fn header(&self) -> &T::Header {
                &self.header
            }
        }
        impl<T, C> Block<T, C>
        where
            T: Config,
            C: OnlineClientT<T>,
        {
            /// Return the events associated with the block, fetching them from the node if necessary.
            pub async fn events(&self) -> Result<events::Events<T>, Error> {
                get_events(&self.client, self.header.hash(), &self.cached_events).await
            }
            /// Fetch and return the extrinsics in the block body.
            pub async fn extrinsics(&self) -> Result<Extrinsics<T, C>, Error> {
                let ids = ExtrinsicPartTypeIds::new(&self.client.metadata())?;
                let block_hash = self.header.hash();
                let Some(extrinsics) = self
                    .client
                    .backend()
                    .block_body(block_hash)
                    .await? else { return Err(BlockError::not_found(block_hash).into());
            };
                Ok(
                    Extrinsics::new(
                        self.client.clone(),
                        extrinsics,
                        self.cached_events.clone(),
                        ids,
                        block_hash,
                    ),
                )
            }
            /// Work with storage.
            pub fn storage(&self) -> Storage<T, C> {
                Storage::new(self.client.clone(), self.block_ref.clone())
            }
            /// Execute a runtime API call at this block.
            pub async fn runtime_api(&self) -> Result<RuntimeApi<T, C>, Error> {
                Ok(RuntimeApi::new(self.client.clone(), self.block_ref.clone()))
            }
            /// Get the account nonce for a given account ID at this block.
            pub async fn account_nonce(
                &self,
                account_id: &T::AccountId,
            ) -> Result<u64, Error> {
                get_account_nonce(&self.client, account_id, self.hash()).await
            }
        }
        pub(crate) async fn get_events<C, T>(
            client: &C,
            block_hash: T::Hash,
            cached_events: &AsyncMutex<Option<events::Events<T>>>,
        ) -> Result<events::Events<T>, Error>
        where
            T: Config,
            C: OnlineClientT<T>,
        {
            let mut lock = cached_events.lock().await;
            let events = match &*lock {
                Some(events) => events.clone(),
                None => {
                    let events = events::EventsClient::new(client.clone())
                        .at(block_hash)
                        .await?;
                    lock.replace(events.clone());
                    events
                }
            };
            Ok(events)
        }
        pub(crate) async fn get_account_nonce<C, T>(
            client: &C,
            account_id: &T::AccountId,
            block_hash: T::Hash,
        ) -> Result<u64, Error>
        where
            C: OnlineClientT<T>,
            T: Config,
        {
            let account_nonce_bytes = client
                .backend()
                .call(
                    "AccountNonceApi_account_nonce",
                    Some(&account_id.encode()),
                    block_hash,
                )
                .await?;
            let cursor = &mut &account_nonce_bytes[..];
            let account_nonce: u64 = match account_nonce_bytes.len() {
                2 => u16::decode(cursor)?.into(),
                4 => u32::decode(cursor)?.into(),
                8 => u64::decode(cursor)?,
                _ => {
                    return Err(
                        Error::Decode(
                            DecodeError::custom_string({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "state call AccountNonceApi_account_nonce returned an unexpected number of bytes: {0} (expected 2, 4 or 8)",
                                        account_nonce_bytes.len()
                                    ),
                                );
                                res
                            }),
                        ),
                    );
                }
            };
            Ok(account_nonce)
        }
    }
    mod blocks_client {
        use super::Block;
        use crate::{
            backend::{BlockRef, StreamOfResults},
            client::OnlineClientT, config::Config, error::{BlockError, Error},
            utils::PhantomDataSendSync,
        };
        use derivative::Derivative;
        use futures::StreamExt;
        use std::future::Future;
        type BlockStream<T> = StreamOfResults<T>;
        type BlockStreamRes<T> = Result<BlockStream<T>, Error>;
        /// A client for working with blocks.
        #[derivative(Clone(bound = "Client: Clone"))]
        pub struct BlocksClient<T, Client> {
            client: Client,
            _marker: PhantomDataSendSync<T>,
        }
        #[allow(unused_qualifications)]
        impl<T, Client> ::std::clone::Clone for BlocksClient<T, Client>
        where
            Client: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    BlocksClient { client: ref __arg_0, _marker: ref __arg_1 } => {
                        BlocksClient {
                            client: (*__arg_0).clone(),
                            _marker: (*__arg_1).clone(),
                        }
                    }
                }
            }
        }
        impl<T, Client> BlocksClient<T, Client> {
            /// Create a new [`BlocksClient`].
            pub fn new(client: Client) -> Self {
                Self {
                    client,
                    _marker: PhantomDataSendSync::new(),
                }
            }
        }
        impl<T, Client> BlocksClient<T, Client>
        where
            T: Config,
            Client: OnlineClientT<T>,
        {
            /// Obtain block details given the provided block hash.
            ///
            /// # Warning
            ///
            /// This call only supports blocks produced since the most recent
            /// runtime upgrade. You can attempt to retrieve older blocks,
            /// but may run into errors attempting to work with them.
            pub fn at(
                &self,
                block_ref: impl Into<BlockRef<T::Hash>>,
            ) -> impl Future<Output = Result<Block<T, Client>, Error>> + Send + 'static {
                self.at_or_latest(Some(block_ref.into()))
            }
            /// Obtain block details of the latest block hash.
            pub fn at_latest(
                &self,
            ) -> impl Future<Output = Result<Block<T, Client>, Error>> + Send + 'static {
                self.at_or_latest(None)
            }
            /// Obtain block details given the provided block hash, or the latest block if `None` is
            /// provided.
            fn at_or_latest(
                &self,
                block_ref: Option<BlockRef<T::Hash>>,
            ) -> impl Future<Output = Result<Block<T, Client>, Error>> + Send + 'static {
                let client = self.client.clone();
                async move {
                    let block_ref = match block_ref {
                        Some(r) => r,
                        None => client.backend().latest_finalized_block_ref().await?,
                    };
                    let block_header = match client
                        .backend()
                        .block_header(block_ref.hash())
                        .await?
                    {
                        Some(header) => header,
                        None => {
                            return Err(BlockError::not_found(block_ref.hash()).into());
                        }
                    };
                    Ok(Block::new(block_header, block_ref, client))
                }
            }
            /// Subscribe to all new blocks imported by the node.
            ///
            /// **Note:** You probably want to use [`Self::subscribe_finalized()`] most of
            /// the time.
            pub fn subscribe_all(
                &self,
            ) -> impl Future<
                Output = Result<BlockStream<Block<T, Client>>, Error>,
            > + Send + 'static
            where
                Client: Send + Sync + 'static,
            {
                let client = self.client.clone();
                header_sub_fut_to_block_sub(
                    self.clone(),
                    async move {
                        let sub = client.backend().stream_all_block_headers().await?;
                        BlockStreamRes::Ok(sub)
                    },
                )
            }
            /// Subscribe to all new blocks imported by the node onto the current best fork.
            ///
            /// **Note:** You probably want to use [`Self::subscribe_finalized()`] most of
            /// the time.
            pub fn subscribe_best(
                &self,
            ) -> impl Future<
                Output = Result<BlockStream<Block<T, Client>>, Error>,
            > + Send + 'static
            where
                Client: Send + Sync + 'static,
            {
                let client = self.client.clone();
                header_sub_fut_to_block_sub(
                    self.clone(),
                    async move {
                        let sub = client.backend().stream_best_block_headers().await?;
                        BlockStreamRes::Ok(sub)
                    },
                )
            }
            /// Subscribe to finalized blocks.
            pub fn subscribe_finalized(
                &self,
            ) -> impl Future<
                Output = Result<BlockStream<Block<T, Client>>, Error>,
            > + Send + 'static
            where
                Client: Send + Sync + 'static,
            {
                let client = self.client.clone();
                header_sub_fut_to_block_sub(
                    self.clone(),
                    async move {
                        let sub = client
                            .backend()
                            .stream_finalized_block_headers()
                            .await?;
                        BlockStreamRes::Ok(sub)
                    },
                )
            }
        }
        /// Take a promise that will return a subscription to some block headers,
        /// and return a subscription to some blocks based on this.
        async fn header_sub_fut_to_block_sub<T, Client, S>(
            blocks_client: BlocksClient<T, Client>,
            sub: S,
        ) -> Result<BlockStream<Block<T, Client>>, Error>
        where
            T: Config,
            S: Future<
                    Output = Result<BlockStream<(T::Header, BlockRef<T::Hash>)>, Error>,
                > + Send + 'static,
            Client: OnlineClientT<T> + Send + Sync + 'static,
        {
            let sub = sub
                .await?
                .then(move |header_and_ref| {
                    let client = blocks_client.client.clone();
                    async move {
                        let (header, block_ref) = match header_and_ref {
                            Ok(header_and_ref) => header_and_ref,
                            Err(e) => return Err(e),
                        };
                        Ok(Block::new(header, block_ref, client))
                    }
                });
            BlockStreamRes::Ok(StreamOfResults::new(Box::pin(sub)))
        }
    }
    mod extrinsic_types {
        use crate::{
            blocks::block_types::{get_events, CachedEvents},
            client::{OfflineClientT, OnlineClientT},
            config::{Config, Hasher},
            error::{BlockError, Error, MetadataError},
            events, metadata::types::PalletMetadata, Metadata,
        };
        use crate::config::signed_extensions::{
            ChargeAssetTxPayment, ChargeTransactionPayment, CheckNonce,
        };
        use crate::config::SignedExtension;
        use crate::dynamic::DecodedValue;
        use crate::utils::strip_compact_prefix;
        use codec::Decode;
        use derivative::Derivative;
        use scale_decode::{DecodeAsFields, DecodeAsType};
        use std::sync::Arc;
        /// Trait to uniquely identify the extrinsic's identity from the runtime metadata.
        ///
        /// Generated API structures that represent an extrinsic implement this trait.
        ///
        /// The trait is utilized to decode emitted extrinsics from a block, via obtaining the
        /// form of the `Extrinsic` from the metadata.
        pub trait StaticExtrinsic: DecodeAsFields {
            /// Pallet name.
            const PALLET: &'static str;
            /// Call name.
            const CALL: &'static str;
            /// Returns true if the given pallet and call names match this extrinsic.
            fn is_extrinsic(pallet: &str, call: &str) -> bool {
                Self::PALLET == pallet && Self::CALL == call
            }
        }
        /// The body of a block.
        pub struct Extrinsics<T: Config, C> {
            client: C,
            extrinsics: Vec<Vec<u8>>,
            cached_events: CachedEvents<T>,
            ids: ExtrinsicPartTypeIds,
            hash: T::Hash,
        }
        impl<T, C> Extrinsics<T, C>
        where
            T: Config,
            C: OfflineClientT<T>,
        {
            pub(crate) fn new(
                client: C,
                extrinsics: Vec<Vec<u8>>,
                cached_events: CachedEvents<T>,
                ids: ExtrinsicPartTypeIds,
                hash: T::Hash,
            ) -> Self {
                Self {
                    client,
                    extrinsics,
                    cached_events,
                    ids,
                    hash,
                }
            }
            /// The number of extrinsics.
            pub fn len(&self) -> usize {
                self.extrinsics.len()
            }
            /// Are there no extrinsics in this block?
            pub fn is_empty(&self) -> bool {
                self.extrinsics.is_empty()
            }
            /// Return the block hash that these extrinsics are from.
            pub fn block_hash(&self) -> T::Hash {
                self.hash
            }
            /// Returns an iterator over the extrinsics in the block body.
            pub fn iter(
                &self,
            ) -> impl Iterator<
                Item = Result<ExtrinsicDetails<T, C>, Error>,
            > + Send + Sync + 'static {
                let extrinsics = self.extrinsics.clone();
                let num_extrinsics = self.extrinsics.len();
                let client = self.client.clone();
                let hash = self.hash;
                let cached_events = self.cached_events.clone();
                let ids = self.ids;
                let mut index = 0;
                std::iter::from_fn(move || {
                    if index == num_extrinsics {
                        None
                    } else {
                        match ExtrinsicDetails::decode_from(
                            index as u32,
                            &extrinsics[index],
                            client.clone(),
                            hash,
                            cached_events.clone(),
                            ids,
                        ) {
                            Ok(extrinsic_details) => {
                                index += 1;
                                Some(Ok(extrinsic_details))
                            }
                            Err(e) => {
                                index = num_extrinsics;
                                Some(Err(e))
                            }
                        }
                    }
                })
            }
            /// Iterate through the extrinsics using metadata to dynamically decode and skip
            /// them, and return only those which should decode to the provided `E` type.
            /// If an error occurs, all subsequent iterations return `None`.
            pub fn find<E: StaticExtrinsic>(
                &self,
            ) -> impl Iterator<Item = Result<FoundExtrinsic<T, C, E>, Error>> + '_ {
                self.iter()
                    .filter_map(|res| match res {
                        Err(err) => Some(Err(err)),
                        Ok(details) => {
                            match details.as_extrinsic::<E>() {
                                Err(err) => Some(Err(err)),
                                Ok(None) => None,
                                Ok(Some(value)) => {
                                    Some(Ok(FoundExtrinsic { details, value }))
                                }
                            }
                        }
                    })
            }
            /// Iterate through the extrinsics using metadata to dynamically decode and skip
            /// them, and return the first extrinsic found which decodes to the provided `E` type.
            pub fn find_first<E: StaticExtrinsic>(
                &self,
            ) -> Result<Option<FoundExtrinsic<T, C, E>>, Error> {
                self.find::<E>().next().transpose()
            }
            /// Iterate through the extrinsics using metadata to dynamically decode and skip
            /// them, and return the last extrinsic found which decodes to the provided `Ev` type.
            pub fn find_last<E: StaticExtrinsic>(
                &self,
            ) -> Result<Option<FoundExtrinsic<T, C, E>>, Error> {
                self.find::<E>().last().transpose()
            }
            /// Find an extrinsics that decodes to the type provided. Returns true if it was found.
            pub fn has<E: StaticExtrinsic>(&self) -> Result<bool, Error> {
                Ok(self.find::<E>().next().transpose()?.is_some())
            }
        }
        /// A single extrinsic in a block.
        pub struct ExtrinsicDetails<T: Config, C> {
            /// The index of the extrinsic in the block.
            index: u32,
            /// Extrinsic bytes.
            bytes: Arc<[u8]>,
            /// Some if the extrinsic payload is signed.
            signed_details: Option<SignedExtrinsicDetails>,
            /// The start index in the `bytes` from which the call is encoded.
            call_start_idx: usize,
            /// The pallet index.
            pallet_index: u8,
            /// The variant index.
            variant_index: u8,
            /// The block hash of this extrinsic (needed to fetch events).
            block_hash: T::Hash,
            /// Subxt client.
            client: C,
            /// Cached events.
            cached_events: CachedEvents<T>,
            /// Subxt metadata to fetch the extrinsic metadata.
            metadata: Metadata,
            _marker: std::marker::PhantomData<T>,
        }
        /// Details only available in signed extrinsics.
        pub struct SignedExtrinsicDetails {
            /// start index of the range in `bytes` of `ExtrinsicDetails` that encodes the address.
            address_start_idx: usize,
            /// end index of the range in `bytes` of `ExtrinsicDetails` that encodes the address. Equivalent to signature_start_idx.
            address_end_idx: usize,
            /// end index of the range in `bytes` of `ExtrinsicDetails` that encodes the signature. Equivalent to extra_start_idx.
            signature_end_idx: usize,
            /// end index of the range in `bytes` of `ExtrinsicDetails` that encodes the signature.
            extra_end_idx: usize,
        }
        impl<T, C> ExtrinsicDetails<T, C>
        where
            T: Config,
            C: OfflineClientT<T>,
        {
            pub(crate) fn decode_from(
                index: u32,
                extrinsic_bytes: &[u8],
                client: C,
                block_hash: T::Hash,
                cached_events: CachedEvents<T>,
                ids: ExtrinsicPartTypeIds,
            ) -> Result<ExtrinsicDetails<T, C>, Error> {
                const SIGNATURE_MASK: u8 = 0b1000_0000;
                const VERSION_MASK: u8 = 0b0111_1111;
                const LATEST_EXTRINSIC_VERSION: u8 = 4;
                let metadata = client.metadata();
                let bytes: Arc<[u8]> = strip_compact_prefix(extrinsic_bytes)?.1.into();
                let first_byte: u8 = Decode::decode(&mut &bytes[..])?;
                let version = first_byte & VERSION_MASK;
                if version != LATEST_EXTRINSIC_VERSION {
                    return Err(BlockError::UnsupportedVersion(version).into());
                }
                let is_signed = first_byte & SIGNATURE_MASK != 0;
                let cursor = &mut &bytes[1..];
                let signed_details = is_signed
                    .then(|| -> Result<SignedExtrinsicDetails, Error> {
                        let address_start_idx = bytes.len() - cursor.len();
                        scale_decode::visitor::decode_with_visitor(
                                cursor,
                                ids.address,
                                metadata.types(),
                                scale_decode::visitor::IgnoreVisitor,
                            )
                            .map_err(scale_decode::Error::from)?;
                        let address_end_idx = bytes.len() - cursor.len();
                        scale_decode::visitor::decode_with_visitor(
                                cursor,
                                ids.signature,
                                metadata.types(),
                                scale_decode::visitor::IgnoreVisitor,
                            )
                            .map_err(scale_decode::Error::from)?;
                        let signature_end_idx = bytes.len() - cursor.len();
                        scale_decode::visitor::decode_with_visitor(
                                cursor,
                                ids.extra,
                                metadata.types(),
                                scale_decode::visitor::IgnoreVisitor,
                            )
                            .map_err(scale_decode::Error::from)?;
                        let extra_end_idx = bytes.len() - cursor.len();
                        Ok(SignedExtrinsicDetails {
                            address_start_idx,
                            address_end_idx,
                            signature_end_idx,
                            extra_end_idx,
                        })
                    })
                    .transpose()?;
                let call_start_idx = bytes.len() - cursor.len();
                let cursor = &mut &bytes[call_start_idx..];
                let pallet_index: u8 = Decode::decode(cursor)?;
                let variant_index: u8 = Decode::decode(cursor)?;
                Ok(ExtrinsicDetails {
                    index,
                    bytes,
                    signed_details,
                    call_start_idx,
                    pallet_index,
                    variant_index,
                    block_hash,
                    client,
                    cached_events,
                    metadata,
                    _marker: std::marker::PhantomData,
                })
            }
            /// Is the extrinsic signed?
            pub fn is_signed(&self) -> bool {
                self.signed_details.is_some()
            }
            /// The index of the extrinsic in the block.
            pub fn index(&self) -> u32 {
                self.index
            }
            /// Return _all_ of the bytes representing this extrinsic, which include, in order:
            /// - First byte: abbbbbbb (a = 0 for unsigned, 1 for signed, b = version)
            /// - SignatureType (if the payload is signed)
            ///   - Address
            ///   - Signature
            ///   - Extra fields
            /// - Extrinsic call bytes
            pub fn bytes(&self) -> &[u8] {
                &self.bytes
            }
            /// Return only the bytes representing this extrinsic call:
            /// - First byte is the pallet index
            /// - Second byte is the variant (call) index
            /// - Followed by field bytes.
            ///
            /// # Note
            ///
            /// Please use [`Self::bytes`] if you want to get all extrinsic bytes.
            pub fn call_bytes(&self) -> &[u8] {
                &self.bytes[self.call_start_idx..]
            }
            /// Return the bytes representing the fields stored in this extrinsic.
            ///
            /// # Note
            ///
            /// This is a subset of [`Self::call_bytes`] that does not include the
            /// first two bytes that denote the pallet index and the variant index.
            pub fn field_bytes(&self) -> &[u8] {
                &self.call_bytes()[2..]
            }
            /// Return only the bytes of the address that signed this extrinsic.
            ///
            /// # Note
            ///
            /// Returns `None` if the extrinsic is not signed.
            pub fn address_bytes(&self) -> Option<&[u8]> {
                self.signed_details
                    .as_ref()
                    .map(|e| &self.bytes[e.address_start_idx..e.address_end_idx])
            }
            /// Returns Some(signature_bytes) if the extrinsic was signed otherwise None is returned.
            pub fn signature_bytes(&self) -> Option<&[u8]> {
                self.signed_details
                    .as_ref()
                    .map(|e| &self.bytes[e.address_end_idx..e.signature_end_idx])
            }
            /// Returns the signed extension `extra` bytes of the extrinsic.
            /// Each signed extension has an `extra` type (May be zero-sized).
            /// These bytes are the scale encoded `extra` fields of each signed extension in order of the signed extensions.
            /// They do *not* include the `additional` signed bytes that are used as part of the payload that is signed.
            ///
            /// Note: Returns `None` if the extrinsic is not signed.
            pub fn signed_extensions_bytes(&self) -> Option<&[u8]> {
                self.signed_details
                    .as_ref()
                    .map(|e| &self.bytes[e.signature_end_idx..e.extra_end_idx])
            }
            /// Returns `None` if the extrinsic is not signed.
            pub fn signed_extensions(&self) -> Option<ExtrinsicSignedExtensions<'_, T>> {
                let signed = self.signed_details.as_ref()?;
                let extra_bytes = &self
                    .bytes[signed.signature_end_idx..signed.extra_end_idx];
                Some(ExtrinsicSignedExtensions {
                    bytes: extra_bytes,
                    metadata: &self.metadata,
                    _marker: std::marker::PhantomData,
                })
            }
            /// The index of the pallet that the extrinsic originated from.
            pub fn pallet_index(&self) -> u8 {
                self.pallet_index
            }
            /// The index of the extrinsic variant that the extrinsic originated from.
            pub fn variant_index(&self) -> u8 {
                self.variant_index
            }
            /// The name of the pallet from whence the extrinsic originated.
            pub fn pallet_name(&self) -> Result<&str, Error> {
                Ok(self.extrinsic_metadata()?.pallet.name())
            }
            /// The name of the call (ie the name of the variant that it corresponds to).
            pub fn variant_name(&self) -> Result<&str, Error> {
                Ok(&self.extrinsic_metadata()?.variant.name)
            }
            /// Fetch the metadata for this extrinsic.
            pub fn extrinsic_metadata(&self) -> Result<ExtrinsicMetadataDetails, Error> {
                let pallet = self.metadata.pallet_by_index_err(self.pallet_index())?;
                let variant = pallet
                    .call_variant_by_index(self.variant_index())
                    .ok_or_else(|| MetadataError::VariantIndexNotFound(
                        self.variant_index(),
                    ))?;
                Ok(ExtrinsicMetadataDetails {
                    pallet,
                    variant,
                })
            }
            /// Decode and provide the extrinsic fields back in the form of a [`scale_value::Composite`]
            /// type which represents the named or unnamed fields that were present in the extrinsic.
            pub fn field_values(
                &self,
            ) -> Result<scale_value::Composite<scale_value::scale::TypeId>, Error> {
                let bytes = &mut self.field_bytes();
                let extrinsic_metadata = self.extrinsic_metadata()?;
                let mut fields = extrinsic_metadata
                    .variant
                    .fields
                    .iter()
                    .map(|f| scale_decode::Field::new(f.ty.id, f.name.as_deref()));
                let decoded = <scale_value::Composite<
                    scale_value::scale::TypeId,
                >>::decode_as_fields(bytes, &mut fields, self.metadata.types())?;
                Ok(decoded)
            }
            /// Attempt to decode these [`ExtrinsicDetails`] into a type representing the extrinsic fields.
            /// Such types are exposed in the codegen as `pallet_name::calls::types::CallName` types.
            pub fn as_extrinsic<E: StaticExtrinsic>(&self) -> Result<Option<E>, Error> {
                let extrinsic_metadata = self.extrinsic_metadata()?;
                if extrinsic_metadata.pallet.name() == E::PALLET
                    && extrinsic_metadata.variant.name == E::CALL
                {
                    let mut fields = extrinsic_metadata
                        .variant
                        .fields
                        .iter()
                        .map(|f| scale_decode::Field::new(f.ty.id, f.name.as_deref()));
                    let decoded = E::decode_as_fields(
                        &mut self.field_bytes(),
                        &mut fields,
                        self.metadata.types(),
                    )?;
                    Ok(Some(decoded))
                } else {
                    Ok(None)
                }
            }
            /// Attempt to decode these [`ExtrinsicDetails`] into an outer call enum type (which includes
            /// the pallet and extrinsic enum variants as well as the extrinsic fields). A compatible
            /// type for this is exposed via static codegen as a root level `Call` type.
            pub fn as_root_extrinsic<E: DecodeAsType>(&self) -> Result<E, Error> {
                let decoded = E::decode_as_type(
                    &mut &self.call_bytes()[..],
                    self.metadata.outer_enums().call_enum_ty(),
                    self.metadata.types(),
                )?;
                Ok(decoded)
            }
        }
        impl<T, C> ExtrinsicDetails<T, C>
        where
            T: Config,
            C: OnlineClientT<T>,
        {
            /// The events associated with the extrinsic.
            pub async fn events(&self) -> Result<ExtrinsicEvents<T>, Error> {
                let events = get_events(
                        &self.client,
                        self.block_hash,
                        &self.cached_events,
                    )
                    .await?;
                let ext_hash = T::Hasher::hash_of(&self.bytes);
                Ok(ExtrinsicEvents::new(ext_hash, self.index, events))
            }
        }
        /// A Static Extrinsic found in a block coupled with it's details.
        pub struct FoundExtrinsic<T: Config, C, E> {
            pub details: ExtrinsicDetails<T, C>,
            pub value: E,
        }
        /// Details for the given extrinsic plucked from the metadata.
        pub struct ExtrinsicMetadataDetails<'a> {
            pub pallet: PalletMetadata<'a>,
            pub variant: &'a scale_info::Variant<scale_info::form::PortableForm>,
        }
        /// The type IDs extracted from the metadata that represent the
        /// generic type parameters passed to the `UncheckedExtrinsic` from
        /// the substrate-based chain.
        pub(crate) struct ExtrinsicPartTypeIds {
            /// The address (source) of the extrinsic.
            address: u32,
            /// The extrinsic call type.
            _call: u32,
            /// The signature of the extrinsic.
            signature: u32,
            /// The extra parameters of the extrinsic.
            extra: u32,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ExtrinsicPartTypeIds {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ExtrinsicPartTypeIds",
                    "address",
                    &self.address,
                    "_call",
                    &self._call,
                    "signature",
                    &self.signature,
                    "extra",
                    &&self.extra,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ExtrinsicPartTypeIds {}
        #[automatically_derived]
        impl ::core::clone::Clone for ExtrinsicPartTypeIds {
            #[inline]
            fn clone(&self) -> ExtrinsicPartTypeIds {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
        impl ExtrinsicPartTypeIds {
            /// Extract the generic type parameters IDs from the extrinsic type.
            pub(crate) fn new(metadata: &Metadata) -> Result<Self, BlockError> {
                Ok(ExtrinsicPartTypeIds {
                    address: metadata.extrinsic().address_ty(),
                    _call: metadata.extrinsic().call_ty(),
                    signature: metadata.extrinsic().signature_ty(),
                    extra: metadata.extrinsic().extra_ty(),
                })
            }
        }
        /// The events associated with a given extrinsic.
        #[derivative(Debug(bound = ""))]
        pub struct ExtrinsicEvents<T: Config> {
            ext_hash: T::Hash,
            idx: u32,
            events: events::Events<T>,
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<T: Config> ::std::fmt::Debug for ExtrinsicEvents<T> {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    ExtrinsicEvents {
                        ext_hash: ref __arg_0,
                        idx: ref __arg_1,
                        events: ref __arg_2,
                    } => {
                        let mut __debug_trait_builder = __f
                            .debug_struct("ExtrinsicEvents");
                        let _ = __debug_trait_builder.field("ext_hash", &&(*__arg_0));
                        let _ = __debug_trait_builder.field("idx", &&(*__arg_1));
                        let _ = __debug_trait_builder.field("events", &&(*__arg_2));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        impl<T: Config> ExtrinsicEvents<T> {
            pub(crate) fn new(
                ext_hash: T::Hash,
                idx: u32,
                events: events::Events<T>,
            ) -> Self {
                Self { ext_hash, idx, events }
            }
            /// Return the hash of the block that the extrinsic is in.
            pub fn block_hash(&self) -> T::Hash {
                self.events.block_hash()
            }
            /// The index of the extrinsic that these events are produced from.
            pub fn extrinsic_index(&self) -> u32 {
                self.idx
            }
            /// Return the hash of the extrinsic.
            pub fn extrinsic_hash(&self) -> T::Hash {
                self.ext_hash
            }
            /// Return all of the events in the block that the extrinsic is in.
            pub fn all_events_in_block(&self) -> &events::Events<T> {
                &self.events
            }
            /// Iterate over all of the raw events associated with this transaction.
            ///
            /// This works in the same way that [`events::Events::iter()`] does, with the
            /// exception that it filters out events not related to the submitted extrinsic.
            pub fn iter(
                &self,
            ) -> impl Iterator<Item = Result<events::EventDetails<T>, Error>> + '_ {
                self.events
                    .iter()
                    .filter(|ev| {
                        ev.as_ref()
                            .map(|ev| {
                                ev.phase() == events::Phase::ApplyExtrinsic(self.idx)
                            })
                            .unwrap_or(true)
                    })
            }
            /// Find all of the transaction events matching the event type provided as a generic parameter.
            ///
            /// This works in the same way that [`events::Events::find()`] does, with the
            /// exception that it filters out events not related to the submitted extrinsic.
            pub fn find<Ev: events::StaticEvent>(
                &self,
            ) -> impl Iterator<Item = Result<Ev, Error>> + '_ {
                self.iter()
                    .filter_map(|ev| {
                        ev.and_then(|ev| ev.as_event::<Ev>().map_err(Into::into))
                            .transpose()
                    })
            }
            /// Iterate through the transaction events using metadata to dynamically decode and skip
            /// them, and return the first event found which decodes to the provided `Ev` type.
            ///
            /// This works in the same way that [`events::Events::find_first()`] does, with the
            /// exception that it ignores events not related to the submitted extrinsic.
            pub fn find_first<Ev: events::StaticEvent>(
                &self,
            ) -> Result<Option<Ev>, Error> {
                self.find::<Ev>().next().transpose()
            }
            /// Iterate through the transaction events using metadata to dynamically decode and skip
            /// them, and return the last event found which decodes to the provided `Ev` type.
            ///
            /// This works in the same way that [`events::Events::find_last()`] does, with the
            /// exception that it ignores events not related to the submitted extrinsic.
            pub fn find_last<Ev: events::StaticEvent>(
                &self,
            ) -> Result<Option<Ev>, Error> {
                self.find::<Ev>().last().transpose()
            }
            /// Find an event in those associated with this transaction. Returns true if it was found.
            ///
            /// This works in the same way that [`events::Events::has()`] does, with the
            /// exception that it ignores events not related to the submitted extrinsic.
            pub fn has<Ev: events::StaticEvent>(&self) -> Result<bool, Error> {
                Ok(self.find::<Ev>().next().transpose()?.is_some())
            }
        }
        /// The signed extensions of an extrinsic.
        pub struct ExtrinsicSignedExtensions<'a, T: Config> {
            bytes: &'a [u8],
            metadata: &'a Metadata,
            _marker: std::marker::PhantomData<T>,
        }
        #[automatically_derived]
        impl<'a, T: ::core::fmt::Debug + Config> ::core::fmt::Debug
        for ExtrinsicSignedExtensions<'a, T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "ExtrinsicSignedExtensions",
                    "bytes",
                    &self.bytes,
                    "metadata",
                    &self.metadata,
                    "_marker",
                    &&self._marker,
                )
            }
        }
        #[automatically_derived]
        impl<'a, T: ::core::clone::Clone + Config> ::core::clone::Clone
        for ExtrinsicSignedExtensions<'a, T> {
            #[inline]
            fn clone(&self) -> ExtrinsicSignedExtensions<'a, T> {
                ExtrinsicSignedExtensions {
                    bytes: ::core::clone::Clone::clone(&self.bytes),
                    metadata: ::core::clone::Clone::clone(&self.metadata),
                    _marker: ::core::clone::Clone::clone(&self._marker),
                }
            }
        }
        impl<'a, T: Config> ExtrinsicSignedExtensions<'a, T> {
            /// Returns an iterator over each of the signed extension details of the extrinsic.
            /// If the decoding of any signed extension fails, an error item is yielded and the iterator stops.
            pub fn iter(
                &self,
            ) -> impl Iterator<Item = Result<ExtrinsicSignedExtension<T>, Error>> {
                let signed_extension_types = self
                    .metadata
                    .extrinsic()
                    .signed_extensions();
                let num_signed_extensions = signed_extension_types.len();
                let bytes = self.bytes;
                let mut index = 0;
                let mut byte_start_idx = 0;
                let metadata = &self.metadata;
                std::iter::from_fn(move || {
                    if index == num_signed_extensions {
                        return None;
                    }
                    let extension = &signed_extension_types[index];
                    let ty_id = extension.extra_ty();
                    let cursor = &mut &bytes[byte_start_idx..];
                    if let Err(err)
                        = scale_decode::visitor::decode_with_visitor(
                                cursor,
                                ty_id,
                                metadata.types(),
                                scale_decode::visitor::IgnoreVisitor,
                            )
                            .map_err(|e| Error::Decode(e.into()))
                    {
                        index = num_signed_extensions;
                        return Some(Err(err));
                    }
                    let byte_end_idx = bytes.len() - cursor.len();
                    let bytes = &bytes[byte_start_idx..byte_end_idx];
                    byte_start_idx = byte_end_idx;
                    index += 1;
                    Some(
                        Ok(ExtrinsicSignedExtension {
                            bytes,
                            ty_id,
                            identifier: extension.identifier(),
                            metadata,
                            _marker: std::marker::PhantomData,
                        }),
                    )
                })
            }
            /// Searches through all signed extensions to find a specific one.
            /// If the Signed Extension is not found `Ok(None)` is returned.
            /// If the Signed Extension is found but decoding failed `Err(_)` is returned.
            pub fn find<S: SignedExtension<T>>(
                &self,
            ) -> Result<Option<S::Decoded>, Error> {
                for ext in self.iter() {
                    let ext = ext?;
                    match ext.as_signed_extension::<S>() {
                        Ok(Some(e)) => return Ok(Some(e)),
                        Ok(None) => continue,
                        Err(e) => return Err(e),
                    }
                }
                Ok(None)
            }
            /// The tip of an extrinsic, extracted from the ChargeTransactionPayment or ChargeAssetTxPayment
            /// signed extension, depending on which is present.
            ///
            /// Returns `None` if  `tip` was not found or decoding failed.
            pub fn tip(&self) -> Option<u128> {
                self.find::<ChargeTransactionPayment>()
                    .ok()
                    .flatten()
                    .map(|e| e.tip())
                    .or_else(|| {
                        self.find::<ChargeAssetTxPayment<T>>()
                            .ok()
                            .flatten()
                            .map(|e| e.tip())
                    })
            }
            /// The nonce of the account that submitted the extrinsic, extracted from the CheckNonce signed extension.
            ///
            /// Returns `None` if `nonce` was not found or decoding failed.
            pub fn nonce(&self) -> Option<u64> {
                self.find::<CheckNonce>().ok()?
            }
        }
        /// A single signed extension
        pub struct ExtrinsicSignedExtension<'a, T: Config> {
            bytes: &'a [u8],
            ty_id: u32,
            identifier: &'a str,
            metadata: &'a Metadata,
            _marker: std::marker::PhantomData<T>,
        }
        #[automatically_derived]
        impl<'a, T: ::core::fmt::Debug + Config> ::core::fmt::Debug
        for ExtrinsicSignedExtension<'a, T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "ExtrinsicSignedExtension",
                    "bytes",
                    &self.bytes,
                    "ty_id",
                    &self.ty_id,
                    "identifier",
                    &self.identifier,
                    "metadata",
                    &self.metadata,
                    "_marker",
                    &&self._marker,
                )
            }
        }
        #[automatically_derived]
        impl<'a, T: ::core::clone::Clone + Config> ::core::clone::Clone
        for ExtrinsicSignedExtension<'a, T> {
            #[inline]
            fn clone(&self) -> ExtrinsicSignedExtension<'a, T> {
                ExtrinsicSignedExtension {
                    bytes: ::core::clone::Clone::clone(&self.bytes),
                    ty_id: ::core::clone::Clone::clone(&self.ty_id),
                    identifier: ::core::clone::Clone::clone(&self.identifier),
                    metadata: ::core::clone::Clone::clone(&self.metadata),
                    _marker: ::core::clone::Clone::clone(&self._marker),
                }
            }
        }
        impl<'a, T: Config> ExtrinsicSignedExtension<'a, T> {
            /// The bytes representing this signed extension.
            pub fn bytes(&self) -> &'a [u8] {
                self.bytes
            }
            /// The name of the signed extension.
            pub fn name(&self) -> &'a str {
                self.identifier
            }
            /// The type id of the signed extension.
            pub fn type_id(&self) -> u32 {
                self.ty_id
            }
            /// Signed Extension as a [`scale_value::Value`]
            pub fn value(&self) -> Result<DecodedValue, Error> {
                self.as_type()
            }
            /// Decodes the bytes of this Signed Extension into its associated `Decoded` type.
            /// Returns `Ok(None)` if the data we have doesn't match the Signed Extension we're asking to
            /// decode with.
            pub fn as_signed_extension<S: SignedExtension<T>>(
                &self,
            ) -> Result<Option<S::Decoded>, Error> {
                if !S::matches(self.identifier, self.ty_id, self.metadata.types()) {
                    return Ok(None);
                }
                self.as_type::<S::Decoded>().map(Some)
            }
            fn as_type<E: DecodeAsType>(&self) -> Result<E, Error> {
                let value = E::decode_as_type(
                    &mut &self.bytes[..],
                    self.ty_id,
                    self.metadata.types(),
                )?;
                Ok(value)
            }
        }
    }
    /// A reference to a block.
    pub use crate::backend::BlockRef;
    pub use block_types::Block;
    pub use blocks_client::BlocksClient;
    pub use extrinsic_types::{
        ExtrinsicDetails, ExtrinsicEvents, ExtrinsicSignedExtension,
        ExtrinsicSignedExtensions, Extrinsics, StaticExtrinsic,
    };
    pub(crate) use block_types::get_account_nonce;
}
pub mod client {
    //! This module provides two clients that can be used to work with
    //! transactions, storage and events. The [`OfflineClient`] works
    //! entirely offline and can be passed to any function that doesn't
    //! require network access. The [`OnlineClient`] requires network
    //! access.
    mod offline_client {
        use crate::custom_values::CustomValuesClient;
        use crate::{
            backend::RuntimeVersion, blocks::BlocksClient, constants::ConstantsClient,
            events::EventsClient, runtime_api::RuntimeApiClient, storage::StorageClient,
            tx::TxClient, Config, Metadata,
        };
        use derivative::Derivative;
        use std::sync::Arc;
        /// A trait representing a client that can perform
        /// offline-only actions.
        pub trait OfflineClientT<T: Config>: Clone + Send + Sync + 'static {
            /// Return the provided [`Metadata`].
            fn metadata(&self) -> Metadata;
            /// Return the provided genesis hash.
            fn genesis_hash(&self) -> T::Hash;
            /// Return the provided [`RuntimeVersion`].
            fn runtime_version(&self) -> RuntimeVersion;
            /// Work with transactions.
            fn tx(&self) -> TxClient<T, Self> {
                TxClient::new(self.clone())
            }
            /// Work with events.
            fn events(&self) -> EventsClient<T, Self> {
                EventsClient::new(self.clone())
            }
            /// Work with storage.
            fn storage(&self) -> StorageClient<T, Self> {
                StorageClient::new(self.clone())
            }
            /// Access constants.
            fn constants(&self) -> ConstantsClient<T, Self> {
                ConstantsClient::new(self.clone())
            }
            /// Work with blocks.
            fn blocks(&self) -> BlocksClient<T, Self> {
                BlocksClient::new(self.clone())
            }
            /// Work with runtime API.
            fn runtime_api(&self) -> RuntimeApiClient<T, Self> {
                RuntimeApiClient::new(self.clone())
            }
            /// Work this custom types.
            fn custom_values(&self) -> CustomValuesClient<T, Self> {
                CustomValuesClient::new(self.clone())
            }
        }
        /// A client that is capable of performing offline-only operations.
        /// Can be constructed as long as you can populate the required fields.
        #[derivative(Debug(bound = ""), Clone(bound = ""))]
        pub struct OfflineClient<T: Config> {
            inner: Arc<Inner<T>>,
        }
        #[allow(unused_qualifications)]
        impl<T: Config> ::std::clone::Clone for OfflineClient<T> {
            fn clone(&self) -> Self {
                match *self {
                    OfflineClient { inner: ref __arg_0 } => {
                        OfflineClient {
                            inner: (*__arg_0).clone(),
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<T: Config> ::std::fmt::Debug for OfflineClient<T> {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    OfflineClient { inner: ref __arg_0 } => {
                        let mut __debug_trait_builder = __f
                            .debug_struct("OfflineClient");
                        let _ = __debug_trait_builder.field("inner", &&(*__arg_0));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        #[derivative(Debug(bound = ""), Clone(bound = ""))]
        struct Inner<T: Config> {
            genesis_hash: T::Hash,
            runtime_version: RuntimeVersion,
            metadata: Metadata,
        }
        #[allow(unused_qualifications)]
        impl<T: Config> ::std::clone::Clone for Inner<T> {
            fn clone(&self) -> Self {
                match *self {
                    Inner {
                        genesis_hash: ref __arg_0,
                        runtime_version: ref __arg_1,
                        metadata: ref __arg_2,
                    } => {
                        Inner {
                            genesis_hash: (*__arg_0).clone(),
                            runtime_version: (*__arg_1).clone(),
                            metadata: (*__arg_2).clone(),
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<T: Config> ::std::fmt::Debug for Inner<T> {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    Inner {
                        genesis_hash: ref __arg_0,
                        runtime_version: ref __arg_1,
                        metadata: ref __arg_2,
                    } => {
                        let mut __debug_trait_builder = __f.debug_struct("Inner");
                        let _ = __debug_trait_builder
                            .field("genesis_hash", &&(*__arg_0));
                        let _ = __debug_trait_builder
                            .field("runtime_version", &&(*__arg_1));
                        let _ = __debug_trait_builder.field("metadata", &&(*__arg_2));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        impl<T: Config> OfflineClient<T> {
            /// Construct a new [`OfflineClient`], providing
            /// the necessary runtime and compile-time arguments.
            pub fn new(
                genesis_hash: T::Hash,
                runtime_version: RuntimeVersion,
                metadata: impl Into<Metadata>,
            ) -> OfflineClient<T> {
                OfflineClient {
                    inner: Arc::new(Inner {
                        genesis_hash,
                        runtime_version,
                        metadata: metadata.into(),
                    }),
                }
            }
            /// Return the genesis hash.
            pub fn genesis_hash(&self) -> T::Hash {
                self.inner.genesis_hash
            }
            /// Return the runtime version.
            pub fn runtime_version(&self) -> RuntimeVersion {
                self.inner.runtime_version.clone()
            }
            /// Return the [`Metadata`] used in this client.
            pub fn metadata(&self) -> Metadata {
                self.inner.metadata.clone()
            }
            /// Work with transactions.
            pub fn tx(&self) -> TxClient<T, Self> {
                <Self as OfflineClientT<T>>::tx(self)
            }
            /// Work with events.
            pub fn events(&self) -> EventsClient<T, Self> {
                <Self as OfflineClientT<T>>::events(self)
            }
            /// Work with storage.
            pub fn storage(&self) -> StorageClient<T, Self> {
                <Self as OfflineClientT<T>>::storage(self)
            }
            /// Access constants.
            pub fn constants(&self) -> ConstantsClient<T, Self> {
                <Self as OfflineClientT<T>>::constants(self)
            }
            /// Access custom types
            pub fn custom_values(&self) -> CustomValuesClient<T, Self> {
                <Self as OfflineClientT<T>>::custom_values(self)
            }
        }
        impl<T: Config> OfflineClientT<T> for OfflineClient<T> {
            fn genesis_hash(&self) -> T::Hash {
                self.genesis_hash()
            }
            fn runtime_version(&self) -> RuntimeVersion {
                self.runtime_version()
            }
            fn metadata(&self) -> Metadata {
                self.metadata()
            }
        }
        impl<'a, T: Config> From<&'a OfflineClient<T>> for OfflineClient<T> {
            fn from(c: &'a OfflineClient<T>) -> Self {
                c.clone()
            }
        }
    }
    mod online_client {
        use super::{OfflineClient, OfflineClientT};
        use crate::custom_values::CustomValuesClient;
        use crate::{
            backend::{
                legacy::LegacyBackend, rpc::RpcClient, Backend, BackendExt,
                RuntimeVersion, StreamOfResults,
            },
            blocks::{BlockRef, BlocksClient},
            constants::ConstantsClient, error::Error, events::EventsClient,
            runtime_api::RuntimeApiClient, storage::StorageClient, tx::TxClient, Config,
            Metadata,
        };
        use derivative::Derivative;
        use futures::future;
        use std::sync::{Arc, RwLock};
        /// A trait representing a client that can perform
        /// online actions.
        pub trait OnlineClientT<T: Config>: OfflineClientT<T> {
            /// Return a backend that can be used to communicate with a node.
            fn backend(&self) -> &dyn Backend<T>;
        }
        /// A client that can be used to perform API calls (that is, either those
        /// requiring an [`OfflineClientT`] or those requiring an [`OnlineClientT`]).
        #[derivative(Clone(bound = ""))]
        pub struct OnlineClient<T: Config> {
            inner: Arc<RwLock<Inner<T>>>,
            backend: Arc<dyn Backend<T>>,
        }
        #[allow(unused_qualifications)]
        impl<T: Config> ::std::clone::Clone for OnlineClient<T> {
            fn clone(&self) -> Self {
                match *self {
                    OnlineClient { inner: ref __arg_0, backend: ref __arg_1 } => {
                        OnlineClient {
                            inner: (*__arg_0).clone(),
                            backend: (*__arg_1).clone(),
                        }
                    }
                }
            }
        }
        #[derivative(Debug(bound = ""))]
        struct Inner<T: Config> {
            genesis_hash: T::Hash,
            runtime_version: RuntimeVersion,
            metadata: Metadata,
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<T: Config> ::std::fmt::Debug for Inner<T> {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    Inner {
                        genesis_hash: ref __arg_0,
                        runtime_version: ref __arg_1,
                        metadata: ref __arg_2,
                    } => {
                        let mut __debug_trait_builder = __f.debug_struct("Inner");
                        let _ = __debug_trait_builder
                            .field("genesis_hash", &&(*__arg_0));
                        let _ = __debug_trait_builder
                            .field("runtime_version", &&(*__arg_1));
                        let _ = __debug_trait_builder.field("metadata", &&(*__arg_2));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        impl<T: Config> std::fmt::Debug for OnlineClient<T> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.debug_struct("Client")
                    .field("rpc", &"RpcClient")
                    .field("inner", &self.inner)
                    .finish()
            }
        }
        #[cfg(feature = "jsonrpsee")]
        impl<T: Config> OnlineClient<T> {
            /// Construct a new [`OnlineClient`] using default settings which
            /// point to a locally running node on `ws://127.0.0.1:9944`.
            pub async fn new() -> Result<OnlineClient<T>, Error> {
                let url = "ws://127.0.0.1:9944";
                OnlineClient::from_url(url).await
            }
            /// Construct a new [`OnlineClient`], providing a URL to connect to.
            pub async fn from_url(
                url: impl AsRef<str>,
            ) -> Result<OnlineClient<T>, Error> {
                crate::utils::validate_url_is_secure(url.as_ref())?;
                OnlineClient::from_insecure_url(url).await
            }
            /// Construct a new [`OnlineClient`], providing a URL to connect to.
            ///
            /// Allows insecure URLs without SSL encryption, e.g. (http:// and ws:// URLs).
            pub async fn from_insecure_url(
                url: impl AsRef<str>,
            ) -> Result<OnlineClient<T>, Error> {
                let client = RpcClient::from_insecure_url(url).await?;
                let backend = LegacyBackend::new(client);
                OnlineClient::from_backend(Arc::new(backend)).await
            }
        }
        impl<T: Config> OnlineClient<T> {
            /// Construct a new [`OnlineClient`] by providing an [`RpcClient`] to drive the connection.
            /// This will use the current default [`Backend`], which may change in future releases.
            pub async fn from_rpc_client(
                rpc_client: RpcClient,
            ) -> Result<OnlineClient<T>, Error> {
                let backend = Arc::new(LegacyBackend::new(rpc_client));
                OnlineClient::from_backend(backend).await
            }
            /// Construct a new [`OnlineClient`] by providing an RPC client along with the other
            /// necessary details. This will use the current default [`Backend`], which may change
            /// in future releases.
            ///
            /// # Warning
            ///
            /// This is considered the most primitive and also error prone way to
            /// instantiate a client; the genesis hash, metadata and runtime version provided will
            /// entirely determine which node and blocks this client will be able to interact with,
            /// and whether it will be able to successfully do things like submit transactions.
            ///
            /// If you're unsure what you're doing, prefer one of the alternate methods to instantiate
            /// a client.
            pub fn from_rpc_client_with(
                genesis_hash: T::Hash,
                runtime_version: RuntimeVersion,
                metadata: impl Into<Metadata>,
                rpc_client: RpcClient,
            ) -> Result<OnlineClient<T>, Error> {
                let backend = Arc::new(LegacyBackend::new(rpc_client));
                OnlineClient::from_backend_with(
                    genesis_hash,
                    runtime_version,
                    metadata,
                    backend,
                )
            }
            /// Construct a new [`OnlineClient`] by providing an underlying [`Backend`]
            /// implementation to power it. Other details will be obtained from the chain.
            pub async fn from_backend<B: Backend<T>>(
                backend: Arc<B>,
            ) -> Result<OnlineClient<T>, Error> {
                let latest_block = backend.latest_finalized_block_ref().await?;
                let (genesis_hash, runtime_version, metadata) = future::join3(
                        backend.genesis_hash(),
                        backend.current_runtime_version(),
                        OnlineClient::fetch_metadata(&*backend, latest_block.hash()),
                    )
                    .await;
                OnlineClient::from_backend_with(
                    genesis_hash?,
                    runtime_version?,
                    metadata?,
                    backend,
                )
            }
            /// Construct a new [`OnlineClient`] by providing all of the underlying details needed
            /// to make it work.
            ///
            /// # Warning
            ///
            /// This is considered the most primitive and also error prone way to
            /// instantiate a client; the genesis hash, metadata and runtime version provided will
            /// entirely determine which node and blocks this client will be able to interact with,
            /// and whether it will be able to successfully do things like submit transactions.
            ///
            /// If you're unsure what you're doing, prefer one of the alternate methods to instantiate
            /// a client.
            pub fn from_backend_with<B: Backend<T>>(
                genesis_hash: T::Hash,
                runtime_version: RuntimeVersion,
                metadata: impl Into<Metadata>,
                backend: Arc<B>,
            ) -> Result<OnlineClient<T>, Error> {
                Ok(OnlineClient {
                    inner: Arc::new(
                        RwLock::new(Inner {
                            genesis_hash,
                            runtime_version,
                            metadata: metadata.into(),
                        }),
                    ),
                    backend,
                })
            }
            /// Fetch the metadata from substrate using the runtime API.
            async fn fetch_metadata(
                backend: &dyn Backend<T>,
                block_hash: T::Hash,
            ) -> Result<Metadata, Error> {
                #[cfg(not(feature = "unstable-metadata"))]
                OnlineClient::fetch_latest_stable_metadata(backend, block_hash).await
            }
            /// Fetch the latest stable metadata from the node.
            async fn fetch_latest_stable_metadata(
                backend: &dyn Backend<T>,
                block_hash: T::Hash,
            ) -> Result<Metadata, Error> {
                const V15_METADATA_VERSION: u32 = 15;
                if let Ok(bytes)
                    = backend.metadata_at_version(V15_METADATA_VERSION, block_hash).await
                {
                    return Ok(bytes);
                }
                backend.legacy_metadata(block_hash).await
            }
            /// Create an object which can be used to keep the runtime up to date
            /// in a separate thread.
            ///
            /// # Example
            ///
            /// ```no_run
            /// # #[tokio::main]
            /// # async fn main() {
            /// use subxt::{ OnlineClient, PolkadotConfig };
            ///
            /// let client = OnlineClient::<PolkadotConfig>::new().await.unwrap();
            ///
            /// // high level API.
            ///
            /// let update_task = client.updater();
            /// tokio::spawn(async move {
            ///     update_task.perform_runtime_updates().await;
            /// });
            ///
            ///
            /// // low level API.
            ///
            /// let updater = client.updater();
            /// tokio::spawn(async move {
            ///     let mut update_stream = updater.runtime_updates().await.unwrap();
            ///
            ///     while let Some(Ok(update)) = update_stream.next().await {
            ///         let version = update.runtime_version().spec_version;
            ///
            ///         match updater.apply_update(update) {
            ///             Ok(()) => {
            ///                 println!("Upgrade to version: {} successful", version)
            ///             }
            ///             Err(e) => {
            ///                println!("Upgrade to version {} failed {:?}", version, e);
            ///             }
            ///        };
            ///     }
            /// });
            /// # }
            /// ```
            pub fn updater(&self) -> ClientRuntimeUpdater<T> {
                ClientRuntimeUpdater(self.clone())
            }
            /// Return the [`Metadata`] used in this client.
            pub fn metadata(&self) -> Metadata {
                let inner = self.inner.read().expect("shouldn't be poisoned");
                inner.metadata.clone()
            }
            /// Change the [`Metadata`] used in this client.
            ///
            /// # Warning
            ///
            /// Setting custom metadata may leave Subxt unable to work with certain blocks,
            /// subscribe to latest blocks or submit valid transactions.
            pub fn set_metadata(&self, metadata: impl Into<Metadata>) {
                let mut inner = self.inner.write().expect("shouldn't be poisoned");
                inner.metadata = metadata.into();
            }
            /// Return the genesis hash.
            pub fn genesis_hash(&self) -> T::Hash {
                let inner = self.inner.read().expect("shouldn't be poisoned");
                inner.genesis_hash
            }
            /// Change the genesis hash used in this client.
            ///
            /// # Warning
            ///
            /// Setting a custom genesis hash may leave Subxt unable to
            /// submit valid transactions.
            pub fn set_genesis_hash(&self, genesis_hash: T::Hash) {
                let mut inner = self.inner.write().expect("shouldn't be poisoned");
                inner.genesis_hash = genesis_hash;
            }
            /// Return the runtime version.
            pub fn runtime_version(&self) -> RuntimeVersion {
                let inner = self.inner.read().expect("shouldn't be poisoned");
                inner.runtime_version.clone()
            }
            /// Change the [`RuntimeVersion`] used in this client.
            ///
            /// # Warning
            ///
            /// Setting a custom runtime version may leave Subxt unable to
            /// submit valid transactions.
            pub fn set_runtime_version(&self, runtime_version: RuntimeVersion) {
                let mut inner = self.inner.write().expect("shouldn't be poisoned");
                inner.runtime_version = runtime_version;
            }
            /// Return an RPC client to make raw requests with.
            pub fn backend(&self) -> &dyn Backend<T> {
                &*self.backend
            }
            /// Return an offline client with the same configuration as this.
            pub fn offline(&self) -> OfflineClient<T> {
                let inner = self.inner.read().expect("shouldn't be poisoned");
                OfflineClient::new(
                    inner.genesis_hash,
                    inner.runtime_version.clone(),
                    inner.metadata.clone(),
                )
            }
            /// Work with transactions.
            pub fn tx(&self) -> TxClient<T, Self> {
                <Self as OfflineClientT<T>>::tx(self)
            }
            /// Work with events.
            pub fn events(&self) -> EventsClient<T, Self> {
                <Self as OfflineClientT<T>>::events(self)
            }
            /// Work with storage.
            pub fn storage(&self) -> StorageClient<T, Self> {
                <Self as OfflineClientT<T>>::storage(self)
            }
            /// Access constants.
            pub fn constants(&self) -> ConstantsClient<T, Self> {
                <Self as OfflineClientT<T>>::constants(self)
            }
            /// Access custom types.
            pub fn custom_values(&self) -> CustomValuesClient<T, Self> {
                <Self as OfflineClientT<T>>::custom_values(self)
            }
            /// Work with blocks.
            pub fn blocks(&self) -> BlocksClient<T, Self> {
                <Self as OfflineClientT<T>>::blocks(self)
            }
            /// Work with runtime API.
            pub fn runtime_api(&self) -> RuntimeApiClient<T, Self> {
                <Self as OfflineClientT<T>>::runtime_api(self)
            }
        }
        impl<T: Config> OfflineClientT<T> for OnlineClient<T> {
            fn metadata(&self) -> Metadata {
                self.metadata()
            }
            fn genesis_hash(&self) -> T::Hash {
                self.genesis_hash()
            }
            fn runtime_version(&self) -> RuntimeVersion {
                self.runtime_version()
            }
        }
        impl<T: Config> OnlineClientT<T> for OnlineClient<T> {
            fn backend(&self) -> &dyn Backend<T> {
                &*self.backend
            }
        }
        /// Client wrapper for performing runtime updates. See [`OnlineClient::updater()`]
        /// for example usage.
        pub struct ClientRuntimeUpdater<T: Config>(OnlineClient<T>);
        impl<T: Config> ClientRuntimeUpdater<T> {
            fn is_runtime_version_different(&self, new: &RuntimeVersion) -> bool {
                let curr = self.0.inner.read().expect("shouldn't be poisoned");
                &curr.runtime_version != new
            }
            fn do_update(&self, update: Update) {
                let mut writable = self.0.inner.write().expect("shouldn't be poisoned");
                writable.metadata = update.metadata;
                writable.runtime_version = update.runtime_version;
            }
            /// Tries to apply a new update.
            pub fn apply_update(&self, update: Update) -> Result<(), UpgradeError> {
                if !self.is_runtime_version_different(&update.runtime_version) {
                    return Err(UpgradeError::SameVersion);
                }
                self.do_update(update);
                Ok(())
            }
            /// Performs runtime updates indefinitely unless encountering an error.
            ///
            /// *Note:* This will run indefinitely until it errors, so the typical usage
            /// would be to run it in a separate background task.
            pub async fn perform_runtime_updates(&self) -> Result<(), Error> {
                let mut runtime_version_stream = self.runtime_updates().await?;
                while let Some(update) = runtime_version_stream.next().await {
                    let update = update?;
                    let _ = self.apply_update(update);
                }
                Ok(())
            }
            /// Low-level API to get runtime updates as a stream but it's doesn't check if the
            /// runtime version is newer or updates the runtime.
            ///
            /// Instead that's up to the user of this API to decide when to update and
            /// to perform the actual updating.
            pub async fn runtime_updates(
                &self,
            ) -> Result<RuntimeUpdaterStream<T>, Error> {
                let stream = self.0.backend().stream_runtime_version().await?;
                Ok(RuntimeUpdaterStream {
                    stream,
                    client: self.0.clone(),
                })
            }
        }
        /// Stream to perform runtime upgrades.
        pub struct RuntimeUpdaterStream<T: Config> {
            stream: StreamOfResults<RuntimeVersion>,
            client: OnlineClient<T>,
        }
        impl<T: Config> RuntimeUpdaterStream<T> {
            /// Wait for the next runtime update.
            pub async fn next(&mut self) -> Option<Result<Update, Error>> {
                let runtime_version = match self.stream.next().await? {
                    Ok(runtime_version) => runtime_version,
                    Err(err) => return Some(Err(err)),
                };
                let at = match wait_runtime_upgrade_in_finalized_block(
                        &self.client,
                        &runtime_version,
                    )
                    .await?
                {
                    Ok(at) => at,
                    Err(err) => return Some(Err(err)),
                };
                let metadata = match OnlineClient::fetch_metadata(
                        self.client.backend(),
                        at.hash(),
                    )
                    .await
                {
                    Ok(metadata) => metadata,
                    Err(err) => return Some(Err(err)),
                };
                Some(
                    Ok(Update {
                        metadata,
                        runtime_version,
                    }),
                )
            }
        }
        /// Error that can occur during upgrade.
        #[non_exhaustive]
        pub enum UpgradeError {
            /// The version is the same as the current version.
            SameVersion,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UpgradeError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "SameVersion")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for UpgradeError {
            #[inline]
            fn clone(&self) -> UpgradeError {
                UpgradeError::SameVersion
            }
        }
        /// Represents the state when a runtime upgrade occurred.
        pub struct Update {
            runtime_version: RuntimeVersion,
            metadata: Metadata,
        }
        impl Update {
            /// Get the runtime version.
            pub fn runtime_version(&self) -> &RuntimeVersion {
                &self.runtime_version
            }
            /// Get the metadata.
            pub fn metadata(&self) -> &Metadata {
                &self.metadata
            }
        }
        /// Helper to wait until the runtime upgrade is applied on at finalized block.
        async fn wait_runtime_upgrade_in_finalized_block<T: Config>(
            client: &OnlineClient<T>,
            runtime_version: &RuntimeVersion,
        ) -> Option<Result<BlockRef<T::Hash>, Error>> {
            use scale_value::At;
            let mut block_sub = match client
                .backend()
                .stream_finalized_block_headers()
                .await
            {
                Ok(s) => s,
                Err(err) => return Some(Err(err)),
            };
            let block_ref = loop {
                let (_, block_ref) = match block_sub.next().await? {
                    Ok(n) => n,
                    Err(err) => return Some(Err(err)),
                };
                let key: Vec<scale_value::Value> = ::alloc::vec::Vec::new();
                let addr = crate::dynamic::storage("System", "LastRuntimeUpgrade", key);
                let chunk = match client
                    .storage()
                    .at(block_ref.hash())
                    .fetch(&addr)
                    .await
                {
                    Ok(Some(v)) => v,
                    Ok(None) => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!("The storage item `system::lastRuntimeUpgrade` should always exist")
                            ),
                        );
                    }
                    Err(e) => return Some(Err(e)),
                };
                let scale_val = match chunk.to_value() {
                    Ok(v) => v,
                    Err(e) => return Some(Err(e)),
                };
                let Some(Ok(spec_version)) = scale_val
                    .at("spec_version")
                    .and_then(|v| v.as_u128())
                    .map(u32::try_from) else {
                return Some(
                    Err(
                        Error::Other(
                            "Decoding `RuntimeVersion::spec_version` as u32 failed"
                                .to_string(),
                        ),
                    ),
                );
            };
                if spec_version == runtime_version.spec_version {
                    break block_ref;
                }
            };
            Some(Ok(block_ref))
        }
    }
    pub use offline_client::{OfflineClient, OfflineClientT};
    pub use online_client::{
        ClientRuntimeUpdater, OnlineClient, OnlineClientT, RuntimeUpdaterStream, Update,
        UpgradeError,
    };
}
pub mod config {
    //! This module provides a [`Config`] type, which is used to define various
    //! types that are important in order to speak to a particular chain.
    //! [`SubstrateConfig`] provides a default set of these types suitable for the
    //! default Substrate node implementation, and [`PolkadotConfig`] for a
    //! Polkadot node.
    mod default_extrinsic_params {
        use super::{signed_extensions, ExtrinsicParams};
        use super::{Config, Header};
        /// The default [`super::ExtrinsicParams`] implementation understands common signed extensions
        /// and how to apply them to a given chain.
        pub type DefaultExtrinsicParams<T> = signed_extensions::AnyOf<
            T,
            (
                signed_extensions::CheckSpecVersion,
                signed_extensions::CheckTxVersion,
                signed_extensions::CheckNonce,
                signed_extensions::CheckGenesis<T>,
                signed_extensions::CheckMortality<T>,
                signed_extensions::ChargeAssetTxPayment<T>,
                signed_extensions::ChargeTransactionPayment,
            ),
        >;
        /// A builder that outputs the set of [`super::ExtrinsicParams::OtherParams`] required for
        /// [`DefaultExtrinsicParams`]. This may expose methods that aren't applicable to the current
        /// chain; such values will simply be ignored if so.
        pub struct DefaultExtrinsicParamsBuilder<T: Config> {
            /// `None` means the tx will be immortal.
            mortality: Option<Mortality<T::Hash>>,
            /// `None` means we'll use the native token.
            tip_of_asset_id: Option<T::AssetId>,
            tip: u128,
            tip_of: u128,
        }
        struct Mortality<Hash> {
            /// Block hash that mortality starts from
            checkpoint_hash: Hash,
            /// Block number that mortality starts from (must
            checkpoint_number: u64,
            /// How many blocks the tx is mortal for
            period: u64,
        }
        impl<T: Config> Default for DefaultExtrinsicParamsBuilder<T> {
            fn default() -> Self {
                Self {
                    mortality: None,
                    tip: 0,
                    tip_of: 0,
                    tip_of_asset_id: None,
                }
            }
        }
        impl<T: Config> DefaultExtrinsicParamsBuilder<T> {
            /// Configure new extrinsic params. We default to providing no tip
            /// and using an immortal transaction unless otherwise configured
            pub fn new() -> Self {
                Default::default()
            }
            /// Make the transaction mortal, given a block header that it should be mortal from,
            /// and the number of blocks (roughly; it'll be rounded to a power of two) that it will
            /// be mortal for.
            pub fn mortal(mut self, from_block: &T::Header, for_n_blocks: u64) -> Self {
                self
                    .mortality = Some(Mortality {
                    checkpoint_hash: from_block.hash(),
                    checkpoint_number: from_block.number().into(),
                    period: for_n_blocks,
                });
                self
            }
            /// Make the transaction mortal, given a block number and block hash (which must both point to
            /// the same block) that it should be mortal from, and the number of blocks (roughly; it'll be
            /// rounded to a power of two) that it will be mortal for.
            ///
            /// Prefer to use [`DefaultExtrinsicParamsBuilder::mortal()`], which ensures that the block hash
            /// and number align.
            pub fn mortal_unchecked(
                mut self,
                from_block_number: u64,
                from_block_hash: T::Hash,
                for_n_blocks: u64,
            ) -> Self {
                self
                    .mortality = Some(Mortality {
                    checkpoint_hash: from_block_hash,
                    checkpoint_number: from_block_number,
                    period: for_n_blocks,
                });
                self
            }
            /// Provide a tip to the block author in the chain's native token.
            pub fn tip(mut self, tip: u128) -> Self {
                self.tip = tip;
                self.tip_of = tip;
                self.tip_of_asset_id = None;
                self
            }
            /// Provide a tip to the block author using the token denominated by the `asset_id` provided. This
            /// is not applicable on chains which don't use the `ChargeAssetTxPayment` signed extension; in this
            /// case, no tip will be given.
            pub fn tip_of(mut self, tip: u128, asset_id: T::AssetId) -> Self {
                self.tip = 0;
                self.tip_of = tip;
                self.tip_of_asset_id = Some(asset_id);
                self
            }
            /// Build the extrinsic parameters.
            pub fn build(
                self,
            ) -> <DefaultExtrinsicParams<T> as ExtrinsicParams<T>>::OtherParams {
                let check_mortality_params = if let Some(mortality) = self.mortality {
                    signed_extensions::CheckMortalityParams::mortal(
                        mortality.period,
                        mortality.checkpoint_number,
                        mortality.checkpoint_hash,
                    )
                } else {
                    signed_extensions::CheckMortalityParams::immortal()
                };
                let charge_asset_tx_params = if let Some(asset_id) = self.tip_of_asset_id
                {
                    signed_extensions::ChargeAssetTxPaymentParams::tip_of(
                        self.tip,
                        asset_id,
                    )
                } else {
                    signed_extensions::ChargeAssetTxPaymentParams::tip(self.tip)
                };
                let charge_transaction_params = signed_extensions::ChargeTransactionPaymentParams::tip(
                    self.tip,
                );
                (
                    (),
                    (),
                    (),
                    (),
                    check_mortality_params,
                    charge_asset_tx_params,
                    charge_transaction_params,
                )
            }
        }
    }
    mod extrinsic_params {
        //! This module contains a trait which controls the parameters that must
        //! be provided in order to successfully construct an extrinsic.
        //! [`crate::config::DefaultExtrinsicParams`] provides a general-purpose
        //! implementation of this that will work in many cases.
        use crate::{client::OfflineClientT, Config};
        use core::fmt::Debug;
        /// An error that can be emitted when trying to construct an instance of [`ExtrinsicParams`],
        /// encode data from the instance, or match on signed extensions.
        #[non_exhaustive]
        pub enum ExtrinsicParamsError {
            /// Cannot find a type id in the metadata. The context provides some additional
            /// information about the source of the error (eg the signed extension name).
            #[error(
                "Cannot find type id '{type_id} in the metadata (context: {context})"
            )]
            MissingTypeId {
                /// Type ID.
                type_id: u32,
                /// Some arbitrary context to help narrow the source of the error.
                context: &'static str,
            },
            /// A signed extension in use on some chain was not provided.
            #[error(
                "The chain expects a signed extension with the name {0}, but we did not provide one"
            )]
            UnknownSignedExtension(String),
            /// Some custom error.
            #[error("Error constructing extrinsic parameters: {0}")]
            Custom(CustomExtrinsicParamsError),
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for ExtrinsicParamsError {}
        #[allow(unused_qualifications)]
        impl ::core::fmt::Display for ExtrinsicParamsError {
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                use thiserror::__private::AsDisplay as _;
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    ExtrinsicParamsError::MissingTypeId { type_id, context } => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "Cannot find type id \'{0} in the metadata (context: {1})",
                                    type_id.as_display(), context.as_display()
                                ),
                            )
                    }
                    ExtrinsicParamsError::UnknownSignedExtension(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "The chain expects a signed extension with the name {0}, but we did not provide one",
                                    _0.as_display()
                                ),
                            )
                    }
                    ExtrinsicParamsError::Custom(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "Error constructing extrinsic parameters: {0}", _0
                                    .as_display()
                                ),
                            )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ExtrinsicParamsError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ExtrinsicParamsError::MissingTypeId {
                        type_id: __self_0,
                        context: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "MissingTypeId",
                            "type_id",
                            __self_0,
                            "context",
                            &__self_1,
                        )
                    }
                    ExtrinsicParamsError::UnknownSignedExtension(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "UnknownSignedExtension",
                            &__self_0,
                        )
                    }
                    ExtrinsicParamsError::Custom(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Custom",
                            &__self_0,
                        )
                    }
                }
            }
        }
        /// A custom error.
        pub type CustomExtrinsicParamsError = Box<
            dyn std::error::Error + Send + Sync + 'static,
        >;
        impl From<std::convert::Infallible> for ExtrinsicParamsError {
            fn from(value: std::convert::Infallible) -> Self {
                match value {}
            }
        }
        impl From<CustomExtrinsicParamsError> for ExtrinsicParamsError {
            fn from(value: CustomExtrinsicParamsError) -> Self {
                ExtrinsicParamsError::Custom(value)
            }
        }
        /// This trait allows you to configure the "signed extra" and
        /// "additional" parameters that are a part of the transaction payload
        /// or the signer payload respectively.
        pub trait ExtrinsicParams<T: Config>: ExtrinsicParamsEncoder + Sized + 'static {
            /// These parameters can be provided to the constructor along with
            /// some default parameters that `subxt` understands, in order to
            /// help construct your [`ExtrinsicParams`] object.
            type OtherParams;
            /// Construct a new instance of our [`ExtrinsicParams`].
            fn new<Client: OfflineClientT<T>>(
                nonce: u64,
                client: Client,
                other_params: Self::OtherParams,
            ) -> Result<Self, ExtrinsicParamsError>;
        }
        /// This trait is expected to be implemented for any [`ExtrinsicParams`], and
        /// defines how to encode the "additional" and "extra" params. Both functions
        /// are optional and will encode nothing by default.
        pub trait ExtrinsicParamsEncoder: 'static {
            /// This is expected to SCALE encode the "signed extra" parameters
            /// to some buffer that has been provided. These are the parameters
            /// which are sent along with the transaction, as well as taken into
            /// account when signing the transaction.
            fn encode_extra_to(&self, _v: &mut Vec<u8>) {}
            /// This is expected to SCALE encode the "additional" parameters
            /// to some buffer that has been provided. These parameters are _not_
            /// sent along with the transaction, but are taken into account when
            /// signing it, meaning the client and node must agree on their values.
            fn encode_additional_to(&self, _v: &mut Vec<u8>) {}
        }
    }
    pub mod polkadot {
        //! Polkadot specific configuration
        use super::{Config, DefaultExtrinsicParams, DefaultExtrinsicParamsBuilder};
        pub use crate::utils::{AccountId32, MultiAddress, MultiSignature};
        use crate::SubstrateConfig;
        pub use primitive_types::{H256, U256};
        /// Default set of commonly used types by Polkadot nodes.
        pub enum PolkadotConfig {}
        impl Config for PolkadotConfig {
            type Hash = <SubstrateConfig as Config>::Hash;
            type AccountId = <SubstrateConfig as Config>::AccountId;
            type Address = MultiAddress<Self::AccountId, ()>;
            type Signature = <SubstrateConfig as Config>::Signature;
            type Hasher = <SubstrateConfig as Config>::Hasher;
            type Header = <SubstrateConfig as Config>::Header;
            type ExtrinsicParams = PolkadotExtrinsicParams<Self>;
            type AssetId = u32;
        }
        /// A struct representing the signed extra and additional parameters required
        /// to construct a transaction for a polkadot node.
        pub type PolkadotExtrinsicParams<T> = DefaultExtrinsicParams<T>;
        /// A builder which leads to [`PolkadotExtrinsicParams`] being constructed.
        /// This is what you provide to methods like `sign_and_submit()`.
        pub type PolkadotExtrinsicParamsBuilder<T> = DefaultExtrinsicParamsBuilder<T>;
    }
    pub mod signed_extensions {
        //! This module contains implementations for common signed extensions, each
        //! of which implements [`SignedExtension`], and can be used in conjunction with
        //! [`AnyOf`] to configure the set of signed extensions which are known about
        //! when interacting with a chain.
        use super::extrinsic_params::{
            ExtrinsicParams, ExtrinsicParamsEncoder, ExtrinsicParamsError,
        };
        use crate::utils::Era;
        use crate::{client::OfflineClientT, Config};
        use codec::{Compact, Encode};
        use core::fmt::Debug;
        use derivative::Derivative;
        use scale_decode::DecodeAsType;
        use scale_info::PortableRegistry;
        use std::collections::HashMap;
        /// A single [`SignedExtension`] has a unique name, but is otherwise the
        /// same as [`ExtrinsicParams`] in describing how to encode the extra and
        /// additional data.
        pub trait SignedExtension<T: Config>: ExtrinsicParams<T> {
            /// The type representing the `extra` bytes of a signed extension.
            /// Decoding from this type should be symmetrical to the respective
            /// `ExtrinsicParamsEncoder::encode_extra_to()` implementation of this signed extension.
            type Decoded: DecodeAsType;
            /// This should return true if the signed extension matches the details given.
            /// Often, this will involve just checking that the identifier given matches that of the
            /// extension in question.
            fn matches(
                identifier: &str,
                _type_id: u32,
                _types: &PortableRegistry,
            ) -> bool;
        }
        /// The [`CheckSpecVersion`] signed extension.
        pub struct CheckSpecVersion(u32);
        impl<T: Config> ExtrinsicParams<T> for CheckSpecVersion {
            type OtherParams = ();
            fn new<Client: OfflineClientT<T>>(
                _nonce: u64,
                client: Client,
                _other_params: Self::OtherParams,
            ) -> Result<Self, ExtrinsicParamsError> {
                Ok(CheckSpecVersion(client.runtime_version().spec_version))
            }
        }
        impl ExtrinsicParamsEncoder for CheckSpecVersion {
            fn encode_additional_to(&self, v: &mut Vec<u8>) {
                self.0.encode_to(v);
            }
        }
        impl<T: Config> SignedExtension<T> for CheckSpecVersion {
            type Decoded = ();
            fn matches(
                identifier: &str,
                _type_id: u32,
                _types: &PortableRegistry,
            ) -> bool {
                identifier == "CheckSpecVersion"
            }
        }
        /// The [`CheckNonce`] signed extension.
        pub struct CheckNonce(Compact<u64>);
        impl<T: Config> ExtrinsicParams<T> for CheckNonce {
            type OtherParams = ();
            fn new<Client: OfflineClientT<T>>(
                nonce: u64,
                _client: Client,
                _other_params: Self::OtherParams,
            ) -> Result<Self, ExtrinsicParamsError> {
                Ok(CheckNonce(Compact(nonce)))
            }
        }
        impl ExtrinsicParamsEncoder for CheckNonce {
            fn encode_extra_to(&self, v: &mut Vec<u8>) {
                self.0.encode_to(v);
            }
        }
        impl<T: Config> SignedExtension<T> for CheckNonce {
            type Decoded = u64;
            fn matches(
                identifier: &str,
                _type_id: u32,
                _types: &PortableRegistry,
            ) -> bool {
                identifier == "CheckNonce"
            }
        }
        /// The [`CheckTxVersion`] signed extension.
        pub struct CheckTxVersion(u32);
        impl<T: Config> ExtrinsicParams<T> for CheckTxVersion {
            type OtherParams = ();
            fn new<Client: OfflineClientT<T>>(
                _nonce: u64,
                client: Client,
                _other_params: Self::OtherParams,
            ) -> Result<Self, ExtrinsicParamsError> {
                Ok(CheckTxVersion(client.runtime_version().transaction_version))
            }
        }
        impl ExtrinsicParamsEncoder for CheckTxVersion {
            fn encode_additional_to(&self, v: &mut Vec<u8>) {
                self.0.encode_to(v);
            }
        }
        impl<T: Config> SignedExtension<T> for CheckTxVersion {
            type Decoded = ();
            fn matches(
                identifier: &str,
                _type_id: u32,
                _types: &PortableRegistry,
            ) -> bool {
                identifier == "CheckTxVersion"
            }
        }
        /// The [`CheckGenesis`] signed extension.
        pub struct CheckGenesis<T: Config>(T::Hash);
        impl<T: Config> ExtrinsicParams<T> for CheckGenesis<T> {
            type OtherParams = ();
            fn new<Client: OfflineClientT<T>>(
                _nonce: u64,
                client: Client,
                _other_params: Self::OtherParams,
            ) -> Result<Self, ExtrinsicParamsError> {
                Ok(CheckGenesis(client.genesis_hash()))
            }
        }
        impl<T: Config> ExtrinsicParamsEncoder for CheckGenesis<T> {
            fn encode_additional_to(&self, v: &mut Vec<u8>) {
                self.0.encode_to(v);
            }
        }
        impl<T: Config> SignedExtension<T> for CheckGenesis<T> {
            type Decoded = ();
            fn matches(
                identifier: &str,
                _type_id: u32,
                _types: &PortableRegistry,
            ) -> bool {
                identifier == "CheckGenesis"
            }
        }
        /// The [`CheckMortality`] signed extension.
        pub struct CheckMortality<T: Config> {
            era: Era,
            checkpoint: T::Hash,
        }
        /// Parameters to configure the [`CheckMortality`] signed extension.
        pub struct CheckMortalityParams<T: Config> {
            era: Era,
            checkpoint: Option<T::Hash>,
        }
        impl<T: Config> Default for CheckMortalityParams<T> {
            fn default() -> Self {
                Self {
                    era: Default::default(),
                    checkpoint: Default::default(),
                }
            }
        }
        impl<T: Config> CheckMortalityParams<T> {
            /// Configure a mortal transaction. The `period` is (roughly) how many
            /// blocks the transaction will be valid for. The `block_number` and
            /// `block_hash` should both point to the same block, and are the block that
            /// the transaction is mortal from.
            pub fn mortal(period: u64, block_number: u64, block_hash: T::Hash) -> Self {
                CheckMortalityParams {
                    era: Era::mortal(period, block_number),
                    checkpoint: Some(block_hash),
                }
            }
            /// An immortal transaction.
            pub fn immortal() -> Self {
                CheckMortalityParams {
                    era: Era::Immortal,
                    checkpoint: None,
                }
            }
        }
        impl<T: Config> ExtrinsicParams<T> for CheckMortality<T> {
            type OtherParams = CheckMortalityParams<T>;
            fn new<Client: OfflineClientT<T>>(
                _nonce: u64,
                client: Client,
                other_params: Self::OtherParams,
            ) -> Result<Self, ExtrinsicParamsError> {
                Ok(CheckMortality {
                    era: other_params.era,
                    checkpoint: other_params.checkpoint.unwrap_or(client.genesis_hash()),
                })
            }
        }
        impl<T: Config> ExtrinsicParamsEncoder for CheckMortality<T> {
            fn encode_extra_to(&self, v: &mut Vec<u8>) {
                self.era.encode_to(v);
            }
            fn encode_additional_to(&self, v: &mut Vec<u8>) {
                self.checkpoint.encode_to(v);
            }
        }
        impl<T: Config> SignedExtension<T> for CheckMortality<T> {
            type Decoded = Era;
            fn matches(
                identifier: &str,
                _type_id: u32,
                _types: &PortableRegistry,
            ) -> bool {
                identifier == "CheckMortality"
            }
        }
        /// The [`ChargeAssetTxPayment`] signed extension.
        #[derivative(
            Clone(bound = "T::AssetId: Clone"),
            Debug(bound = "T::AssetId: Debug")
        )]
        #[decode_as_type(trait_bounds = "T::AssetId: DecodeAsType")]
        pub struct ChargeAssetTxPayment<T: Config> {
            tip: Compact<u128>,
            asset_id: Option<T::AssetId>,
        }
        #[allow(unused_qualifications)]
        impl<T: Config> ::std::clone::Clone for ChargeAssetTxPayment<T>
        where
            T::AssetId: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    ChargeAssetTxPayment { tip: ref __arg_0, asset_id: ref __arg_1 } => {
                        ChargeAssetTxPayment {
                            tip: (*__arg_0).clone(),
                            asset_id: (*__arg_1).clone(),
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<T: Config> ::std::fmt::Debug for ChargeAssetTxPayment<T>
        where
            T::AssetId: Debug,
        {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    ChargeAssetTxPayment { tip: ref __arg_0, asset_id: ref __arg_1 } => {
                        let mut __debug_trait_builder = __f
                            .debug_struct("ChargeAssetTxPayment");
                        let _ = __debug_trait_builder.field("tip", &&(*__arg_0));
                        let _ = __debug_trait_builder.field("asset_id", &&(*__arg_1));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        const _: () = {
            pub struct Visitor<T: Config>(::core::marker::PhantomData<(T,)>);
            use ::scale_decode::vec;
            use ::scale_decode::ToString;
            impl<T: Config> ::scale_decode::IntoVisitor for ChargeAssetTxPayment<T>
            where
                T::AssetId: DecodeAsType,
            {
                type Visitor = Visitor<T>;
                fn into_visitor() -> Self::Visitor {
                    Visitor(::core::marker::PhantomData)
                }
            }
            impl<T: Config> ::scale_decode::Visitor for Visitor<T>
            where
                T::AssetId: DecodeAsType,
            {
                type Error = ::scale_decode::Error;
                type Value<'scale, 'info> = ChargeAssetTxPayment<T>;
                fn visit_composite<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Composite<'scale, 'info>,
                    type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.has_unnamed_fields() {
                        return self.visit_tuple(&mut value.as_tuple(), type_id);
                    }
                    let vals: ::scale_decode::BTreeMap<Option<&str>, _> = value
                        .map(|res| res.map(|item| (item.name(), item)))
                        .collect::<Result<_, _>>()?;
                    Ok(ChargeAssetTxPayment {
                        tip: {
                            let val = *vals
                                .get(&Some("tip"))
                                .ok_or_else(|| ::scale_decode::Error::new(::scale_decode::error::ErrorKind::CannotFindField {
                                    name: "tip".to_string(),
                                }))?;
                            val.decode_as_type().map_err(|e| e.at_field("tip"))?
                        },
                        asset_id: {
                            let val = *vals
                                .get(&Some("asset_id"))
                                .ok_or_else(|| ::scale_decode::Error::new(::scale_decode::error::ErrorKind::CannotFindField {
                                    name: "asset_id".to_string(),
                                }))?;
                            val.decode_as_type().map_err(|e| e.at_field("asset_id"))?
                        },
                    })
                }
                fn visit_tuple<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Tuple<'scale, 'info>,
                    type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 2usize {
                        return Err(
                            ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                actual_len: value.remaining(),
                                expected_len: 2usize,
                            }),
                        );
                    }
                    let vals = value;
                    Ok(ChargeAssetTxPayment {
                        tip: {
                            let val = vals
                                .next()
                                .expect(
                                    "field count should have been checked already on tuple type; please file a bug report",
                                )?;
                            val.decode_as_type().map_err(|e| e.at_field("tip"))?
                        },
                        asset_id: {
                            let val = vals
                                .next()
                                .expect(
                                    "field count should have been checked already on tuple type; please file a bug report",
                                )?;
                            val.decode_as_type().map_err(|e| e.at_field("asset_id"))?
                        },
                    })
                }
            }
            impl<T: Config> ::scale_decode::DecodeAsFields for ChargeAssetTxPayment<T>
            where
                T::AssetId: DecodeAsType,
            {
                fn decode_as_fields<'info>(
                    input: &mut &[u8],
                    fields: &mut dyn ::scale_decode::FieldIter<'info>,
                    types: &'info ::scale_decode::PortableRegistry,
                ) -> Result<Self, ::scale_decode::Error> {
                    let path = ::scale_decode::EMPTY_SCALE_INFO_PATH;
                    let mut composite = ::scale_decode::visitor::types::Composite::new(
                        input,
                        path,
                        fields,
                        types,
                        false,
                    );
                    use ::scale_decode::{Visitor, IntoVisitor};
                    let val = <ChargeAssetTxPayment<T>>::into_visitor()
                        .visit_composite(
                            &mut composite,
                            ::scale_decode::visitor::TypeId(0),
                        );
                    composite.skip_decoding()?;
                    *input = composite.bytes_from_undecoded();
                    val.map_err(From::from)
                }
            }
        };
        impl<T: Config> ChargeAssetTxPayment<T> {
            /// Tip to the extrinsic author in the native chain token.
            pub fn tip(&self) -> u128 {
                self.tip.0
            }
            /// Tip to the extrinsic author using the asset ID given.
            pub fn asset_id(&self) -> Option<&T::AssetId> {
                self.asset_id.as_ref()
            }
        }
        /// Parameters to configure the [`ChargeAssetTxPayment`] signed extension.
        pub struct ChargeAssetTxPaymentParams<T: Config> {
            tip: u128,
            asset_id: Option<T::AssetId>,
        }
        impl<T: Config> Default for ChargeAssetTxPaymentParams<T> {
            fn default() -> Self {
                ChargeAssetTxPaymentParams {
                    tip: Default::default(),
                    asset_id: Default::default(),
                }
            }
        }
        impl<T: Config> ChargeAssetTxPaymentParams<T> {
            /// Don't provide a tip to the extrinsic author.
            pub fn no_tip() -> Self {
                ChargeAssetTxPaymentParams {
                    tip: 0,
                    asset_id: None,
                }
            }
            /// Tip the extrinsic author in the native chain token.
            pub fn tip(tip: u128) -> Self {
                ChargeAssetTxPaymentParams {
                    tip,
                    asset_id: None,
                }
            }
            /// Tip the extrinsic author using the asset ID given.
            pub fn tip_of(tip: u128, asset_id: T::AssetId) -> Self {
                ChargeAssetTxPaymentParams {
                    tip,
                    asset_id: Some(asset_id),
                }
            }
        }
        impl<T: Config> ExtrinsicParams<T> for ChargeAssetTxPayment<T> {
            type OtherParams = ChargeAssetTxPaymentParams<T>;
            fn new<Client: OfflineClientT<T>>(
                _nonce: u64,
                _client: Client,
                other_params: Self::OtherParams,
            ) -> Result<Self, ExtrinsicParamsError> {
                Ok(ChargeAssetTxPayment {
                    tip: Compact(other_params.tip),
                    asset_id: other_params.asset_id,
                })
            }
        }
        impl<T: Config> ExtrinsicParamsEncoder for ChargeAssetTxPayment<T> {
            fn encode_extra_to(&self, v: &mut Vec<u8>) {
                (self.tip, &self.asset_id).encode_to(v);
            }
        }
        impl<T: Config> SignedExtension<T> for ChargeAssetTxPayment<T> {
            type Decoded = Self;
            fn matches(
                identifier: &str,
                _type_id: u32,
                _types: &PortableRegistry,
            ) -> bool {
                identifier == "ChargeAssetTxPayment"
            }
        }
        /// The [`ChargeTransactionPayment`] signed extension.
        pub struct ChargeTransactionPayment {
            tip: Compact<u128>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ChargeTransactionPayment {
            #[inline]
            fn clone(&self) -> ChargeTransactionPayment {
                ChargeTransactionPayment {
                    tip: ::core::clone::Clone::clone(&self.tip),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ChargeTransactionPayment {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ChargeTransactionPayment",
                    "tip",
                    &&self.tip,
                )
            }
        }
        const _: () = {
            pub struct Visitor(::core::marker::PhantomData<()>);
            use ::scale_decode::vec;
            use ::scale_decode::ToString;
            impl ::scale_decode::IntoVisitor for ChargeTransactionPayment {
                type Visitor = Visitor;
                fn into_visitor() -> Self::Visitor {
                    Visitor(::core::marker::PhantomData)
                }
            }
            impl ::scale_decode::Visitor for Visitor {
                type Error = ::scale_decode::Error;
                type Value<'scale, 'info> = ChargeTransactionPayment;
                fn visit_composite<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Composite<'scale, 'info>,
                    type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.has_unnamed_fields() {
                        return self.visit_tuple(&mut value.as_tuple(), type_id);
                    }
                    let vals: ::scale_decode::BTreeMap<Option<&str>, _> = value
                        .map(|res| res.map(|item| (item.name(), item)))
                        .collect::<Result<_, _>>()?;
                    Ok(ChargeTransactionPayment {
                        tip: {
                            let val = *vals
                                .get(&Some("tip"))
                                .ok_or_else(|| ::scale_decode::Error::new(::scale_decode::error::ErrorKind::CannotFindField {
                                    name: "tip".to_string(),
                                }))?;
                            val.decode_as_type().map_err(|e| e.at_field("tip"))?
                        },
                    })
                }
                fn visit_tuple<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Tuple<'scale, 'info>,
                    type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 1usize {
                        return Err(
                            ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                actual_len: value.remaining(),
                                expected_len: 1usize,
                            }),
                        );
                    }
                    let vals = value;
                    Ok(ChargeTransactionPayment {
                        tip: {
                            let val = vals
                                .next()
                                .expect(
                                    "field count should have been checked already on tuple type; please file a bug report",
                                )?;
                            val.decode_as_type().map_err(|e| e.at_field("tip"))?
                        },
                    })
                }
            }
            impl ::scale_decode::DecodeAsFields for ChargeTransactionPayment {
                fn decode_as_fields<'info>(
                    input: &mut &[u8],
                    fields: &mut dyn ::scale_decode::FieldIter<'info>,
                    types: &'info ::scale_decode::PortableRegistry,
                ) -> Result<Self, ::scale_decode::Error> {
                    let path = ::scale_decode::EMPTY_SCALE_INFO_PATH;
                    let mut composite = ::scale_decode::visitor::types::Composite::new(
                        input,
                        path,
                        fields,
                        types,
                        false,
                    );
                    use ::scale_decode::{Visitor, IntoVisitor};
                    let val = <ChargeTransactionPayment>::into_visitor()
                        .visit_composite(
                            &mut composite,
                            ::scale_decode::visitor::TypeId(0),
                        );
                    composite.skip_decoding()?;
                    *input = composite.bytes_from_undecoded();
                    val.map_err(From::from)
                }
            }
        };
        impl ChargeTransactionPayment {
            /// Tip to the extrinsic author in the native chain token.
            pub fn tip(&self) -> u128 {
                self.tip.0
            }
        }
        /// Parameters to configure the [`ChargeTransactionPayment`] signed extension.
        pub struct ChargeTransactionPaymentParams {
            tip: u128,
        }
        #[automatically_derived]
        impl ::core::default::Default for ChargeTransactionPaymentParams {
            #[inline]
            fn default() -> ChargeTransactionPaymentParams {
                ChargeTransactionPaymentParams {
                    tip: ::core::default::Default::default(),
                }
            }
        }
        impl ChargeTransactionPaymentParams {
            /// Don't provide a tip to the extrinsic author.
            pub fn no_tip() -> Self {
                ChargeTransactionPaymentParams {
                    tip: 0,
                }
            }
            /// Tip the extrinsic author in the native chain token.
            pub fn tip(tip: u128) -> Self {
                ChargeTransactionPaymentParams {
                    tip,
                }
            }
        }
        impl<T: Config> ExtrinsicParams<T> for ChargeTransactionPayment {
            type OtherParams = ChargeTransactionPaymentParams;
            fn new<Client: OfflineClientT<T>>(
                _nonce: u64,
                _client: Client,
                other_params: Self::OtherParams,
            ) -> Result<Self, ExtrinsicParamsError> {
                Ok(ChargeTransactionPayment {
                    tip: Compact(other_params.tip),
                })
            }
        }
        impl ExtrinsicParamsEncoder for ChargeTransactionPayment {
            fn encode_extra_to(&self, v: &mut Vec<u8>) {
                self.tip.encode_to(v);
            }
        }
        impl<T: Config> SignedExtension<T> for ChargeTransactionPayment {
            type Decoded = Self;
            fn matches(
                identifier: &str,
                _type_id: u32,
                _types: &PortableRegistry,
            ) -> bool {
                identifier == "ChargeTransactionPayment"
            }
        }
        /// This accepts a tuple of [`SignedExtension`]s, and will dynamically make use of whichever
        /// ones are actually required for the chain in the correct order, ignoring the rest. This
        /// is a sensible default, and allows for a single configuration to work across multiple chains.
        pub struct AnyOf<T, Params> {
            params: Vec<Box<dyn ExtrinsicParamsEncoder>>,
            _marker: std::marker::PhantomData<(T, Params)>,
        }
        #[rustfmt::skip]
        const _: () = {
            impl<T, A> ExtrinsicParams<T> for AnyOf<T, (A,)>
            where
                T: Config,
                A: SignedExtension<T>,
            {
                type OtherParams = (A::OtherParams,);
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A> ExtrinsicParamsEncoder for AnyOf<T, (A,)>
            where
                T: Config,
                A: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B> ExtrinsicParams<T> for AnyOf<T, (A, B)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
            {
                type OtherParams = (A::OtherParams, B::OtherParams);
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B> ExtrinsicParamsEncoder for AnyOf<T, (A, B)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C> ExtrinsicParams<T> for AnyOf<T, (A, B, C)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
            {
                type OtherParams = (A::OtherParams, B::OtherParams, C::OtherParams);
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C> ExtrinsicParamsEncoder for AnyOf<T, (A, B, C)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D> ExtrinsicParams<T> for AnyOf<T, (A, B, C, D)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C, D> ExtrinsicParamsEncoder for AnyOf<T, (A, B, C, D)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E> ExtrinsicParams<T> for AnyOf<T, (A, B, C, D, E)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C, D, E> ExtrinsicParamsEncoder for AnyOf<T, (A, B, C, D, E)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E, F> ExtrinsicParams<T> for AnyOf<T, (A, B, C, D, E, F)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C, D, E, F> ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E, F, G> ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C, D, E, F, G> ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E, F, G, H> ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C, D, E, F, G, H> ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I> ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I> ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J> ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                    J::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if J::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = J::new(nonce, client.clone(), other_params.9)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J> ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J, K> ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                    J::OtherParams,
                    K::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if J::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = J::new(nonce, client.clone(), other_params.9)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if K::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = K::new(nonce, client.clone(), other_params.10)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J, K> ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J, K, L> ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                    J::OtherParams,
                    K::OtherParams,
                    L::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if J::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = J::new(nonce, client.clone(), other_params.9)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if K::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = K::new(nonce, client.clone(), other_params.10)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if L::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = L::new(nonce, client.clone(), other_params.11)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J, K, L> ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J, K, L, M> ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                    J::OtherParams,
                    K::OtherParams,
                    L::OtherParams,
                    M::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if J::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = J::new(nonce, client.clone(), other_params.9)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if K::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = K::new(nonce, client.clone(), other_params.10)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if L::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = L::new(nonce, client.clone(), other_params.11)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if M::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = M::new(nonce, client.clone(), other_params.12)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J, K, L, M> ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J, K, L, M, N> ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                    J::OtherParams,
                    K::OtherParams,
                    L::OtherParams,
                    M::OtherParams,
                    N::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if J::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = J::new(nonce, client.clone(), other_params.9)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if K::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = K::new(nonce, client.clone(), other_params.10)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if L::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = L::new(nonce, client.clone(), other_params.11)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if M::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = M::new(nonce, client.clone(), other_params.12)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if N::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = N::new(nonce, client.clone(), other_params.13)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J, K, L, M, N> ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                    J::OtherParams,
                    K::OtherParams,
                    L::OtherParams,
                    M::OtherParams,
                    N::OtherParams,
                    O::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if J::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = J::new(nonce, client.clone(), other_params.9)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if K::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = K::new(nonce, client.clone(), other_params.10)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if L::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = L::new(nonce, client.clone(), other_params.11)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if M::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = M::new(nonce, client.clone(), other_params.12)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if N::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = N::new(nonce, client.clone(), other_params.13)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if O::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = O::new(nonce, client.clone(), other_params.14)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O> ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P> ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
                P: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                    J::OtherParams,
                    K::OtherParams,
                    L::OtherParams,
                    M::OtherParams,
                    N::OtherParams,
                    O::OtherParams,
                    P::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if J::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = J::new(nonce, client.clone(), other_params.9)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if K::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = K::new(nonce, client.clone(), other_params.10)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if L::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = L::new(nonce, client.clone(), other_params.11)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if M::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = M::new(nonce, client.clone(), other_params.12)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if N::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = N::new(nonce, client.clone(), other_params.13)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if O::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = O::new(nonce, client.clone(), other_params.14)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if P::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = P::new(nonce, client.clone(), other_params.15)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<
                T,
                A,
                B,
                C,
                D,
                E,
                F,
                G,
                H,
                I,
                J,
                K,
                L,
                M,
                N,
                O,
                P,
            > ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
                P: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<T, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q> ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
                P: SignedExtension<T>,
                Q: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                    J::OtherParams,
                    K::OtherParams,
                    L::OtherParams,
                    M::OtherParams,
                    N::OtherParams,
                    O::OtherParams,
                    P::OtherParams,
                    Q::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if J::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = J::new(nonce, client.clone(), other_params.9)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if K::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = K::new(nonce, client.clone(), other_params.10)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if L::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = L::new(nonce, client.clone(), other_params.11)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if M::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = M::new(nonce, client.clone(), other_params.12)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if N::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = N::new(nonce, client.clone(), other_params.13)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if O::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = O::new(nonce, client.clone(), other_params.14)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if P::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = P::new(nonce, client.clone(), other_params.15)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if Q::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = Q::new(nonce, client.clone(), other_params.16)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<
                T,
                A,
                B,
                C,
                D,
                E,
                F,
                G,
                H,
                I,
                J,
                K,
                L,
                M,
                N,
                O,
                P,
                Q,
            > ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
                P: SignedExtension<T>,
                Q: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<
                T,
                A,
                B,
                C,
                D,
                E,
                F,
                G,
                H,
                I,
                J,
                K,
                L,
                M,
                N,
                O,
                P,
                Q,
                R,
            > ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
                P: SignedExtension<T>,
                Q: SignedExtension<T>,
                R: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                    J::OtherParams,
                    K::OtherParams,
                    L::OtherParams,
                    M::OtherParams,
                    N::OtherParams,
                    O::OtherParams,
                    P::OtherParams,
                    Q::OtherParams,
                    R::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if J::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = J::new(nonce, client.clone(), other_params.9)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if K::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = K::new(nonce, client.clone(), other_params.10)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if L::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = L::new(nonce, client.clone(), other_params.11)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if M::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = M::new(nonce, client.clone(), other_params.12)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if N::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = N::new(nonce, client.clone(), other_params.13)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if O::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = O::new(nonce, client.clone(), other_params.14)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if P::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = P::new(nonce, client.clone(), other_params.15)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if Q::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = Q::new(nonce, client.clone(), other_params.16)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if R::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = R::new(nonce, client.clone(), other_params.17)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<
                T,
                A,
                B,
                C,
                D,
                E,
                F,
                G,
                H,
                I,
                J,
                K,
                L,
                M,
                N,
                O,
                P,
                Q,
                R,
            > ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
                P: SignedExtension<T>,
                Q: SignedExtension<T>,
                R: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<
                T,
                A,
                B,
                C,
                D,
                E,
                F,
                G,
                H,
                I,
                J,
                K,
                L,
                M,
                N,
                O,
                P,
                Q,
                R,
                S,
            > ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
                P: SignedExtension<T>,
                Q: SignedExtension<T>,
                R: SignedExtension<T>,
                S: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                    J::OtherParams,
                    K::OtherParams,
                    L::OtherParams,
                    M::OtherParams,
                    N::OtherParams,
                    O::OtherParams,
                    P::OtherParams,
                    Q::OtherParams,
                    R::OtherParams,
                    S::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if J::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = J::new(nonce, client.clone(), other_params.9)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if K::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = K::new(nonce, client.clone(), other_params.10)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if L::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = L::new(nonce, client.clone(), other_params.11)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if M::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = M::new(nonce, client.clone(), other_params.12)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if N::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = N::new(nonce, client.clone(), other_params.13)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if O::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = O::new(nonce, client.clone(), other_params.14)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if P::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = P::new(nonce, client.clone(), other_params.15)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if Q::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = Q::new(nonce, client.clone(), other_params.16)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if R::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = R::new(nonce, client.clone(), other_params.17)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if S::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = S::new(nonce, client.clone(), other_params.18)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<
                T,
                A,
                B,
                C,
                D,
                E,
                F,
                G,
                H,
                I,
                J,
                K,
                L,
                M,
                N,
                O,
                P,
                Q,
                R,
                S,
            > ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
                P: SignedExtension<T>,
                Q: SignedExtension<T>,
                R: SignedExtension<T>,
                S: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<
                T,
                A,
                B,
                C,
                D,
                E,
                F,
                G,
                H,
                I,
                J,
                K,
                L,
                M,
                N,
                O,
                P,
                Q,
                R,
                S,
                U,
            > ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, U)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
                P: SignedExtension<T>,
                Q: SignedExtension<T>,
                R: SignedExtension<T>,
                S: SignedExtension<T>,
                U: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                    J::OtherParams,
                    K::OtherParams,
                    L::OtherParams,
                    M::OtherParams,
                    N::OtherParams,
                    O::OtherParams,
                    P::OtherParams,
                    Q::OtherParams,
                    R::OtherParams,
                    S::OtherParams,
                    U::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if J::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = J::new(nonce, client.clone(), other_params.9)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if K::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = K::new(nonce, client.clone(), other_params.10)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if L::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = L::new(nonce, client.clone(), other_params.11)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if M::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = M::new(nonce, client.clone(), other_params.12)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if N::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = N::new(nonce, client.clone(), other_params.13)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if O::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = O::new(nonce, client.clone(), other_params.14)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if P::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = P::new(nonce, client.clone(), other_params.15)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if Q::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = Q::new(nonce, client.clone(), other_params.16)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if R::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = R::new(nonce, client.clone(), other_params.17)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if S::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = S::new(nonce, client.clone(), other_params.18)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if U::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = U::new(nonce, client.clone(), other_params.19)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<
                T,
                A,
                B,
                C,
                D,
                E,
                F,
                G,
                H,
                I,
                J,
                K,
                L,
                M,
                N,
                O,
                P,
                Q,
                R,
                S,
                U,
            > ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, U)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
                P: SignedExtension<T>,
                Q: SignedExtension<T>,
                R: SignedExtension<T>,
                S: SignedExtension<T>,
                U: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
            impl<
                T,
                A,
                B,
                C,
                D,
                E,
                F,
                G,
                H,
                I,
                J,
                K,
                L,
                M,
                N,
                O,
                P,
                Q,
                R,
                S,
                U,
                V,
            > ExtrinsicParams<T>
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, U, V)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
                P: SignedExtension<T>,
                Q: SignedExtension<T>,
                R: SignedExtension<T>,
                S: SignedExtension<T>,
                U: SignedExtension<T>,
                V: SignedExtension<T>,
            {
                type OtherParams = (
                    A::OtherParams,
                    B::OtherParams,
                    C::OtherParams,
                    D::OtherParams,
                    E::OtherParams,
                    F::OtherParams,
                    G::OtherParams,
                    H::OtherParams,
                    I::OtherParams,
                    J::OtherParams,
                    K::OtherParams,
                    L::OtherParams,
                    M::OtherParams,
                    N::OtherParams,
                    O::OtherParams,
                    P::OtherParams,
                    Q::OtherParams,
                    R::OtherParams,
                    S::OtherParams,
                    U::OtherParams,
                    V::OtherParams,
                );
                fn new<Client: OfflineClientT<T>>(
                    nonce: u64,
                    client: Client,
                    other_params: Self::OtherParams,
                ) -> Result<Self, ExtrinsicParamsError> {
                    let metadata = client.metadata();
                    let types = metadata.types();
                    let mut exts_by_index = HashMap::new();
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if A::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = A::new(nonce, client.clone(), other_params.0)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if B::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = B::new(nonce, client.clone(), other_params.1)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if C::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = C::new(nonce, client.clone(), other_params.2)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if D::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = D::new(nonce, client.clone(), other_params.3)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if E::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = E::new(nonce, client.clone(), other_params.4)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if F::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = F::new(nonce, client.clone(), other_params.5)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if G::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = G::new(nonce, client.clone(), other_params.6)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if H::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = H::new(nonce, client.clone(), other_params.7)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if I::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = I::new(nonce, client.clone(), other_params.8)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if J::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = J::new(nonce, client.clone(), other_params.9)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if K::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = K::new(nonce, client.clone(), other_params.10)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if L::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = L::new(nonce, client.clone(), other_params.11)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if M::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = M::new(nonce, client.clone(), other_params.12)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if N::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = N::new(nonce, client.clone(), other_params.13)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if O::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = O::new(nonce, client.clone(), other_params.14)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if P::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = P::new(nonce, client.clone(), other_params.15)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if Q::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = Q::new(nonce, client.clone(), other_params.16)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if R::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = R::new(nonce, client.clone(), other_params.17)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if S::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = S::new(nonce, client.clone(), other_params.18)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if U::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = U::new(nonce, client.clone(), other_params.19)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    {
                        for (idx, e) in metadata
                            .extrinsic()
                            .signed_extensions()
                            .iter()
                            .enumerate()
                        {
                            if exts_by_index.contains_key(&idx) {
                                continue;
                            }
                            if V::matches(e.identifier(), e.extra_ty(), types) {
                                let ext = V::new(nonce, client.clone(), other_params.20)?;
                                let boxed_ext: Box<dyn ExtrinsicParamsEncoder> = Box::new(
                                    ext,
                                );
                                exts_by_index.insert(idx, boxed_ext);
                                break;
                            }
                        }
                    }
                    let mut params = Vec::new();
                    for (idx, e) in metadata
                        .extrinsic()
                        .signed_extensions()
                        .iter()
                        .enumerate()
                    {
                        let Some(ext) = exts_by_index.remove(&idx) else {
                        if is_type_empty(e.extra_ty(), types) {
                            continue
                        } else {
                            return Err(
                                ExtrinsicParamsError::UnknownSignedExtension(
                                    e.identifier().to_owned(),
                                ),
                            );
                        } };
                        params.push(ext);
                    }
                    Ok(AnyOf {
                        params,
                        _marker: std::marker::PhantomData,
                    })
                }
            }
            impl<
                T,
                A,
                B,
                C,
                D,
                E,
                F,
                G,
                H,
                I,
                J,
                K,
                L,
                M,
                N,
                O,
                P,
                Q,
                R,
                S,
                U,
                V,
            > ExtrinsicParamsEncoder
            for AnyOf<T, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, U, V)>
            where
                T: Config,
                A: SignedExtension<T>,
                B: SignedExtension<T>,
                C: SignedExtension<T>,
                D: SignedExtension<T>,
                E: SignedExtension<T>,
                F: SignedExtension<T>,
                G: SignedExtension<T>,
                H: SignedExtension<T>,
                I: SignedExtension<T>,
                J: SignedExtension<T>,
                K: SignedExtension<T>,
                L: SignedExtension<T>,
                M: SignedExtension<T>,
                N: SignedExtension<T>,
                O: SignedExtension<T>,
                P: SignedExtension<T>,
                Q: SignedExtension<T>,
                R: SignedExtension<T>,
                S: SignedExtension<T>,
                U: SignedExtension<T>,
                V: SignedExtension<T>,
            {
                fn encode_extra_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_extra_to(v);
                    }
                }
                fn encode_additional_to(&self, v: &mut Vec<u8>) {
                    for ext in &self.params {
                        ext.encode_additional_to(v);
                    }
                }
            }
        };
        /// Checks to see whether the type being given is empty, ie would require
        /// 0 bytes to encode.
        fn is_type_empty(type_id: u32, types: &scale_info::PortableRegistry) -> bool {
            let Some(ty) = types.resolve(type_id) else { return false;
        };
            use scale_info::TypeDef;
            match &ty.type_def {
                TypeDef::Composite(c) => {
                    c.fields.iter().all(|f| is_type_empty(f.ty.id, types))
                }
                TypeDef::Array(a) => a.len == 0 || is_type_empty(a.type_param.id, types),
                TypeDef::Tuple(t) => t.fields.iter().all(|f| is_type_empty(f.id, types)),
                TypeDef::BitSequence(_)
                | TypeDef::Variant(_)
                | TypeDef::Sequence(_)
                | TypeDef::Compact(_)
                | TypeDef::Primitive(_) => false,
            }
        }
    }
    pub mod substrate {
        //! Substrate specific configuration
        use super::{
            Config, DefaultExtrinsicParams, DefaultExtrinsicParamsBuilder, Hasher, Header,
        };
        use codec::{Decode, Encode};
        use serde::{Deserialize, Serialize};
        pub use crate::utils::{AccountId32, MultiAddress, MultiSignature};
        pub use primitive_types::{H256, U256};
        /// Default set of commonly used types by Substrate runtimes.
        pub enum SubstrateConfig {}
        impl Config for SubstrateConfig {
            type Hash = H256;
            type AccountId = AccountId32;
            type Address = MultiAddress<Self::AccountId, u32>;
            type Signature = MultiSignature;
            type Hasher = BlakeTwo256;
            type Header = SubstrateHeader<u32, BlakeTwo256>;
            type ExtrinsicParams = SubstrateExtrinsicParams<Self>;
            type AssetId = u32;
        }
        /// A struct representing the signed extra and additional parameters required
        /// to construct a transaction for the default substrate node.
        pub type SubstrateExtrinsicParams<T> = DefaultExtrinsicParams<T>;
        /// A builder which leads to [`SubstrateExtrinsicParams`] being constructed.
        /// This is what you provide to methods like `sign_and_submit()`.
        pub type SubstrateExtrinsicParamsBuilder<T> = DefaultExtrinsicParamsBuilder<T>;
        /// A type that can hash values using the blaks2_256 algorithm.
        pub struct BlakeTwo256;
        #[automatically_derived]
        impl ::core::fmt::Debug for BlakeTwo256 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "BlakeTwo256")
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for BlakeTwo256 {
            #[inline]
            fn clone(&self) -> BlakeTwo256 {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for BlakeTwo256 {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for BlakeTwo256 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for BlakeTwo256 {
            #[inline]
            fn eq(&self, other: &BlakeTwo256) -> bool {
                true
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for BlakeTwo256 {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Encode for BlakeTwo256 {
                fn size_hint(&self) -> usize {
                    0_usize
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {}
            }
            #[automatically_derived]
            impl ::codec::EncodeLike for BlakeTwo256 {}
        };
        impl Hasher for BlakeTwo256 {
            type Output = H256;
            fn hash(s: &[u8]) -> Self::Output {
                sp_core_hashing::blake2_256(s).into()
            }
        }
        /// A generic Substrate header type, adapted from `sp_runtime::generic::Header`.
        /// The block number and hasher can be configured to adapt this for other nodes.
        #[serde(rename_all = "camelCase")]
        pub struct SubstrateHeader<N: Copy + Into<U256> + TryFrom<U256>, H: Hasher> {
            /// The parent hash.
            pub parent_hash: H::Output,
            /// The block number.
            #[serde(
                serialize_with = "serialize_number",
                deserialize_with = "deserialize_number"
            )]
            #[codec(compact)]
            pub number: N,
            /// The state trie merkle root
            pub state_root: H::Output,
            /// The merkle root of the extrinsics.
            pub extrinsics_root: H::Output,
            /// A chain-specific digest of data useful for light clients or referencing auxiliary data.
            pub digest: Digest,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<N: Copy + Into<U256> + TryFrom<U256>, H: Hasher> ::codec::Encode
            for SubstrateHeader<N, H>
            where
                H::Output: ::codec::Encode,
                H::Output: ::codec::Encode,
                H::Output: ::codec::Encode,
                H::Output: ::codec::Encode,
                H::Output: ::codec::Encode,
                H::Output: ::codec::Encode,
                N: ::codec::HasCompact,
            {
                fn size_hint(&self) -> usize {
                    0_usize
                        .saturating_add(::codec::Encode::size_hint(&self.parent_hash))
                        .saturating_add(
                            ::codec::Encode::size_hint(
                                &<<N as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                    '_,
                                    N,
                                >>::RefType::from(&self.number),
                            ),
                        )
                        .saturating_add(::codec::Encode::size_hint(&self.state_root))
                        .saturating_add(
                            ::codec::Encode::size_hint(&self.extrinsics_root),
                        )
                        .saturating_add(::codec::Encode::size_hint(&self.digest))
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    ::codec::Encode::encode_to(&self.parent_hash, __codec_dest_edqy);
                    {
                        ::codec::Encode::encode_to(
                            &<<N as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                '_,
                                N,
                            >>::RefType::from(&self.number),
                            __codec_dest_edqy,
                        );
                    }
                    ::codec::Encode::encode_to(&self.state_root, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.extrinsics_root, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self.digest, __codec_dest_edqy);
                }
            }
            #[automatically_derived]
            impl<N: Copy + Into<U256> + TryFrom<U256>, H: Hasher> ::codec::EncodeLike
            for SubstrateHeader<N, H>
            where
                H::Output: ::codec::Encode,
                H::Output: ::codec::Encode,
                H::Output: ::codec::Encode,
                H::Output: ::codec::Encode,
                H::Output: ::codec::Encode,
                H::Output: ::codec::Encode,
                N: ::codec::HasCompact,
            {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<N: Copy + Into<U256> + TryFrom<U256>, H: Hasher> ::codec::Decode
            for SubstrateHeader<N, H>
            where
                H::Output: ::codec::Decode,
                H::Output: ::codec::Decode,
                H::Output: ::codec::Decode,
                H::Output: ::codec::Decode,
                H::Output: ::codec::Decode,
                H::Output: ::codec::Decode,
                N: ::codec::HasCompact,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(SubstrateHeader::<N, H> {
                        parent_hash: {
                            let __codec_res_edqy = <H::Output as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `SubstrateHeader::parent_hash`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                        number: {
                            let __codec_res_edqy = <<N as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `SubstrateHeader::number`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy.into()
                                }
                            }
                        },
                        state_root: {
                            let __codec_res_edqy = <H::Output as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `SubstrateHeader::state_root`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                        extrinsics_root: {
                            let __codec_res_edqy = <H::Output as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e
                                            .chain(
                                                "Could not decode `SubstrateHeader::extrinsics_root`",
                                            ),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                        digest: {
                            let __codec_res_edqy = <Digest as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `SubstrateHeader::digest`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                    })
                }
            }
        };
        #[automatically_derived]
        impl<
            N: ::core::fmt::Debug + Copy + Into<U256> + TryFrom<U256>,
            H: ::core::fmt::Debug + Hasher,
        > ::core::fmt::Debug for SubstrateHeader<N, H>
        where
            H::Output: ::core::fmt::Debug,
            H::Output: ::core::fmt::Debug,
            H::Output: ::core::fmt::Debug,
        {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "SubstrateHeader",
                    "parent_hash",
                    &self.parent_hash,
                    "number",
                    &self.number,
                    "state_root",
                    &self.state_root,
                    "extrinsics_root",
                    &self.extrinsics_root,
                    "digest",
                    &&self.digest,
                )
            }
        }
        #[automatically_derived]
        impl<
            N: Copy + Into<U256> + TryFrom<U256>,
            H: Hasher,
        > ::core::marker::StructuralPartialEq for SubstrateHeader<N, H> {}
        #[automatically_derived]
        impl<
            N: ::core::cmp::PartialEq + Copy + Into<U256> + TryFrom<U256>,
            H: ::core::cmp::PartialEq + Hasher,
        > ::core::cmp::PartialEq for SubstrateHeader<N, H>
        where
            H::Output: ::core::cmp::PartialEq,
            H::Output: ::core::cmp::PartialEq,
            H::Output: ::core::cmp::PartialEq,
        {
            #[inline]
            fn eq(&self, other: &SubstrateHeader<N, H>) -> bool {
                self.parent_hash == other.parent_hash && self.number == other.number
                    && self.state_root == other.state_root
                    && self.extrinsics_root == other.extrinsics_root
                    && self.digest == other.digest
            }
        }
        #[automatically_derived]
        impl<
            N: ::core::cmp::Eq + Copy + Into<U256> + TryFrom<U256>,
            H: ::core::cmp::Eq + Hasher,
        > ::core::cmp::Eq for SubstrateHeader<N, H>
        where
            H::Output: ::core::cmp::Eq,
            H::Output: ::core::cmp::Eq,
            H::Output: ::core::cmp::Eq,
        {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<H::Output>;
                let _: ::core::cmp::AssertParamIsEq<N>;
                let _: ::core::cmp::AssertParamIsEq<H::Output>;
                let _: ::core::cmp::AssertParamIsEq<H::Output>;
                let _: ::core::cmp::AssertParamIsEq<Digest>;
            }
        }
        #[automatically_derived]
        impl<
            N: ::core::clone::Clone + Copy + Into<U256> + TryFrom<U256>,
            H: ::core::clone::Clone + Hasher,
        > ::core::clone::Clone for SubstrateHeader<N, H>
        where
            H::Output: ::core::clone::Clone,
            H::Output: ::core::clone::Clone,
            H::Output: ::core::clone::Clone,
        {
            #[inline]
            fn clone(&self) -> SubstrateHeader<N, H> {
                SubstrateHeader {
                    parent_hash: ::core::clone::Clone::clone(&self.parent_hash),
                    number: ::core::clone::Clone::clone(&self.number),
                    state_root: ::core::clone::Clone::clone(&self.state_root),
                    extrinsics_root: ::core::clone::Clone::clone(&self.extrinsics_root),
                    digest: ::core::clone::Clone::clone(&self.digest),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<N: Copy + Into<U256> + TryFrom<U256>, H: Hasher> _serde::Serialize
            for SubstrateHeader<N, H>
            where
                H::Output: _serde::Serialize,
                H::Output: _serde::Serialize,
                H::Output: _serde::Serialize,
            {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "SubstrateHeader",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "parentHash",
                        &self.parent_hash,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "number",
                        {
                            #[doc(hidden)]
                            struct __SerializeWith<
                                '__a,
                                N: Copy + Into<U256> + TryFrom<U256> + '__a,
                                H: Hasher + '__a,
                            >
                            where
                                H::Output: _serde::Serialize,
                                H::Output: _serde::Serialize,
                                H::Output: _serde::Serialize,
                            {
                                values: (&'__a N,),
                                phantom: _serde::__private::PhantomData<
                                    SubstrateHeader<N, H>,
                                >,
                            }
                            impl<
                                '__a,
                                N: Copy + Into<U256> + TryFrom<U256> + '__a,
                                H: Hasher + '__a,
                            > _serde::Serialize for __SerializeWith<'__a, N, H>
                            where
                                H::Output: _serde::Serialize,
                                H::Output: _serde::Serialize,
                                H::Output: _serde::Serialize,
                            {
                                fn serialize<__S>(
                                    &self,
                                    __s: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    serialize_number(self.values.0, __s)
                                }
                            }
                            &__SerializeWith {
                                values: (&self.number,),
                                phantom: _serde::__private::PhantomData::<
                                    SubstrateHeader<N, H>,
                                >,
                            }
                        },
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "stateRoot",
                        &self.state_root,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "extrinsicsRoot",
                        &self.extrinsics_root,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "digest",
                        &self.digest,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<
                'de,
                N: Copy + Into<U256> + TryFrom<U256>,
                H: Hasher,
            > _serde::Deserialize<'de> for SubstrateHeader<N, H>
            where
                H::Output: _serde::Deserialize<'de>,
                H::Output: _serde::Deserialize<'de>,
                H::Output: _serde::Deserialize<'de>,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "parentHash" => _serde::__private::Ok(__Field::__field0),
                                "number" => _serde::__private::Ok(__Field::__field1),
                                "stateRoot" => _serde::__private::Ok(__Field::__field2),
                                "extrinsicsRoot" => _serde::__private::Ok(__Field::__field3),
                                "digest" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"parentHash" => _serde::__private::Ok(__Field::__field0),
                                b"number" => _serde::__private::Ok(__Field::__field1),
                                b"stateRoot" => _serde::__private::Ok(__Field::__field2),
                                b"extrinsicsRoot" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"digest" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<
                        'de,
                        N: Copy + Into<U256> + TryFrom<U256>,
                        H: Hasher,
                    >
                    where
                        H::Output: _serde::Deserialize<'de>,
                        H::Output: _serde::Deserialize<'de>,
                        H::Output: _serde::Deserialize<'de>,
                    {
                        marker: _serde::__private::PhantomData<SubstrateHeader<N, H>>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<
                        'de,
                        N: Copy + Into<U256> + TryFrom<U256>,
                        H: Hasher,
                    > _serde::de::Visitor<'de> for __Visitor<'de, N, H>
                    where
                        H::Output: _serde::Deserialize<'de>,
                        H::Output: _serde::Deserialize<'de>,
                        H::Output: _serde::Deserialize<'de>,
                    {
                        type Value = SubstrateHeader<N, H>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SubstrateHeader",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                H::Output,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SubstrateHeader with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<
                                    'de,
                                    N: Copy + Into<U256> + TryFrom<U256>,
                                    H: Hasher,
                                >
                                where
                                    H::Output: _serde::Deserialize<'de>,
                                    H::Output: _serde::Deserialize<'de>,
                                    H::Output: _serde::Deserialize<'de>,
                                {
                                    value: N,
                                    phantom: _serde::__private::PhantomData<
                                        SubstrateHeader<N, H>,
                                    >,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<
                                    'de,
                                    N: Copy + Into<U256> + TryFrom<U256>,
                                    H: Hasher,
                                > _serde::Deserialize<'de> for __DeserializeWith<'de, N, H>
                                where
                                    H::Output: _serde::Deserialize<'de>,
                                    H::Output: _serde::Deserialize<'de>,
                                    H::Output: _serde::Deserialize<'de>,
                                {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: deserialize_number(__deserializer)?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<'de, N, H>,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct SubstrateHeader with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                H::Output,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct SubstrateHeader with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                H::Output,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct SubstrateHeader with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                Digest,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct SubstrateHeader with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SubstrateHeader {
                                parent_hash: __field0,
                                number: __field1,
                                state_root: __field2,
                                extrinsics_root: __field3,
                                digest: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<H::Output> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<N> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<H::Output> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<H::Output> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Digest> = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "parentHash",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<H::Output>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("number"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<
                                                'de,
                                                N: Copy + Into<U256> + TryFrom<U256>,
                                                H: Hasher,
                                            >
                                            where
                                                H::Output: _serde::Deserialize<'de>,
                                                H::Output: _serde::Deserialize<'de>,
                                                H::Output: _serde::Deserialize<'de>,
                                            {
                                                value: N,
                                                phantom: _serde::__private::PhantomData<
                                                    SubstrateHeader<N, H>,
                                                >,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            impl<
                                                'de,
                                                N: Copy + Into<U256> + TryFrom<U256>,
                                                H: Hasher,
                                            > _serde::Deserialize<'de> for __DeserializeWith<'de, N, H>
                                            where
                                                H::Output: _serde::Deserialize<'de>,
                                                H::Output: _serde::Deserialize<'de>,
                                                H::Output: _serde::Deserialize<'de>,
                                            {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: deserialize_number(__deserializer)?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<'de, N, H>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "stateRoot",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<H::Output>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "extrinsicsRoot",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<H::Output>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("digest"),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Digest>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("parentHash")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field("number"),
                                    );
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("stateRoot")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("extrinsicsRoot")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("digest")?
                                }
                            };
                            _serde::__private::Ok(SubstrateHeader {
                                parent_hash: __field0,
                                number: __field1,
                                state_root: __field2,
                                extrinsics_root: __field3,
                                digest: __field4,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "parentHash",
                        "number",
                        "stateRoot",
                        "extrinsicsRoot",
                        "digest",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SubstrateHeader",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                SubstrateHeader<N, H>,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl<N, H> Header for SubstrateHeader<N, H>
        where
            N: Copy + Into<u64> + Into<U256> + TryFrom<U256> + Encode,
            H: Hasher + Encode,
            SubstrateHeader<N, H>: Encode + Decode,
        {
            type Number = N;
            type Hasher = H;
            fn number(&self) -> Self::Number {
                self.number
            }
        }
        /// Generic header digest. From `sp_runtime::generic::digest`.
        pub struct Digest {
            /// A list of digest items.
            pub logs: Vec<DigestItem>,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Encode for Digest {
                fn size_hint(&self) -> usize {
                    ::codec::Encode::size_hint(&&self.logs)
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    ::codec::Encode::encode_to(&&self.logs, __codec_dest_edqy)
                }
                fn encode(&self) -> ::codec::alloc::vec::Vec<::core::primitive::u8> {
                    ::codec::Encode::encode(&&self.logs)
                }
                fn using_encoded<
                    __CodecOutputReturn,
                    __CodecUsingEncodedCallback: ::core::ops::FnOnce(
                            &[::core::primitive::u8],
                        ) -> __CodecOutputReturn,
                >(&self, f: __CodecUsingEncodedCallback) -> __CodecOutputReturn {
                    ::codec::Encode::using_encoded(&&self.logs, f)
                }
            }
            #[automatically_derived]
            impl ::codec::EncodeLike for Digest {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Decode for Digest {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(Digest {
                        logs: {
                            let __codec_res_edqy = <Vec<
                                DigestItem,
                            > as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `Digest::logs`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                    })
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for Digest {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Digest",
                    "logs",
                    &&self.logs,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Digest {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Digest {
            #[inline]
            fn eq(&self, other: &Digest) -> bool {
                self.logs == other.logs
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Digest {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Vec<DigestItem>>;
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Digest {
            #[inline]
            fn clone(&self) -> Digest {
                Digest {
                    logs: ::core::clone::Clone::clone(&self.logs),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Digest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Digest",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "logs",
                        &self.logs,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Digest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "logs" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"logs" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Digest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Digest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Digest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Vec<DigestItem>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Digest with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Digest { logs: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Vec<DigestItem>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key)
                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("logs"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<DigestItem>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("logs")?
                                }
                            };
                            _serde::__private::Ok(Digest { logs: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["logs"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Digest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Digest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for Digest {
            #[inline]
            fn default() -> Digest {
                Digest {
                    logs: ::core::default::Default::default(),
                }
            }
        }
        /// Digest item that is able to encode/decode 'system' digest items and
        /// provide opaque access to other items. From `sp_runtime::generic::digest`.
        pub enum DigestItem {
            /// A pre-runtime digest.
            ///
            /// These are messages from the consensus engine to the runtime, although
            /// the consensus engine can (and should) read them itself to avoid
            /// code and state duplication. It is erroneous for a runtime to produce
            /// these, but this is not (yet) checked.
            ///
            /// NOTE: the runtime is not allowed to panic or fail in an `on_initialize`
            /// call if an expected `PreRuntime` digest is not present. It is the
            /// responsibility of a external block verifier to check this. Runtime API calls
            /// will initialize the block without pre-runtime digests, so initialization
            /// cannot fail when they are missing.
            PreRuntime(ConsensusEngineId, Vec<u8>),
            /// A message from the runtime to the consensus engine. This should *never*
            /// be generated by the native code of any consensus engine, but this is not
            /// checked (yet).
            Consensus(ConsensusEngineId, Vec<u8>),
            /// Put a Seal on it. This is only used by native code, and is never seen
            /// by runtimes.
            Seal(ConsensusEngineId, Vec<u8>),
            /// Some other thing. Unsupported and experimental.
            Other(Vec<u8>),
            /// An indication for the light clients that the runtime execution
            /// environment is updated.
            ///
            /// Currently this is triggered when:
            /// 1. Runtime code blob is changed or
            /// 2. `heap_pages` value is changed.
            RuntimeEnvironmentUpdated,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DigestItem {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    DigestItem::PreRuntime(__self_0, __self_1) => {
                        ::core::fmt::Formatter::debug_tuple_field2_finish(
                            f,
                            "PreRuntime",
                            __self_0,
                            &__self_1,
                        )
                    }
                    DigestItem::Consensus(__self_0, __self_1) => {
                        ::core::fmt::Formatter::debug_tuple_field2_finish(
                            f,
                            "Consensus",
                            __self_0,
                            &__self_1,
                        )
                    }
                    DigestItem::Seal(__self_0, __self_1) => {
                        ::core::fmt::Formatter::debug_tuple_field2_finish(
                            f,
                            "Seal",
                            __self_0,
                            &__self_1,
                        )
                    }
                    DigestItem::Other(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Other",
                            &__self_0,
                        )
                    }
                    DigestItem::RuntimeEnvironmentUpdated => {
                        ::core::fmt::Formatter::write_str(f, "RuntimeEnvironmentUpdated")
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DigestItem {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DigestItem {
            #[inline]
            fn eq(&self, other: &DigestItem) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            DigestItem::PreRuntime(__self_0, __self_1),
                            DigestItem::PreRuntime(__arg1_0, __arg1_1),
                        ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                        (
                            DigestItem::Consensus(__self_0, __self_1),
                            DigestItem::Consensus(__arg1_0, __arg1_1),
                        ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                        (
                            DigestItem::Seal(__self_0, __self_1),
                            DigestItem::Seal(__arg1_0, __arg1_1),
                        ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                        (DigestItem::Other(__self_0), DigestItem::Other(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        _ => true,
                    }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for DigestItem {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ConsensusEngineId>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DigestItem {
            #[inline]
            fn clone(&self) -> DigestItem {
                match self {
                    DigestItem::PreRuntime(__self_0, __self_1) => {
                        DigestItem::PreRuntime(
                            ::core::clone::Clone::clone(__self_0),
                            ::core::clone::Clone::clone(__self_1),
                        )
                    }
                    DigestItem::Consensus(__self_0, __self_1) => {
                        DigestItem::Consensus(
                            ::core::clone::Clone::clone(__self_0),
                            ::core::clone::Clone::clone(__self_1),
                        )
                    }
                    DigestItem::Seal(__self_0, __self_1) => {
                        DigestItem::Seal(
                            ::core::clone::Clone::clone(__self_0),
                            ::core::clone::Clone::clone(__self_1),
                        )
                    }
                    DigestItem::Other(__self_0) => {
                        DigestItem::Other(::core::clone::Clone::clone(__self_0))
                    }
                    DigestItem::RuntimeEnvironmentUpdated => {
                        DigestItem::RuntimeEnvironmentUpdated
                    }
                }
            }
        }
        #[repr(u32)]
        enum DigestItemType {
            Other = 0u32,
            Consensus = 4u32,
            Seal = 5u32,
            PreRuntime = 6u32,
            RuntimeEnvironmentUpdated = 8u32,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Encode for DigestItemType {
                fn size_hint(&self) -> usize {
                    1_usize
                        + match *self {
                            DigestItemType::Other => 0_usize,
                            DigestItemType::Consensus => 0_usize,
                            DigestItemType::Seal => 0_usize,
                            DigestItemType::PreRuntime => 0_usize,
                            DigestItemType::RuntimeEnvironmentUpdated => 0_usize,
                            _ => 0_usize,
                        }
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    match *self {
                        DigestItemType::Other => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(0u32 as ::core::primitive::u8);
                        }
                        DigestItemType::Consensus => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(4u32 as ::core::primitive::u8);
                        }
                        DigestItemType::Seal => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(5u32 as ::core::primitive::u8);
                        }
                        DigestItemType::PreRuntime => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(6u32 as ::core::primitive::u8);
                        }
                        DigestItemType::RuntimeEnvironmentUpdated => {
                            #[allow(clippy::unnecessary_cast)]
                            __codec_dest_edqy.push_byte(8u32 as ::core::primitive::u8);
                        }
                        _ => {}
                    }
                }
            }
            #[automatically_derived]
            impl ::codec::EncodeLike for DigestItemType {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Decode for DigestItemType {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy
                        .read_byte()
                        .map_err(|e| {
                            e
                                .chain(
                                    "Could not decode `DigestItemType`, failed to read variant byte",
                                )
                        })?
                    {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 0u32 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(DigestItemType::Other)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 4u32 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(DigestItemType::Consensus)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 5u32 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(DigestItemType::Seal)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 6u32 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(DigestItemType::PreRuntime)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 8u32 as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    DigestItemType::RuntimeEnvironmentUpdated,
                                )
                            })();
                        }
                        _ => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Err(
                                    <_ as ::core::convert::Into<
                                        _,
                                    >>::into(
                                        "Could not decode `DigestItemType`, variant doesn't exist",
                                    ),
                                )
                            })();
                        }
                    }
                }
            }
        };
        impl Encode for DigestItem {
            fn encode(&self) -> Vec<u8> {
                let mut v = Vec::new();
                match self {
                    Self::Consensus(val, data) => {
                        DigestItemType::Consensus.encode_to(&mut v);
                        (val, data).encode_to(&mut v);
                    }
                    Self::Seal(val, sig) => {
                        DigestItemType::Seal.encode_to(&mut v);
                        (val, sig).encode_to(&mut v);
                    }
                    Self::PreRuntime(val, data) => {
                        DigestItemType::PreRuntime.encode_to(&mut v);
                        (val, data).encode_to(&mut v);
                    }
                    Self::Other(val) => {
                        DigestItemType::Other.encode_to(&mut v);
                        val.encode_to(&mut v);
                    }
                    Self::RuntimeEnvironmentUpdated => {
                        DigestItemType::RuntimeEnvironmentUpdated.encode_to(&mut v);
                    }
                }
                v
            }
        }
        impl Decode for DigestItem {
            fn decode<I: codec::Input>(input: &mut I) -> Result<Self, codec::Error> {
                let item_type: DigestItemType = Decode::decode(input)?;
                match item_type {
                    DigestItemType::PreRuntime => {
                        let vals: (ConsensusEngineId, Vec<u8>) = Decode::decode(input)?;
                        Ok(Self::PreRuntime(vals.0, vals.1))
                    }
                    DigestItemType::Consensus => {
                        let vals: (ConsensusEngineId, Vec<u8>) = Decode::decode(input)?;
                        Ok(Self::Consensus(vals.0, vals.1))
                    }
                    DigestItemType::Seal => {
                        let vals: (ConsensusEngineId, Vec<u8>) = Decode::decode(input)?;
                        Ok(Self::Seal(vals.0, vals.1))
                    }
                    DigestItemType::Other => Ok(Self::Other(Decode::decode(input)?)),
                    DigestItemType::RuntimeEnvironmentUpdated => {
                        Ok(Self::RuntimeEnvironmentUpdated)
                    }
                }
            }
        }
        /// Consensus engine unique ID. From `sp_runtime::ConsensusEngineId`.
        pub type ConsensusEngineId = [u8; 4];
        impl serde::Serialize for DigestItem {
            fn serialize<S>(&self, seq: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                self.using_encoded(|bytes| impl_serde::serialize::serialize(bytes, seq))
            }
        }
        impl<'a> serde::Deserialize<'a> for DigestItem {
            fn deserialize<D>(de: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'a>,
            {
                let r = impl_serde::serialize::deserialize(de)?;
                Decode::decode(&mut &r[..])
                    .map_err(|e| serde::de::Error::custom({
                        let res = ::alloc::fmt::format(
                            format_args!("Decode error: {0}", e),
                        );
                        res
                    }))
            }
        }
        fn serialize_number<S, T: Copy + Into<U256>>(
            val: &T,
            s: S,
        ) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            let u256: U256 = (*val).into();
            serde::Serialize::serialize(&u256, s)
        }
        fn deserialize_number<'a, D, T: TryFrom<U256>>(d: D) -> Result<T, D::Error>
        where
            D: serde::Deserializer<'a>,
        {
            use crate::backend::legacy::rpc_methods::NumberOrHex;
            let number_or_hex = NumberOrHex::deserialize(d)?;
            let u256 = number_or_hex.into_u256();
            TryFrom::try_from(u256)
                .map_err(|_| serde::de::Error::custom("Try from failed"))
        }
    }
    use crate::macros::cfg_substrate_compat;
    use codec::{Decode, Encode};
    use core::fmt::Debug;
    use scale_decode::DecodeAsType;
    use scale_encode::EncodeAsType;
    use serde::{de::DeserializeOwned, Serialize};
    pub use default_extrinsic_params::{
        DefaultExtrinsicParams, DefaultExtrinsicParamsBuilder,
    };
    pub use extrinsic_params::{
        ExtrinsicParams, ExtrinsicParamsEncoder, ExtrinsicParamsError,
    };
    pub use polkadot::{
        PolkadotConfig, PolkadotExtrinsicParams, PolkadotExtrinsicParamsBuilder,
    };
    pub use signed_extensions::SignedExtension;
    pub use substrate::{
        SubstrateConfig, SubstrateExtrinsicParams, SubstrateExtrinsicParamsBuilder,
    };
    /// Runtime types.
    pub trait Config: Sized + Send + Sync + 'static {
        /// The output of the `Hasher` function.
        type Hash: BlockHash;
        /// The account ID type.
        type AccountId: Debug + Clone + Encode;
        /// The address type.
        type Address: Debug + Encode + From<Self::AccountId>;
        /// The signature type.
        type Signature: Debug + Encode;
        /// The hashing system (algorithm) being used in the runtime (e.g. Blake2).
        type Hasher: Debug + Hasher<Output = Self::Hash>;
        /// The block header.
        type Header: Debug
            + Header<Hasher = Self::Hasher>
            + Sync
            + Send
            + DeserializeOwned;
        /// This type defines the extrinsic extra and additional parameters.
        type ExtrinsicParams: ExtrinsicParams<Self>;
        /// This is used to identify an asset in the `ChargeAssetTxPayment` signed extension.
        type AssetId: Debug + Clone + Encode + DecodeAsType + EncodeAsType;
    }
    /// given some [`Config`], this return the other params needed for its `ExtrinsicParams`.
    pub type OtherParamsFor<T> = <<T as Config>::ExtrinsicParams as ExtrinsicParams<
        T,
    >>::OtherParams;
    /// Block hashes must conform to a bunch of things to be used in Subxt.
    pub trait BlockHash: Debug + Copy + Send + Sync + Decode + AsRef<
            [u8],
        > + Serialize + DeserializeOwned + Encode + PartialEq + Eq + std::hash::Hash {}
    impl<T> BlockHash for T
    where
        T: Debug + Copy + Send + Sync + Decode + AsRef<[u8]> + Serialize
            + DeserializeOwned + Encode + PartialEq + Eq + std::hash::Hash,
    {}
    /// This represents the hasher used by a node to hash things like block headers
    /// and extrinsics.
    pub trait Hasher {
        /// The type given back from the hash operation
        type Output;
        /// Hash some bytes to the given output type.
        fn hash(s: &[u8]) -> Self::Output;
        /// Hash some SCALE encodable type to the given output type.
        fn hash_of<S: Encode>(s: &S) -> Self::Output {
            let out = s.encode();
            Self::hash(&out)
        }
    }
    /// This represents the block header type used by a node.
    pub trait Header: Sized + Encode + Decode {
        /// The block number type for this header.
        type Number: Into<u64>;
        /// The hasher used to hash this header.
        type Hasher: Hasher;
        /// Return the block number of this header.
        fn number(&self) -> Self::Number;
        /// Hash this header.
        fn hash(&self) -> <Self::Hasher as Hasher>::Output {
            Self::Hasher::hash_of(self)
        }
    }
}
pub mod constants {
    //! Types associated with accessing constants.
    mod constant_address {
        use crate::{dynamic::DecodedValueThunk, metadata::DecodeWithMetadata};
        use derivative::Derivative;
        use std::borrow::Cow;
        /// This represents a constant address. Anything implementing this trait
        /// can be used to fetch constants.
        pub trait ConstantAddress {
            /// The target type of the value that lives at this address.
            type Target: DecodeWithMetadata;
            /// The name of the pallet that the constant lives under.
            fn pallet_name(&self) -> &str;
            /// The name of the constant in a given pallet.
            fn constant_name(&self) -> &str;
            /// An optional hash which, if present, will be checked against
            /// the node metadata to confirm that the return type matches what
            /// we are expecting.
            fn validation_hash(&self) -> Option<[u8; 32]> {
                None
            }
        }
        /// This represents the address of a constant.
        #[derivative(
            Clone(bound = ""),
            Debug(bound = ""),
            Eq(bound = ""),
            Ord(bound = ""),
            PartialEq(bound = "")
        )]
        pub struct Address<ReturnTy> {
            pallet_name: Cow<'static, str>,
            constant_name: Cow<'static, str>,
            constant_hash: Option<[u8; 32]>,
            _marker: std::marker::PhantomData<ReturnTy>,
        }
        #[allow(unused_qualifications)]
        impl<ReturnTy> ::std::clone::Clone for Address<ReturnTy> {
            fn clone(&self) -> Self {
                match *self {
                    Address {
                        pallet_name: ref __arg_0,
                        constant_name: ref __arg_1,
                        constant_hash: ref __arg_2,
                        _marker: ref __arg_3,
                    } => {
                        Address {
                            pallet_name: (*__arg_0).clone(),
                            constant_name: (*__arg_1).clone(),
                            constant_hash: (*__arg_2).clone(),
                            _marker: (*__arg_3).clone(),
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<ReturnTy> ::std::fmt::Debug for Address<ReturnTy> {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    Address {
                        pallet_name: ref __arg_0,
                        constant_name: ref __arg_1,
                        constant_hash: ref __arg_2,
                        _marker: ref __arg_3,
                    } => {
                        let mut __debug_trait_builder = __f.debug_struct("Address");
                        let _ = __debug_trait_builder.field("pallet_name", &&(*__arg_0));
                        let _ = __debug_trait_builder
                            .field("constant_name", &&(*__arg_1));
                        let _ = __debug_trait_builder
                            .field("constant_hash", &&(*__arg_2));
                        let _ = __debug_trait_builder.field("_marker", &&(*__arg_3));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        impl<ReturnTy> ::std::cmp::Eq for Address<ReturnTy> {}
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<ReturnTy> ::std::cmp::PartialEq for Address<ReturnTy> {
            fn eq(&self, other: &Self) -> bool {
                true
                    && match *self {
                        Address {
                            pallet_name: ref __self_0,
                            constant_name: ref __self_1,
                            constant_hash: ref __self_2,
                            _marker: ref __self_3,
                        } => {
                            match *other {
                                Address {
                                    pallet_name: ref __other_0,
                                    constant_name: ref __other_1,
                                    constant_hash: ref __other_2,
                                    _marker: ref __other_3,
                                } => {
                                    true && &(*__self_0) == &(*__other_0)
                                        && &(*__self_1) == &(*__other_1)
                                        && &(*__self_2) == &(*__other_2)
                                        && &(*__self_3) == &(*__other_3)
                                }
                            }
                        }
                    }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<ReturnTy> ::std::cmp::Ord for Address<ReturnTy> {
            fn cmp(&self, other: &Self) -> ::std::cmp::Ordering {
                match *self {
                    Address {
                        pallet_name: ref __self_0,
                        constant_name: ref __self_1,
                        constant_hash: ref __self_2,
                        _marker: ref __self_3,
                    } => {
                        match *other {
                            Address {
                                pallet_name: ref __other_0,
                                constant_name: ref __other_1,
                                constant_hash: ref __other_2,
                                _marker: ref __other_3,
                            } => {
                                match ::std::cmp::Ord::cmp(&(*__self_0), &(*__other_0)) {
                                    ::std::cmp::Ordering::Equal => {
                                        match ::std::cmp::Ord::cmp(&(*__self_1), &(*__other_1)) {
                                            ::std::cmp::Ordering::Equal => {
                                                match ::std::cmp::Ord::cmp(&(*__self_2), &(*__other_2)) {
                                                    ::std::cmp::Ordering::Equal => {
                                                        match ::std::cmp::Ord::cmp(&(*__self_3), &(*__other_3)) {
                                                            ::std::cmp::Ordering::Equal => ::std::cmp::Ordering::Equal,
                                                            __derive_ordering_other => __derive_ordering_other,
                                                        }
                                                    }
                                                    __derive_ordering_other => __derive_ordering_other,
                                                }
                                            }
                                            __derive_ordering_other => __derive_ordering_other,
                                        }
                                    }
                                    __derive_ordering_other => __derive_ordering_other,
                                }
                            }
                        }
                    }
                }
            }
        }
        impl<ReturnTy> PartialOrd for Address<ReturnTy> {
            fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
                Some(self.cmp(other))
            }
        }
        /// The type of address typically used to return dynamic constant values.
        pub type DynamicAddress = Address<DecodedValueThunk>;
        impl<ReturnTy> Address<ReturnTy> {
            /// Create a new [`Address`] to use to look up a constant.
            pub fn new(
                pallet_name: impl Into<String>,
                constant_name: impl Into<String>,
            ) -> Self {
                Self {
                    pallet_name: Cow::Owned(pallet_name.into()),
                    constant_name: Cow::Owned(constant_name.into()),
                    constant_hash: None,
                    _marker: std::marker::PhantomData,
                }
            }
            /// Create a new [`Address`] that will be validated
            /// against node metadata using the hash given.
            #[doc(hidden)]
            pub fn new_static(
                pallet_name: &'static str,
                constant_name: &'static str,
                hash: [u8; 32],
            ) -> Self {
                Self {
                    pallet_name: Cow::Borrowed(pallet_name),
                    constant_name: Cow::Borrowed(constant_name),
                    constant_hash: Some(hash),
                    _marker: std::marker::PhantomData,
                }
            }
            /// Do not validate this constant prior to accessing it.
            pub fn unvalidated(self) -> Self {
                Self {
                    pallet_name: self.pallet_name,
                    constant_name: self.constant_name,
                    constant_hash: None,
                    _marker: self._marker,
                }
            }
        }
        impl<ReturnTy: DecodeWithMetadata> ConstantAddress for Address<ReturnTy> {
            type Target = ReturnTy;
            fn pallet_name(&self) -> &str {
                &self.pallet_name
            }
            fn constant_name(&self) -> &str {
                &self.constant_name
            }
            fn validation_hash(&self) -> Option<[u8; 32]> {
                self.constant_hash
            }
        }
        /// Construct a new dynamic constant lookup.
        pub fn dynamic(
            pallet_name: impl Into<String>,
            constant_name: impl Into<String>,
        ) -> DynamicAddress {
            DynamicAddress::new(pallet_name, constant_name)
        }
    }
    mod constants_client {
        use super::ConstantAddress;
        use crate::{
            client::OfflineClientT, error::{Error, MetadataError},
            metadata::DecodeWithMetadata, Config,
        };
        use derivative::Derivative;
        /// A client for accessing constants.
        #[derivative(Clone(bound = "Client: Clone"))]
        pub struct ConstantsClient<T, Client> {
            client: Client,
            _marker: std::marker::PhantomData<T>,
        }
        #[allow(unused_qualifications)]
        impl<T, Client> ::std::clone::Clone for ConstantsClient<T, Client>
        where
            Client: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    ConstantsClient { client: ref __arg_0, _marker: ref __arg_1 } => {
                        ConstantsClient {
                            client: (*__arg_0).clone(),
                            _marker: (*__arg_1).clone(),
                        }
                    }
                }
            }
        }
        impl<T, Client> ConstantsClient<T, Client> {
            /// Create a new [`ConstantsClient`].
            pub fn new(client: Client) -> Self {
                Self {
                    client,
                    _marker: std::marker::PhantomData,
                }
            }
        }
        impl<T: Config, Client: OfflineClientT<T>> ConstantsClient<T, Client> {
            /// Run the validation logic against some constant address you'd like to access. Returns `Ok(())`
            /// if the address is valid (or if it's not possible to check since the address has no validation hash).
            /// Return an error if the address was not valid or something went wrong trying to validate it (ie
            /// the pallet or constant in question do not exist at all).
            pub fn validate<Address: ConstantAddress>(
                &self,
                address: &Address,
            ) -> Result<(), Error> {
                if let Some(actual_hash) = address.validation_hash() {
                    let expected_hash = self
                        .client
                        .metadata()
                        .pallet_by_name_err(address.pallet_name())?
                        .constant_hash(address.constant_name())
                        .ok_or_else(|| {
                            MetadataError::ConstantNameNotFound(
                                address.constant_name().to_owned(),
                            )
                        })?;
                    if actual_hash != expected_hash {
                        return Err(MetadataError::IncompatibleCodegen.into());
                    }
                }
                Ok(())
            }
            /// Access the constant at the address given, returning the type defined by this address.
            /// This is probably used with addresses given from static codegen, although you can manually
            /// construct your own, too.
            pub fn at<Address: ConstantAddress>(
                &self,
                address: &Address,
            ) -> Result<Address::Target, Error> {
                let metadata = self.client.metadata();
                self.validate(address)?;
                let constant = metadata
                    .pallet_by_name_err(address.pallet_name())?
                    .constant_by_name(address.constant_name())
                    .ok_or_else(|| {
                        MetadataError::ConstantNameNotFound(
                            address.constant_name().to_owned(),
                        )
                    })?;
                let value = <Address::Target as DecodeWithMetadata>::decode_with_metadata(
                    &mut constant.value(),
                    constant.ty(),
                    &metadata,
                )?;
                Ok(value)
            }
        }
    }
    pub use constant_address::{dynamic, Address, ConstantAddress, DynamicAddress};
    pub use constants_client::ConstantsClient;
}
pub mod custom_values {
    //! Types associated with accessing custom types
    mod custom_value_address {
        use derivative::Derivative;
        use std::marker::PhantomData;
        use crate::dynamic::DecodedValueThunk;
        use crate::metadata::DecodeWithMetadata;
        /// This represents the address of a custom value in in the metadata.
        /// Anything, that implements the [CustomValueAddress] trait can be used, to fetch
        /// custom values from the metadata.
        /// The trait is implemented by [str] for dynamic loopup and [StaticAddress] for static queries.
        pub trait CustomValueAddress {
            /// The type of the custom value.
            type Target: DecodeWithMetadata;
            /// Should be set to `Yes` for Dynamic values and static values that have a valid type.
            /// Should be `()` for custom values, that have an invalid type id.
            type IsDecodable;
            /// the name (key) by which the custom value can be accessed in the metadata.
            fn name(&self) -> &str;
            /// An optional hash which, if present, can be checked against node metadata.
            fn validation_hash(&self) -> Option<[u8; 32]> {
                None
            }
        }
        impl CustomValueAddress for str {
            type Target = DecodedValueThunk;
            type IsDecodable = Yes;
            fn name(&self) -> &str {
                self
            }
        }
        /// Used to signal whether a [`CustomValueAddress`] can be decoded.
        pub struct Yes;
        /// A static address to a custom value.
        #[derivative(
            Clone(bound = ""),
            Debug(bound = ""),
            Eq(bound = ""),
            Ord(bound = ""),
            PartialEq(bound = "")
        )]
        pub struct StaticAddress<ReturnTy, IsDecodable> {
            name: &'static str,
            hash: Option<[u8; 32]>,
            phantom: PhantomData<(ReturnTy, IsDecodable)>,
        }
        #[allow(unused_qualifications)]
        impl<ReturnTy, IsDecodable> ::std::clone::Clone
        for StaticAddress<ReturnTy, IsDecodable> {
            fn clone(&self) -> Self {
                match *self {
                    StaticAddress {
                        name: ref __arg_0,
                        hash: ref __arg_1,
                        phantom: ref __arg_2,
                    } => {
                        StaticAddress {
                            name: (*__arg_0).clone(),
                            hash: (*__arg_1).clone(),
                            phantom: (*__arg_2).clone(),
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<ReturnTy, IsDecodable> ::std::fmt::Debug
        for StaticAddress<ReturnTy, IsDecodable> {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    StaticAddress {
                        name: ref __arg_0,
                        hash: ref __arg_1,
                        phantom: ref __arg_2,
                    } => {
                        let mut __debug_trait_builder = __f
                            .debug_struct("StaticAddress");
                        let _ = __debug_trait_builder.field("name", &&(*__arg_0));
                        let _ = __debug_trait_builder.field("hash", &&(*__arg_1));
                        let _ = __debug_trait_builder.field("phantom", &&(*__arg_2));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        impl<ReturnTy, IsDecodable> ::std::cmp::Eq
        for StaticAddress<ReturnTy, IsDecodable> {}
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<ReturnTy, IsDecodable> ::std::cmp::PartialEq
        for StaticAddress<ReturnTy, IsDecodable> {
            fn eq(&self, other: &Self) -> bool {
                true
                    && match *self {
                        StaticAddress {
                            name: ref __self_0,
                            hash: ref __self_1,
                            phantom: ref __self_2,
                        } => {
                            match *other {
                                StaticAddress {
                                    name: ref __other_0,
                                    hash: ref __other_1,
                                    phantom: ref __other_2,
                                } => {
                                    true && &(*__self_0) == &(*__other_0)
                                        && &(*__self_1) == &(*__other_1)
                                        && &(*__self_2) == &(*__other_2)
                                }
                            }
                        }
                    }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<ReturnTy, IsDecodable> ::std::cmp::Ord
        for StaticAddress<ReturnTy, IsDecodable> {
            fn cmp(&self, other: &Self) -> ::std::cmp::Ordering {
                match *self {
                    StaticAddress {
                        name: ref __self_0,
                        hash: ref __self_1,
                        phantom: ref __self_2,
                    } => {
                        match *other {
                            StaticAddress {
                                name: ref __other_0,
                                hash: ref __other_1,
                                phantom: ref __other_2,
                            } => {
                                match ::std::cmp::Ord::cmp(&(*__self_0), &(*__other_0)) {
                                    ::std::cmp::Ordering::Equal => {
                                        match ::std::cmp::Ord::cmp(&(*__self_1), &(*__other_1)) {
                                            ::std::cmp::Ordering::Equal => {
                                                match ::std::cmp::Ord::cmp(&(*__self_2), &(*__other_2)) {
                                                    ::std::cmp::Ordering::Equal => ::std::cmp::Ordering::Equal,
                                                    __derive_ordering_other => __derive_ordering_other,
                                                }
                                            }
                                            __derive_ordering_other => __derive_ordering_other,
                                        }
                                    }
                                    __derive_ordering_other => __derive_ordering_other,
                                }
                            }
                        }
                    }
                }
            }
        }
        impl<ReturnTy, IsDecodable> PartialOrd for StaticAddress<ReturnTy, IsDecodable> {
            fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
                Some(self.cmp(other))
            }
        }
        impl<ReturnTy, IsDecodable> StaticAddress<ReturnTy, IsDecodable> {
            #[doc(hidden)]
            /// Creates a new StaticAddress.
            pub fn new_static(
                name: &'static str,
                hash: [u8; 32],
            ) -> StaticAddress<ReturnTy, IsDecodable> {
                StaticAddress::<ReturnTy, IsDecodable> {
                    name,
                    hash: Some(hash),
                    phantom: PhantomData,
                }
            }
            /// Do not validate this custom value prior to accessing it.
            pub fn unvalidated(self) -> Self {
                Self {
                    name: self.name,
                    hash: None,
                    phantom: self.phantom,
                }
            }
        }
        impl<R: DecodeWithMetadata, Y> CustomValueAddress for StaticAddress<R, Y> {
            type Target = R;
            type IsDecodable = Y;
            fn name(&self) -> &str {
                self.name
            }
            fn validation_hash(&self) -> Option<[u8; 32]> {
                self.hash
            }
        }
    }
    mod custom_values_client {
        use crate::client::OfflineClientT;
        use crate::custom_values::custom_value_address::{CustomValueAddress, Yes};
        use crate::error::MetadataError;
        use crate::metadata::DecodeWithMetadata;
        use crate::{Config, Error};
        use derivative::Derivative;
        /// A client for accessing custom values stored in the metadata.
        #[derivative(Clone(bound = "Client: Clone"))]
        pub struct CustomValuesClient<T, Client> {
            client: Client,
            _marker: std::marker::PhantomData<T>,
        }
        #[allow(unused_qualifications)]
        impl<T, Client> ::std::clone::Clone for CustomValuesClient<T, Client>
        where
            Client: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    CustomValuesClient { client: ref __arg_0, _marker: ref __arg_1 } => {
                        CustomValuesClient {
                            client: (*__arg_0).clone(),
                            _marker: (*__arg_1).clone(),
                        }
                    }
                }
            }
        }
        impl<T, Client> CustomValuesClient<T, Client> {
            /// Create a new [`CustomValuesClient`].
            pub fn new(client: Client) -> Self {
                Self {
                    client,
                    _marker: std::marker::PhantomData,
                }
            }
        }
        impl<T: Config, Client: OfflineClientT<T>> CustomValuesClient<T, Client> {
            /// Access a custom value by the address it is registered under. This can be just a [str] to get back a dynamic value,
            /// or a static address from the generated static interface to get a value of a static type returned.
            pub fn at<Address: CustomValueAddress<IsDecodable = Yes> + ?Sized>(
                &self,
                address: &Address,
            ) -> Result<Address::Target, Error> {
                self.validate(address)?;
                let metadata = self.client.metadata();
                let custom = metadata.custom();
                let custom_value = custom
                    .get(address.name())
                    .ok_or_else(|| MetadataError::CustomValueNameNotFound(
                        address.name().to_string(),
                    ))?;
                let value = <Address::Target as DecodeWithMetadata>::decode_with_metadata(
                    &mut custom_value.bytes(),
                    custom_value.type_id(),
                    &metadata,
                )?;
                Ok(value)
            }
            /// Access the bytes of a custom value by the address it is registered under.
            pub fn bytes_at<Address: CustomValueAddress + ?Sized>(
                &self,
                address: &Address,
            ) -> Result<Vec<u8>, Error> {
                self.validate(address)?;
                let metadata = self.client.metadata();
                let custom = metadata.custom();
                let custom_value = custom
                    .get(address.name())
                    .ok_or_else(|| MetadataError::CustomValueNameNotFound(
                        address.name().to_string(),
                    ))?;
                Ok(custom_value.bytes().to_vec())
            }
            /// Run the validation logic against some custom value address you'd like to access. Returns `Ok(())`
            /// if the address is valid (or if it's not possible to check since the address has no validation hash).
            /// Returns an error if the address was not valid (wrong name, type or raw bytes)
            pub fn validate<Address: CustomValueAddress + ?Sized>(
                &self,
                address: &Address,
            ) -> Result<(), Error> {
                let metadata = self.client.metadata();
                if let Some(actual_hash) = address.validation_hash() {
                    let custom = metadata.custom();
                    let custom_value = custom
                        .get(address.name())
                        .ok_or_else(|| MetadataError::CustomValueNameNotFound(
                            address.name().into(),
                        ))?;
                    let expected_hash = custom_value.hash();
                    if actual_hash != expected_hash {
                        return Err(MetadataError::IncompatibleCodegen.into());
                    }
                }
                if metadata.custom().get(address.name()).is_none() {
                    return Err(MetadataError::IncompatibleCodegen.into());
                }
                Ok(())
            }
        }
    }
    pub use custom_value_address::{CustomValueAddress, StaticAddress, Yes};
    pub use custom_values_client::CustomValuesClient;
}
pub mod dynamic {
    //! This module provides the entry points to create dynamic
    //! transactions, storage and constant lookups.
    use crate::{error::Error, metadata::{DecodeWithMetadata, Metadata}};
    use scale_decode::DecodeAsType;
    pub use scale_value::{At, Value};
    /// A [`scale_value::Value`] type endowed with contextual information
    /// regarding what type was used to decode each part of it. This implements
    /// [`crate::metadata::DecodeWithMetadata`], and is used as a return type
    /// for dynamic requests.
    pub type DecodedValue = scale_value::Value<scale_value::scale::TypeId>;
    pub use crate::tx::dynamic as tx;
    pub use crate::constants::dynamic as constant;
    pub use crate::storage::dynamic as storage;
    pub use crate::runtime_api::dynamic as runtime_api_call;
    /// This is the result of making a dynamic request to a node. From this,
    /// we can return the raw SCALE bytes that we were handed back, or we can
    /// complete the decoding of the bytes into a [`DecodedValue`] type.
    pub struct DecodedValueThunk {
        type_id: u32,
        metadata: Metadata,
        scale_bytes: Vec<u8>,
    }
    impl DecodeWithMetadata for DecodedValueThunk {
        fn decode_with_metadata(
            bytes: &mut &[u8],
            type_id: u32,
            metadata: &Metadata,
        ) -> Result<Self, Error> {
            let mut v = Vec::with_capacity(bytes.len());
            v.extend_from_slice(bytes);
            *bytes = &[];
            Ok(DecodedValueThunk {
                type_id,
                metadata: metadata.clone(),
                scale_bytes: v,
            })
        }
    }
    impl DecodedValueThunk {
        /// Return the SCALE encoded bytes handed back from the node.
        pub fn into_encoded(self) -> Vec<u8> {
            self.scale_bytes
        }
        /// Return the SCALE encoded bytes handed back from the node without taking ownership of them.
        pub fn encoded(&self) -> &[u8] {
            &self.scale_bytes
        }
        /// Decode the SCALE encoded storage entry into a dynamic [`DecodedValue`] type.
        pub fn to_value(&self) -> Result<DecodedValue, Error> {
            let val = DecodedValue::decode_as_type(
                &mut &*self.scale_bytes,
                self.type_id,
                self.metadata.types(),
            )?;
            Ok(val)
        }
        /// decode the `DecodedValueThunk` into a concrete type.
        pub fn as_type<T: DecodeAsType>(&self) -> Result<T, scale_decode::Error> {
            T::decode_as_type(
                &mut &self.scale_bytes[..],
                self.type_id,
                self.metadata.types(),
            )
        }
    }
}
pub mod error {
    //! Types representing the errors that can be returned.
    mod dispatch_error {
        //! A representation of the dispatch error; an error returned when
        //! something fails in trying to submit/execute a transaction.
        use crate::metadata::{DecodeWithMetadata, Metadata};
        use core::fmt::Debug;
        use scale_decode::{visitor::DecodeAsTypeResult, DecodeAsType};
        use std::borrow::Cow;
        use super::{Error, MetadataError};
        /// An error dispatching a transaction.
        #[non_exhaustive]
        pub enum DispatchError {
            /// Some error occurred.
            #[error("Some unknown error occurred.")]
            Other,
            /// Failed to lookup some data.
            #[error("Failed to lookup some data.")]
            CannotLookup,
            /// A bad origin.
            #[error("Bad origin.")]
            BadOrigin,
            /// A custom error in a module.
            #[error("Pallet error: {0}")]
            Module(ModuleError),
            /// At least one consumer is remaining so the account cannot be destroyed.
            #[error(
                "At least one consumer is remaining so the account cannot be destroyed."
            )]
            ConsumerRemaining,
            /// There are no providers so the account cannot be created.
            #[error("There are no providers so the account cannot be created.")]
            NoProviders,
            /// There are too many consumers so the account cannot be created.
            #[error("There are too many consumers so the account cannot be created.")]
            TooManyConsumers,
            /// An error to do with tokens.
            #[error("Token error: {0}")]
            Token(TokenError),
            /// An arithmetic error.
            #[error("Arithmetic error: {0}")]
            Arithmetic(ArithmeticError),
            /// The number of transactional layers has been reached, or we are not in a transactional layer.
            #[error("Transactional error: {0}")]
            Transactional(TransactionalError),
            /// Resources exhausted, e.g. attempt to read/write data which is too large to manipulate.
            #[error(
                "Resources exhausted, e.g. attempt to read/write data which is too large to manipulate."
            )]
            Exhausted,
            /// The state is corrupt; this is generally not going to fix itself.
            #[error("The state is corrupt; this is generally not going to fix itself.")]
            Corruption,
            /// Some resource (e.g. a preimage) is unavailable right now. This might fix itself later.
            #[error(
                "Some resource (e.g. a preimage) is unavailable right now. This might fix itself later."
            )]
            Unavailable,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DispatchError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    DispatchError::Other => ::core::fmt::Formatter::write_str(f, "Other"),
                    DispatchError::CannotLookup => {
                        ::core::fmt::Formatter::write_str(f, "CannotLookup")
                    }
                    DispatchError::BadOrigin => {
                        ::core::fmt::Formatter::write_str(f, "BadOrigin")
                    }
                    DispatchError::Module(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Module",
                            &__self_0,
                        )
                    }
                    DispatchError::ConsumerRemaining => {
                        ::core::fmt::Formatter::write_str(f, "ConsumerRemaining")
                    }
                    DispatchError::NoProviders => {
                        ::core::fmt::Formatter::write_str(f, "NoProviders")
                    }
                    DispatchError::TooManyConsumers => {
                        ::core::fmt::Formatter::write_str(f, "TooManyConsumers")
                    }
                    DispatchError::Token(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Token",
                            &__self_0,
                        )
                    }
                    DispatchError::Arithmetic(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Arithmetic",
                            &__self_0,
                        )
                    }
                    DispatchError::Transactional(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Transactional",
                            &__self_0,
                        )
                    }
                    DispatchError::Exhausted => {
                        ::core::fmt::Formatter::write_str(f, "Exhausted")
                    }
                    DispatchError::Corruption => {
                        ::core::fmt::Formatter::write_str(f, "Corruption")
                    }
                    DispatchError::Unavailable => {
                        ::core::fmt::Formatter::write_str(f, "Unavailable")
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for DispatchError {}
        #[allow(unused_qualifications)]
        impl ::core::fmt::Display for DispatchError {
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                use thiserror::__private::AsDisplay as _;
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    DispatchError::Other {} => {
                        __formatter.write_str("Some unknown error occurred.")
                    }
                    DispatchError::CannotLookup {} => {
                        __formatter.write_str("Failed to lookup some data.")
                    }
                    DispatchError::BadOrigin {} => __formatter.write_str("Bad origin."),
                    DispatchError::Module(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!("Pallet error: {0}", _0.as_display()),
                            )
                    }
                    DispatchError::ConsumerRemaining {} => {
                        __formatter
                            .write_str(
                                "At least one consumer is remaining so the account cannot be destroyed.",
                            )
                    }
                    DispatchError::NoProviders {} => {
                        __formatter
                            .write_str(
                                "There are no providers so the account cannot be created.",
                            )
                    }
                    DispatchError::TooManyConsumers {} => {
                        __formatter
                            .write_str(
                                "There are too many consumers so the account cannot be created.",
                            )
                    }
                    DispatchError::Token(_0) => {
                        __formatter
                            .write_fmt(format_args!("Token error: {0}", _0.as_display()))
                    }
                    DispatchError::Arithmetic(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!("Arithmetic error: {0}", _0.as_display()),
                            )
                    }
                    DispatchError::Transactional(_0) => {
                        __formatter
                            .write_fmt(
                                format_args!("Transactional error: {0}", _0.as_display()),
                            )
                    }
                    DispatchError::Exhausted {} => {
                        __formatter
                            .write_str(
                                "Resources exhausted, e.g. attempt to read/write data which is too large to manipulate.",
                            )
                    }
                    DispatchError::Corruption {} => {
                        __formatter
                            .write_str(
                                "The state is corrupt; this is generally not going to fix itself.",
                            )
                    }
                    DispatchError::Unavailable {} => {
                        __formatter
                            .write_str(
                                "Some resource (e.g. a preimage) is unavailable right now. This might fix itself later.",
                            )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DispatchError {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DispatchError {
            #[inline]
            fn eq(&self, other: &DispatchError) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            DispatchError::Module(__self_0),
                            DispatchError::Module(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            DispatchError::Token(__self_0),
                            DispatchError::Token(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            DispatchError::Arithmetic(__self_0),
                            DispatchError::Arithmetic(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            DispatchError::Transactional(__self_0),
                            DispatchError::Transactional(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => true,
                    }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for DispatchError {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<ModuleError>;
                let _: ::core::cmp::AssertParamIsEq<TokenError>;
                let _: ::core::cmp::AssertParamIsEq<ArithmeticError>;
                let _: ::core::cmp::AssertParamIsEq<TransactionalError>;
            }
        }
        /// An error relating to tokens when dispatching a transaction.
        #[non_exhaustive]
        pub enum TokenError {
            /// Funds are unavailable.
            #[error("Funds are unavailable.")]
            FundsUnavailable,
            /// Some part of the balance gives the only provider reference to the account and thus cannot be (re)moved.
            #[error(
                "Some part of the balance gives the only provider reference to the account and thus cannot be (re)moved."
            )]
            OnlyProvider,
            /// Account cannot exist with the funds that would be given.
            #[error("Account cannot exist with the funds that would be given.")]
            BelowMinimum,
            /// Account cannot be created.
            #[error("Account cannot be created.")]
            CannotCreate,
            /// The asset in question is unknown.
            #[error("The asset in question is unknown.")]
            UnknownAsset,
            /// Funds exist but are frozen.
            #[error("Funds exist but are frozen.")]
            Frozen,
            /// Operation is not supported by the asset.
            #[error("Operation is not supported by the asset.")]
            Unsupported,
            /// Account cannot be created for a held balance.
            #[error("Account cannot be created for a held balance.")]
            CannotCreateHold,
            /// Withdrawal would cause unwanted loss of account.
            #[error("Withdrawal would cause unwanted loss of account.")]
            NotExpendable,
        }
        const _: () = {
            pub struct Visitor(::core::marker::PhantomData<()>);
            use ::scale_decode::vec;
            use ::scale_decode::ToString;
            impl ::scale_decode::IntoVisitor for TokenError {
                type Visitor = Visitor;
                fn into_visitor() -> Self::Visitor {
                    Visitor(::core::marker::PhantomData)
                }
            }
            impl ::scale_decode::Visitor for Visitor {
                type Error = ::scale_decode::Error;
                type Value<'scale, 'info> = TokenError;
                fn visit_variant<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Variant<'scale, 'info>,
                    type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.name() == "FundsUnavailable" {
                        return Ok(TokenError::FundsUnavailable);
                    }
                    if value.name() == "OnlyProvider" {
                        return Ok(TokenError::OnlyProvider);
                    }
                    if value.name() == "BelowMinimum" {
                        return Ok(TokenError::BelowMinimum);
                    }
                    if value.name() == "CannotCreate" {
                        return Ok(TokenError::CannotCreate);
                    }
                    if value.name() == "UnknownAsset" {
                        return Ok(TokenError::UnknownAsset);
                    }
                    if value.name() == "Frozen" {
                        return Ok(TokenError::Frozen);
                    }
                    if value.name() == "Unsupported" {
                        return Ok(TokenError::Unsupported);
                    }
                    if value.name() == "CannotCreateHold" {
                        return Ok(TokenError::CannotCreateHold);
                    }
                    if value.name() == "NotExpendable" {
                        return Ok(TokenError::NotExpendable);
                    }
                    Err(
                        ::scale_decode::Error::new(::scale_decode::error::ErrorKind::CannotFindVariant {
                            got: value.name().to_string(),
                            expected: <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    "FundsUnavailable",
                                    "OnlyProvider",
                                    "BelowMinimum",
                                    "CannotCreate",
                                    "UnknownAsset",
                                    "Frozen",
                                    "Unsupported",
                                    "CannotCreateHold",
                                    "NotExpendable",
                                ]),
                            ),
                        }),
                    )
                }
                fn visit_composite<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Composite<'scale, 'info>,
                    _type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 1 {
                        return self
                            .visit_unexpected(
                                ::scale_decode::visitor::Unexpected::Composite,
                            );
                    }
                    value.decode_item(self).unwrap()
                }
                fn visit_tuple<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Tuple<'scale, 'info>,
                    _type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 1 {
                        return self
                            .visit_unexpected(
                                ::scale_decode::visitor::Unexpected::Tuple,
                            );
                    }
                    value.decode_item(self).unwrap()
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for TokenError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        TokenError::FundsUnavailable => "FundsUnavailable",
                        TokenError::OnlyProvider => "OnlyProvider",
                        TokenError::BelowMinimum => "BelowMinimum",
                        TokenError::CannotCreate => "CannotCreate",
                        TokenError::UnknownAsset => "UnknownAsset",
                        TokenError::Frozen => "Frozen",
                        TokenError::Unsupported => "Unsupported",
                        TokenError::CannotCreateHold => "CannotCreateHold",
                        TokenError::NotExpendable => "NotExpendable",
                    },
                )
            }
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for TokenError {}
        #[allow(unused_qualifications)]
        impl ::core::fmt::Display for TokenError {
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    TokenError::FundsUnavailable {} => {
                        __formatter.write_str("Funds are unavailable.")
                    }
                    TokenError::OnlyProvider {} => {
                        __formatter
                            .write_str(
                                "Some part of the balance gives the only provider reference to the account and thus cannot be (re)moved.",
                            )
                    }
                    TokenError::BelowMinimum {} => {
                        __formatter
                            .write_str(
                                "Account cannot exist with the funds that would be given.",
                            )
                    }
                    TokenError::CannotCreate {} => {
                        __formatter.write_str("Account cannot be created.")
                    }
                    TokenError::UnknownAsset {} => {
                        __formatter.write_str("The asset in question is unknown.")
                    }
                    TokenError::Frozen {} => {
                        __formatter.write_str("Funds exist but are frozen.")
                    }
                    TokenError::Unsupported {} => {
                        __formatter.write_str("Operation is not supported by the asset.")
                    }
                    TokenError::CannotCreateHold {} => {
                        __formatter
                            .write_str("Account cannot be created for a held balance.")
                    }
                    TokenError::NotExpendable {} => {
                        __formatter
                            .write_str(
                                "Withdrawal would cause unwanted loss of account.",
                            )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TokenError {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TokenError {
            #[inline]
            fn eq(&self, other: &TokenError) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for TokenError {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        /// An error relating to arithmetic when dispatching a transaction.
        #[non_exhaustive]
        pub enum ArithmeticError {
            /// Underflow.
            #[error("Underflow.")]
            Underflow,
            /// Overflow.
            #[error("Overflow.")]
            Overflow,
            /// Division by zero.
            #[error("Division by zero.")]
            DivisionByZero,
        }
        const _: () = {
            pub struct Visitor(::core::marker::PhantomData<()>);
            use ::scale_decode::vec;
            use ::scale_decode::ToString;
            impl ::scale_decode::IntoVisitor for ArithmeticError {
                type Visitor = Visitor;
                fn into_visitor() -> Self::Visitor {
                    Visitor(::core::marker::PhantomData)
                }
            }
            impl ::scale_decode::Visitor for Visitor {
                type Error = ::scale_decode::Error;
                type Value<'scale, 'info> = ArithmeticError;
                fn visit_variant<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Variant<'scale, 'info>,
                    type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.name() == "Underflow" {
                        return Ok(ArithmeticError::Underflow);
                    }
                    if value.name() == "Overflow" {
                        return Ok(ArithmeticError::Overflow);
                    }
                    if value.name() == "DivisionByZero" {
                        return Ok(ArithmeticError::DivisionByZero);
                    }
                    Err(
                        ::scale_decode::Error::new(::scale_decode::error::ErrorKind::CannotFindVariant {
                            got: value.name().to_string(),
                            expected: <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    "Underflow",
                                    "Overflow",
                                    "DivisionByZero",
                                ]),
                            ),
                        }),
                    )
                }
                fn visit_composite<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Composite<'scale, 'info>,
                    _type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 1 {
                        return self
                            .visit_unexpected(
                                ::scale_decode::visitor::Unexpected::Composite,
                            );
                    }
                    value.decode_item(self).unwrap()
                }
                fn visit_tuple<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Tuple<'scale, 'info>,
                    _type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 1 {
                        return self
                            .visit_unexpected(
                                ::scale_decode::visitor::Unexpected::Tuple,
                            );
                    }
                    value.decode_item(self).unwrap()
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for ArithmeticError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ArithmeticError::Underflow => "Underflow",
                        ArithmeticError::Overflow => "Overflow",
                        ArithmeticError::DivisionByZero => "DivisionByZero",
                    },
                )
            }
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for ArithmeticError {}
        #[allow(unused_qualifications)]
        impl ::core::fmt::Display for ArithmeticError {
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    ArithmeticError::Underflow {} => __formatter.write_str("Underflow."),
                    ArithmeticError::Overflow {} => __formatter.write_str("Overflow."),
                    ArithmeticError::DivisionByZero {} => {
                        __formatter.write_str("Division by zero.")
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ArithmeticError {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ArithmeticError {
            #[inline]
            fn eq(&self, other: &ArithmeticError) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ArithmeticError {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        /// An error relating to thr transactional layers when dispatching a transaction.
        #[non_exhaustive]
        pub enum TransactionalError {
            /// Too many transactional layers have been spawned.
            #[error("Too many transactional layers have been spawned.")]
            LimitReached,
            /// A transactional layer was expected, but does not exist.
            #[error("A transactional layer was expected, but does not exist.")]
            NoLayer,
        }
        const _: () = {
            pub struct Visitor(::core::marker::PhantomData<()>);
            use ::scale_decode::vec;
            use ::scale_decode::ToString;
            impl ::scale_decode::IntoVisitor for TransactionalError {
                type Visitor = Visitor;
                fn into_visitor() -> Self::Visitor {
                    Visitor(::core::marker::PhantomData)
                }
            }
            impl ::scale_decode::Visitor for Visitor {
                type Error = ::scale_decode::Error;
                type Value<'scale, 'info> = TransactionalError;
                fn visit_variant<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Variant<'scale, 'info>,
                    type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.name() == "LimitReached" {
                        return Ok(TransactionalError::LimitReached);
                    }
                    if value.name() == "NoLayer" {
                        return Ok(TransactionalError::NoLayer);
                    }
                    Err(
                        ::scale_decode::Error::new(::scale_decode::error::ErrorKind::CannotFindVariant {
                            got: value.name().to_string(),
                            expected: <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new(["LimitReached", "NoLayer"]),
                            ),
                        }),
                    )
                }
                fn visit_composite<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Composite<'scale, 'info>,
                    _type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 1 {
                        return self
                            .visit_unexpected(
                                ::scale_decode::visitor::Unexpected::Composite,
                            );
                    }
                    value.decode_item(self).unwrap()
                }
                fn visit_tuple<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Tuple<'scale, 'info>,
                    _type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 1 {
                        return self
                            .visit_unexpected(
                                ::scale_decode::visitor::Unexpected::Tuple,
                            );
                    }
                    value.decode_item(self).unwrap()
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for TransactionalError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        TransactionalError::LimitReached => "LimitReached",
                        TransactionalError::NoLayer => "NoLayer",
                    },
                )
            }
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for TransactionalError {}
        #[allow(unused_qualifications)]
        impl ::core::fmt::Display for TransactionalError {
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    TransactionalError::LimitReached {} => {
                        __formatter
                            .write_str(
                                "Too many transactional layers have been spawned.",
                            )
                    }
                    TransactionalError::NoLayer {} => {
                        __formatter
                            .write_str(
                                "A transactional layer was expected, but does not exist.",
                            )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TransactionalError {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TransactionalError {
            #[inline]
            fn eq(&self, other: &TransactionalError) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for TransactionalError {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        /// Details about a module error that has occurred.
        #[non_exhaustive]
        pub struct ModuleError {
            metadata: Metadata,
            /// Bytes representation:
            ///  - `bytes[0]`:   pallet index
            ///  - `bytes[1]`:   error index
            ///  - `bytes[2..]`: 3 bytes specific for the module error
            bytes: [u8; 5],
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ModuleError {
            #[inline]
            fn clone(&self) -> ModuleError {
                ModuleError {
                    metadata: ::core::clone::Clone::clone(&self.metadata),
                    bytes: ::core::clone::Clone::clone(&self.bytes),
                }
            }
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for ModuleError {}
        impl PartialEq for ModuleError {
            fn eq(&self, other: &Self) -> bool {
                self.bytes == other.bytes
            }
        }
        impl Eq for ModuleError {}
        /// Custom `Debug` implementation, ignores the very large `metadata` field, using it instead (as
        /// intended) to resolve the actual pallet and error names. This is much more useful for debugging.
        impl Debug for ModuleError {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let details = self.details_string();
                f.write_fmt(format_args!("ModuleError(<{0}>)", details))
            }
        }
        impl std::fmt::Display for ModuleError {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let details = self.details_string();
                f.write_fmt(format_args!("{0}", details))
            }
        }
        impl ModuleError {
            /// Return more details about this error.
            pub fn details(&self) -> Result<ModuleErrorDetails, MetadataError> {
                let pallet = self.metadata.pallet_by_index_err(self.pallet_index())?;
                let variant = pallet
                    .error_variant_by_index(self.error_index())
                    .ok_or_else(|| MetadataError::VariantIndexNotFound(
                        self.error_index(),
                    ))?;
                Ok(ModuleErrorDetails {
                    pallet,
                    variant,
                })
            }
            /// Return a formatted string of the resolved error details for debugging/display purposes.
            pub fn details_string(&self) -> String {
                match self.details() {
                    Ok(details) => {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "{0}::{1}", details.pallet.name(), details.variant.name
                            ),
                        );
                        res
                    }
                    Err(_) => {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "Unknown pallet error \'{0:?}\' (pallet and error details cannot be retrieved)",
                                self.bytes
                            ),
                        );
                        res
                    }
                }
            }
            /// Return the underlying module error data that was decoded.
            pub fn bytes(&self) -> [u8; 5] {
                self.bytes
            }
            /// Obtain the pallet index from the underlying byte data.
            pub fn pallet_index(&self) -> u8 {
                self.bytes[0]
            }
            /// Obtain the error index from the underlying byte data.
            pub fn error_index(&self) -> u8 {
                self.bytes[1]
            }
            /// Attempts to decode the ModuleError into the top outer Error enum.
            pub fn as_root_error<E: DecodeAsType>(&self) -> Result<E, Error> {
                let decoded = E::decode_as_type(
                    &mut &self.bytes[..],
                    self.metadata.outer_enums().error_enum_ty(),
                    self.metadata.types(),
                )?;
                Ok(decoded)
            }
        }
        /// Details about the module error.
        pub struct ModuleErrorDetails<'a> {
            /// The pallet that the error is in
            pub pallet: crate::metadata::types::PalletMetadata<'a>,
            /// The variant representing the error
            pub variant: &'a scale_info::Variant<scale_info::form::PortableForm>,
        }
        impl DispatchError {
            /// Attempt to decode a runtime [`DispatchError`].
            #[doc(hidden)]
            pub fn decode_from<'a>(
                bytes: impl Into<Cow<'a, [u8]>>,
                metadata: Metadata,
            ) -> Result<Self, super::Error> {
                let bytes = bytes.into();
                let dispatch_error_ty_id = metadata
                    .dispatch_error_ty()
                    .ok_or(MetadataError::DispatchErrorNotFound)?;
                enum DecodedDispatchError {
                    Other,
                    CannotLookup,
                    BadOrigin,
                    Module(DecodedModuleErrorBytes),
                    ConsumerRemaining,
                    NoProviders,
                    TooManyConsumers,
                    Token(TokenError),
                    Arithmetic(ArithmeticError),
                    Transactional(TransactionalError),
                    Exhausted,
                    Corruption,
                    Unavailable,
                }
                const _: () = {
                    struct Visitor(::core::marker::PhantomData<()>);
                    use ::scale_decode::vec;
                    use ::scale_decode::ToString;
                    impl ::scale_decode::IntoVisitor for DecodedDispatchError {
                        type Visitor = Visitor;
                        fn into_visitor() -> Self::Visitor {
                            Visitor(::core::marker::PhantomData)
                        }
                    }
                    impl ::scale_decode::Visitor for Visitor {
                        type Error = ::scale_decode::Error;
                        type Value<'scale, 'info> = DecodedDispatchError;
                        fn visit_variant<'scale, 'info>(
                            self,
                            value: &mut ::scale_decode::visitor::types::Variant<
                                'scale,
                                'info,
                            >,
                            type_id: ::scale_decode::visitor::TypeId,
                        ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                            if value.name() == "Other" {
                                return Ok(DecodedDispatchError::Other);
                            }
                            if value.name() == "CannotLookup" {
                                return Ok(DecodedDispatchError::CannotLookup);
                            }
                            if value.name() == "BadOrigin" {
                                return Ok(DecodedDispatchError::BadOrigin);
                            }
                            if value.name() == "Module" {
                                let fields = value.fields();
                                if fields.remaining() != 1usize {
                                    return Err(
                                        ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                            actual_len: fields.remaining(),
                                            expected_len: 1usize,
                                        }),
                                    );
                                }
                                let vals = fields;
                                return Ok(
                                    DecodedDispatchError::Module({
                                        let val = vals
                                            .next()
                                            .expect(
                                                "field count should have been checked already on tuple type; please file a bug report",
                                            )?;
                                        val.decode_as_type().map_err(|e| e.at_idx(0usize))?
                                    }),
                                );
                            }
                            if value.name() == "ConsumerRemaining" {
                                return Ok(DecodedDispatchError::ConsumerRemaining);
                            }
                            if value.name() == "NoProviders" {
                                return Ok(DecodedDispatchError::NoProviders);
                            }
                            if value.name() == "TooManyConsumers" {
                                return Ok(DecodedDispatchError::TooManyConsumers);
                            }
                            if value.name() == "Token" {
                                let fields = value.fields();
                                if fields.remaining() != 1usize {
                                    return Err(
                                        ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                            actual_len: fields.remaining(),
                                            expected_len: 1usize,
                                        }),
                                    );
                                }
                                let vals = fields;
                                return Ok(
                                    DecodedDispatchError::Token({
                                        let val = vals
                                            .next()
                                            .expect(
                                                "field count should have been checked already on tuple type; please file a bug report",
                                            )?;
                                        val.decode_as_type().map_err(|e| e.at_idx(0usize))?
                                    }),
                                );
                            }
                            if value.name() == "Arithmetic" {
                                let fields = value.fields();
                                if fields.remaining() != 1usize {
                                    return Err(
                                        ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                            actual_len: fields.remaining(),
                                            expected_len: 1usize,
                                        }),
                                    );
                                }
                                let vals = fields;
                                return Ok(
                                    DecodedDispatchError::Arithmetic({
                                        let val = vals
                                            .next()
                                            .expect(
                                                "field count should have been checked already on tuple type; please file a bug report",
                                            )?;
                                        val.decode_as_type().map_err(|e| e.at_idx(0usize))?
                                    }),
                                );
                            }
                            if value.name() == "Transactional" {
                                let fields = value.fields();
                                if fields.remaining() != 1usize {
                                    return Err(
                                        ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                            actual_len: fields.remaining(),
                                            expected_len: 1usize,
                                        }),
                                    );
                                }
                                let vals = fields;
                                return Ok(
                                    DecodedDispatchError::Transactional({
                                        let val = vals
                                            .next()
                                            .expect(
                                                "field count should have been checked already on tuple type; please file a bug report",
                                            )?;
                                        val.decode_as_type().map_err(|e| e.at_idx(0usize))?
                                    }),
                                );
                            }
                            if value.name() == "Exhausted" {
                                return Ok(DecodedDispatchError::Exhausted);
                            }
                            if value.name() == "Corruption" {
                                return Ok(DecodedDispatchError::Corruption);
                            }
                            if value.name() == "Unavailable" {
                                return Ok(DecodedDispatchError::Unavailable);
                            }
                            Err(
                                ::scale_decode::Error::new(::scale_decode::error::ErrorKind::CannotFindVariant {
                                    got: value.name().to_string(),
                                    expected: <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            "Other",
                                            "CannotLookup",
                                            "BadOrigin",
                                            "Module",
                                            "ConsumerRemaining",
                                            "NoProviders",
                                            "TooManyConsumers",
                                            "Token",
                                            "Arithmetic",
                                            "Transactional",
                                            "Exhausted",
                                            "Corruption",
                                            "Unavailable",
                                        ]),
                                    ),
                                }),
                            )
                        }
                        fn visit_composite<'scale, 'info>(
                            self,
                            value: &mut ::scale_decode::visitor::types::Composite<
                                'scale,
                                'info,
                            >,
                            _type_id: ::scale_decode::visitor::TypeId,
                        ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                            if value.remaining() != 1 {
                                return self
                                    .visit_unexpected(
                                        ::scale_decode::visitor::Unexpected::Composite,
                                    );
                            }
                            value.decode_item(self).unwrap()
                        }
                        fn visit_tuple<'scale, 'info>(
                            self,
                            value: &mut ::scale_decode::visitor::types::Tuple<
                                'scale,
                                'info,
                            >,
                            _type_id: ::scale_decode::visitor::TypeId,
                        ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                            if value.remaining() != 1 {
                                return self
                                    .visit_unexpected(
                                        ::scale_decode::visitor::Unexpected::Tuple,
                                    );
                            }
                            value.decode_item(self).unwrap()
                        }
                    }
                };
                struct DecodedModuleErrorBytes(Vec<u8>);
                struct DecodedModuleErrorBytesVisitor;
                impl scale_decode::Visitor for DecodedModuleErrorBytesVisitor {
                    type Error = scale_decode::Error;
                    type Value<'scale, 'info> = DecodedModuleErrorBytes;
                    fn unchecked_decode_as_type<'scale, 'info>(
                        self,
                        input: &mut &'scale [u8],
                        _type_id: scale_decode::visitor::TypeId,
                        _types: &'info scale_info::PortableRegistry,
                    ) -> DecodeAsTypeResult<
                        Self,
                        Result<Self::Value<'scale, 'info>, Self::Error>,
                    > {
                        DecodeAsTypeResult::Decoded(
                            Ok(DecodedModuleErrorBytes(input.to_vec())),
                        )
                    }
                }
                impl scale_decode::IntoVisitor for DecodedModuleErrorBytes {
                    type Visitor = DecodedModuleErrorBytesVisitor;
                    fn into_visitor() -> Self::Visitor {
                        DecodedModuleErrorBytesVisitor
                    }
                }
                let decoded_dispatch_err = DecodedDispatchError::decode_with_metadata(
                    &mut &*bytes,
                    dispatch_error_ty_id,
                    &metadata,
                )?;
                let dispatch_error = match decoded_dispatch_err {
                    DecodedDispatchError::Other => DispatchError::Other,
                    DecodedDispatchError::CannotLookup => DispatchError::CannotLookup,
                    DecodedDispatchError::BadOrigin => DispatchError::BadOrigin,
                    DecodedDispatchError::ConsumerRemaining => {
                        DispatchError::ConsumerRemaining
                    }
                    DecodedDispatchError::NoProviders => DispatchError::NoProviders,
                    DecodedDispatchError::TooManyConsumers => {
                        DispatchError::TooManyConsumers
                    }
                    DecodedDispatchError::Token(val) => DispatchError::Token(val),
                    DecodedDispatchError::Arithmetic(val) => {
                        DispatchError::Arithmetic(val)
                    }
                    DecodedDispatchError::Transactional(val) => {
                        DispatchError::Transactional(val)
                    }
                    DecodedDispatchError::Exhausted => DispatchError::Exhausted,
                    DecodedDispatchError::Corruption => DispatchError::Corruption,
                    DecodedDispatchError::Unavailable => DispatchError::Unavailable,
                    DecodedDispatchError::Module(module_bytes) => {
                        let module_bytes = module_bytes.0;
                        let bytes = if module_bytes.len() == 2 {
                            [module_bytes[0], module_bytes[1], 0, 0, 0]
                        } else if module_bytes.len() == 5 {
                            [
                                module_bytes[0],
                                module_bytes[1],
                                module_bytes[2],
                                module_bytes[3],
                                module_bytes[4],
                            ]
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event subxt/src/error/dispatch_error.rs:318",
                                            "subxt::error::dispatch_error",
                                            ::tracing::Level::WARN,
                                            ::core::option::Option::Some(
                                                "subxt/src/error/dispatch_error.rs",
                                            ),
                                            ::core::option::Option::Some(318u32),
                                            ::core::option::Option::Some(
                                                "subxt::error::dispatch_error",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!(
                                                                "Can\'t decode error sp_runtime::DispatchError: bytes do not match known shapes"
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            return Err(super::Error::Unknown(bytes.to_vec()));
                        };
                        DispatchError::Module(ModuleError { metadata, bytes })
                    }
                };
                Ok(dispatch_error)
            }
        }
    }
    pub use dispatch_error::{
        ArithmeticError, DispatchError, ModuleError, TokenError, TransactionalError,
    };
    use subxt_metadata::StorageHasher;
    pub use crate::config::ExtrinsicParamsError;
    pub use crate::metadata::Metadata;
    pub use scale_decode::Error as DecodeError;
    pub use scale_encode::Error as EncodeError;
    pub use subxt_metadata::TryFromError as MetadataTryFromError;
    /// The underlying error enum, generic over the type held by the `Runtime`
    /// variant. Prefer to use the [`Error<E>`] and [`Error`] aliases over
    /// using this type directly.
    #[non_exhaustive]
    pub enum Error {
        /// Io error.
        #[error("Io error: {0}")]
        Io(#[from] std::io::Error),
        /// Codec error.
        #[error("Scale codec error: {0}")]
        Codec(#[from] codec::Error),
        /// Rpc error.
        #[error("Rpc error: {0}")]
        Rpc(#[from] RpcError),
        /// Serde serialization error
        #[error("Serde json error: {0}")]
        Serialization(#[from] serde_json::error::Error),
        /// Error working with metadata.
        #[error("Metadata error: {0}")]
        Metadata(#[from] MetadataError),
        /// Error decoding metadata.
        #[error("Metadata Decoding error: {0}")]
        MetadataDecoding(#[from] MetadataTryFromError),
        /// Runtime error.
        #[error("Runtime error: {0}")]
        Runtime(#[from] DispatchError),
        /// Error decoding to a [`crate::dynamic::Value`].
        #[error("Error decoding into dynamic value: {0}")]
        Decode(#[from] DecodeError),
        /// Error encoding from a [`crate::dynamic::Value`].
        #[error("Error encoding from dynamic value: {0}")]
        Encode(#[from] EncodeError),
        /// Transaction progress error.
        #[error("Transaction error: {0}")]
        Transaction(#[from] TransactionError),
        /// Error constructing the appropriate extrinsic params.
        #[error("Extrinsic params error: {0}")]
        ExtrinsicParams(#[from] ExtrinsicParamsError),
        /// Block related error.
        #[error("Block error: {0}")]
        Block(#[from] BlockError),
        /// An error encoding a storage address.
        #[error("Error encoding storage address: {0}")]
        StorageAddress(#[from] StorageAddressError),
        /// The bytes representing an error that we were unable to decode.
        #[error("An error occurred but it could not be decoded: {0:?}")]
        Unknown(Vec<u8>),
        /// Other error.
        #[error("Other error: {0}")]
        Other(String),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Error {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Error::Io(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Io", &__self_0)
                }
                Error::Codec(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Codec",
                        &__self_0,
                    )
                }
                Error::Rpc(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Rpc",
                        &__self_0,
                    )
                }
                Error::Serialization(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Serialization",
                        &__self_0,
                    )
                }
                Error::Metadata(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Metadata",
                        &__self_0,
                    )
                }
                Error::MetadataDecoding(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "MetadataDecoding",
                        &__self_0,
                    )
                }
                Error::Runtime(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Runtime",
                        &__self_0,
                    )
                }
                Error::Decode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Decode",
                        &__self_0,
                    )
                }
                Error::Encode(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Encode",
                        &__self_0,
                    )
                }
                Error::Transaction(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Transaction",
                        &__self_0,
                    )
                }
                Error::ExtrinsicParams(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ExtrinsicParams",
                        &__self_0,
                    )
                }
                Error::Block(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Block",
                        &__self_0,
                    )
                }
                Error::StorageAddress(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StorageAddress",
                        &__self_0,
                    )
                }
                Error::Unknown(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Unknown",
                        &__self_0,
                    )
                }
                Error::Other(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Other",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for Error {
        fn source(&self) -> ::core::option::Option<&(dyn std::error::Error + 'static)> {
            use thiserror::__private::AsDynError as _;
            #[allow(deprecated)]
            match self {
                Error::Io { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::Codec { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::Rpc { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::Serialization { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::Metadata { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::MetadataDecoding { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::Runtime { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::Decode { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::Encode { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::Transaction { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::ExtrinsicParams { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::Block { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::StorageAddress { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                Error::Unknown { .. } => ::core::option::Option::None,
                Error::Other { .. } => ::core::option::Option::None,
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for Error {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                Error::Io(_0) => {
                    __formatter.write_fmt(format_args!("Io error: {0}", _0.as_display()))
                }
                Error::Codec(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("Scale codec error: {0}", _0.as_display()),
                        )
                }
                Error::Rpc(_0) => {
                    __formatter
                        .write_fmt(format_args!("Rpc error: {0}", _0.as_display()))
                }
                Error::Serialization(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("Serde json error: {0}", _0.as_display()),
                        )
                }
                Error::Metadata(_0) => {
                    __formatter
                        .write_fmt(format_args!("Metadata error: {0}", _0.as_display()))
                }
                Error::MetadataDecoding(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("Metadata Decoding error: {0}", _0.as_display()),
                        )
                }
                Error::Runtime(_0) => {
                    __formatter
                        .write_fmt(format_args!("Runtime error: {0}", _0.as_display()))
                }
                Error::Decode(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Error decoding into dynamic value: {0}", _0.as_display()
                            ),
                        )
                }
                Error::Encode(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Error encoding from dynamic value: {0}", _0.as_display()
                            ),
                        )
                }
                Error::Transaction(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("Transaction error: {0}", _0.as_display()),
                        )
                }
                Error::ExtrinsicParams(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("Extrinsic params error: {0}", _0.as_display()),
                        )
                }
                Error::Block(_0) => {
                    __formatter
                        .write_fmt(format_args!("Block error: {0}", _0.as_display()))
                }
                Error::StorageAddress(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Error encoding storage address: {0}", _0.as_display()
                            ),
                        )
                }
                Error::Unknown(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "An error occurred but it could not be decoded: {0:?}", _0
                            ),
                        )
                }
                Error::Other(_0) => {
                    __formatter
                        .write_fmt(format_args!("Other error: {0}", _0.as_display()))
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<std::io::Error> for Error {
        #[allow(deprecated)]
        fn from(source: std::io::Error) -> Self {
            Error::Io { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<codec::Error> for Error {
        #[allow(deprecated)]
        fn from(source: codec::Error) -> Self {
            Error::Codec { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<RpcError> for Error {
        #[allow(deprecated)]
        fn from(source: RpcError) -> Self {
            Error::Rpc { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<serde_json::error::Error> for Error {
        #[allow(deprecated)]
        fn from(source: serde_json::error::Error) -> Self {
            Error::Serialization { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<MetadataError> for Error {
        #[allow(deprecated)]
        fn from(source: MetadataError) -> Self {
            Error::Metadata { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<MetadataTryFromError> for Error {
        #[allow(deprecated)]
        fn from(source: MetadataTryFromError) -> Self {
            Error::MetadataDecoding {
                0: source,
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<DispatchError> for Error {
        #[allow(deprecated)]
        fn from(source: DispatchError) -> Self {
            Error::Runtime { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<DecodeError> for Error {
        #[allow(deprecated)]
        fn from(source: DecodeError) -> Self {
            Error::Decode { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<EncodeError> for Error {
        #[allow(deprecated)]
        fn from(source: EncodeError) -> Self {
            Error::Encode { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<TransactionError> for Error {
        #[allow(deprecated)]
        fn from(source: TransactionError) -> Self {
            Error::Transaction { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<ExtrinsicParamsError> for Error {
        #[allow(deprecated)]
        fn from(source: ExtrinsicParamsError) -> Self {
            Error::ExtrinsicParams {
                0: source,
            }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<BlockError> for Error {
        #[allow(deprecated)]
        fn from(source: BlockError) -> Self {
            Error::Block { 0: source }
        }
    }
    #[allow(unused_qualifications)]
    impl ::core::convert::From<StorageAddressError> for Error {
        #[allow(deprecated)]
        fn from(source: StorageAddressError) -> Self {
            Error::StorageAddress { 0: source }
        }
    }
    impl<'a> From<&'a str> for Error {
        fn from(error: &'a str) -> Self {
            Error::Other(error.into())
        }
    }
    impl From<String> for Error {
        fn from(error: String) -> Self {
            Error::Other(error)
        }
    }
    impl From<std::convert::Infallible> for Error {
        fn from(value: std::convert::Infallible) -> Self {
            match value {}
        }
    }
    impl Error {
        /// Checks whether the error was caused by a RPC re-connection.
        pub fn is_disconnected_will_reconnect(&self) -> bool {
            match self {
                Error::Rpc(RpcError::DisconnectedWillReconnect(_)) => true,
                _ => false,
            }
        }
    }
    /// An RPC error. Since we are generic over the RPC client that is used,
    /// the error is boxed and could be casted.
    #[non_exhaustive]
    pub enum RpcError {
        /// Error related to the RPC client.
        #[error("RPC error: {0}")]
        ClientError(Box<dyn std::error::Error + Send + Sync + 'static>),
        /// This error signals that the request was rejected for some reason.
        /// The specific reason is provided.
        #[error("RPC error: request rejected: {0}")]
        RequestRejected(String),
        /// The RPC subscription dropped.
        #[error("RPC error: subscription dropped.")]
        SubscriptionDropped,
        /// The requested URL is insecure.
        #[error("RPC error: insecure URL: {0}")]
        InsecureUrl(String),
        /// The connection was lost and automatically reconnected.
        #[error(
            "RPC error: the connection was lost `{0}`; reconnect automatically initiated"
        )]
        DisconnectedWillReconnect(String),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RpcError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                RpcError::ClientError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ClientError",
                        &__self_0,
                    )
                }
                RpcError::RequestRejected(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RequestRejected",
                        &__self_0,
                    )
                }
                RpcError::SubscriptionDropped => {
                    ::core::fmt::Formatter::write_str(f, "SubscriptionDropped")
                }
                RpcError::InsecureUrl(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "InsecureUrl",
                        &__self_0,
                    )
                }
                RpcError::DisconnectedWillReconnect(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DisconnectedWillReconnect",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for RpcError {}
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for RpcError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                RpcError::ClientError(_0) => {
                    __formatter
                        .write_fmt(format_args!("RPC error: {0}", _0.as_display()))
                }
                RpcError::RequestRejected(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "RPC error: request rejected: {0}", _0.as_display()
                            ),
                        )
                }
                RpcError::SubscriptionDropped {} => {
                    __formatter.write_str("RPC error: subscription dropped.")
                }
                RpcError::InsecureUrl(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("RPC error: insecure URL: {0}", _0.as_display()),
                        )
                }
                RpcError::DisconnectedWillReconnect(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "RPC error: the connection was lost `{0}`; reconnect automatically initiated",
                                _0.as_display()
                            ),
                        )
                }
            }
        }
    }
    impl RpcError {
        /// Create a `RequestRejected` error from anything that can be turned into a string.
        pub fn request_rejected<S: Into<String>>(s: S) -> RpcError {
            RpcError::RequestRejected(s.into())
        }
    }
    /// Block error
    #[non_exhaustive]
    pub enum BlockError {
        /// An error containing the hash of the block that was not found.
        #[error(
            "Could not find a block with hash {0} (perhaps it was on a non-finalized fork?)"
        )]
        NotFound(String),
        /// Extrinsic type ID cannot be resolved with the provided metadata.
        #[error(
            "Extrinsic type ID cannot be resolved with the provided metadata. Make sure this is a valid metadata"
        )]
        MissingType,
        /// Unsupported signature.
        #[error("Unsupported extrinsic version, only version 4 is supported currently")]
        /// The extrinsic has an unsupported version.
        UnsupportedVersion(u8),
        /// Decoding error.
        #[error("Cannot decode extrinsic: {0}")]
        DecodingError(codec::Error),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for BlockError {
        #[inline]
        fn clone(&self) -> BlockError {
            match self {
                BlockError::NotFound(__self_0) => {
                    BlockError::NotFound(::core::clone::Clone::clone(__self_0))
                }
                BlockError::MissingType => BlockError::MissingType,
                BlockError::UnsupportedVersion(__self_0) => {
                    BlockError::UnsupportedVersion(::core::clone::Clone::clone(__self_0))
                }
                BlockError::DecodingError(__self_0) => {
                    BlockError::DecodingError(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for BlockError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                BlockError::NotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NotFound",
                        &__self_0,
                    )
                }
                BlockError::MissingType => {
                    ::core::fmt::Formatter::write_str(f, "MissingType")
                }
                BlockError::UnsupportedVersion(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UnsupportedVersion",
                        &__self_0,
                    )
                }
                BlockError::DecodingError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DecodingError",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for BlockError {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<u8>;
            let _: ::core::cmp::AssertParamIsEq<codec::Error>;
        }
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for BlockError {}
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for BlockError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                BlockError::NotFound(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Could not find a block with hash {0} (perhaps it was on a non-finalized fork?)",
                                _0.as_display()
                            ),
                        )
                }
                BlockError::MissingType {} => {
                    __formatter
                        .write_str(
                            "Extrinsic type ID cannot be resolved with the provided metadata. Make sure this is a valid metadata",
                        )
                }
                BlockError::UnsupportedVersion(_0) => {
                    __formatter
                        .write_str(
                            "Unsupported extrinsic version, only version 4 is supported currently",
                        )
                }
                BlockError::DecodingError(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("Cannot decode extrinsic: {0}", _0.as_display()),
                        )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for BlockError {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for BlockError {
        #[inline]
        fn eq(&self, other: &BlockError) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (BlockError::NotFound(__self_0), BlockError::NotFound(__arg1_0)) => {
                        *__self_0 == *__arg1_0
                    }
                    (
                        BlockError::UnsupportedVersion(__self_0),
                        BlockError::UnsupportedVersion(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        BlockError::DecodingError(__self_0),
                        BlockError::DecodingError(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => true,
                }
        }
    }
    impl BlockError {
        /// Produce an error that a block with the given hash cannot be found.
        pub fn not_found(hash: impl AsRef<[u8]>) -> BlockError {
            let hash = {
                let res = ::alloc::fmt::format(format_args!("0x{0}", hex::encode(hash)));
                res
            };
            BlockError::NotFound(hash)
        }
    }
    /// Transaction error.
    #[non_exhaustive]
    pub enum TransactionError {
        /// The block hash that the transaction was added to could not be found.
        /// This is probably because the block was retracted before being finalized.
        #[error(
            "The block containing the transaction can no longer be found (perhaps it was on a non-finalized fork?)"
        )]
        BlockNotFound,
        /// An error happened on the node that the transaction was submitted to.
        #[error("Error handling transaction: {0}")]
        Error(String),
        /// The transaction was deemed invalid.
        #[error("The transaction is not valid: {0}")]
        Invalid(String),
        /// The transaction was dropped.
        #[error("The transaction was dropped: {0}")]
        Dropped(String),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TransactionError {
        #[inline]
        fn clone(&self) -> TransactionError {
            match self {
                TransactionError::BlockNotFound => TransactionError::BlockNotFound,
                TransactionError::Error(__self_0) => {
                    TransactionError::Error(::core::clone::Clone::clone(__self_0))
                }
                TransactionError::Invalid(__self_0) => {
                    TransactionError::Invalid(::core::clone::Clone::clone(__self_0))
                }
                TransactionError::Dropped(__self_0) => {
                    TransactionError::Dropped(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TransactionError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TransactionError::BlockNotFound => {
                    ::core::fmt::Formatter::write_str(f, "BlockNotFound")
                }
                TransactionError::Error(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Error",
                        &__self_0,
                    )
                }
                TransactionError::Invalid(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Invalid",
                        &__self_0,
                    )
                }
                TransactionError::Dropped(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Dropped",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TransactionError {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for TransactionError {}
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for TransactionError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                TransactionError::BlockNotFound {} => {
                    __formatter
                        .write_str(
                            "The block containing the transaction can no longer be found (perhaps it was on a non-finalized fork?)",
                        )
                }
                TransactionError::Error(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Error handling transaction: {0}", _0.as_display()
                            ),
                        )
                }
                TransactionError::Invalid(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "The transaction is not valid: {0}", _0.as_display()
                            ),
                        )
                }
                TransactionError::Dropped(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "The transaction was dropped: {0}", _0.as_display()
                            ),
                        )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TransactionError {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TransactionError {
        #[inline]
        fn eq(&self, other: &TransactionError) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        TransactionError::Error(__self_0),
                        TransactionError::Error(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        TransactionError::Invalid(__self_0),
                        TransactionError::Invalid(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        TransactionError::Dropped(__self_0),
                        TransactionError::Dropped(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => true,
                }
        }
    }
    /// Something went wrong trying to encode a storage address.
    #[non_exhaustive]
    pub enum StorageAddressError {
        /// Storage map type must be a composite type.
        #[error("Storage map type must be a composite type")]
        MapTypeMustBeTuple,
        /// Storage lookup does not have the expected number of keys.
        #[error("Storage lookup requires {expected} keys but got {actual} keys")]
        WrongNumberOfKeys {
            /// The actual number of keys needed, based on the metadata.
            actual: usize,
            /// The number of keys provided in the storage address.
            expected: usize,
        },
        /// This storage entry in the metadata does not have the correct number of hashers to fields.
        #[error(
            "Storage entry in metadata does not have the correct number of hashers to fields"
        )]
        WrongNumberOfHashers {
            /// The number of hashers in the metadata for this storage entry.
            hashers: usize,
            /// The number of fields in the metadata for this storage entry.
            fields: usize,
        },
        /// The bytes of a storage address are not the expected address for decoding the storage keys of the address.
        #[error(
            "Storage address bytes are not the expected format. Addresses need to be at least 16 bytes (pallet ++ entry) and follow a structure given by the hashers defined in the metadata."
        )]
        UnexpectedAddressBytes,
        /// An invalid hasher was used to reconstruct a value from a chunk of bytes that is part of a storage address. Hashers where the hash does not contain the original value are invalid for this purpose.
        #[error(
            "An invalid hasher was used to reconstruct a value of type {ty_name} (id={ty_id}) from a hash formed by a {hasher:?} hasher. This is only possible for concat-style hashers or the identity hasher"
        )]
        HasherCannotReconstructKey {
            /// Type id of the key's type.
            ty_id: u32,
            /// Type name of the key's type.
            ty_name: String,
            /// The invalid hasher that caused this error.
            hasher: StorageHasher,
        },
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StorageAddressError {
        #[inline]
        fn clone(&self) -> StorageAddressError {
            match self {
                StorageAddressError::MapTypeMustBeTuple => {
                    StorageAddressError::MapTypeMustBeTuple
                }
                StorageAddressError::WrongNumberOfKeys {
                    actual: __self_0,
                    expected: __self_1,
                } => {
                    StorageAddressError::WrongNumberOfKeys {
                        actual: ::core::clone::Clone::clone(__self_0),
                        expected: ::core::clone::Clone::clone(__self_1),
                    }
                }
                StorageAddressError::WrongNumberOfHashers {
                    hashers: __self_0,
                    fields: __self_1,
                } => {
                    StorageAddressError::WrongNumberOfHashers {
                        hashers: ::core::clone::Clone::clone(__self_0),
                        fields: ::core::clone::Clone::clone(__self_1),
                    }
                }
                StorageAddressError::UnexpectedAddressBytes => {
                    StorageAddressError::UnexpectedAddressBytes
                }
                StorageAddressError::HasherCannotReconstructKey {
                    ty_id: __self_0,
                    ty_name: __self_1,
                    hasher: __self_2,
                } => {
                    StorageAddressError::HasherCannotReconstructKey {
                        ty_id: ::core::clone::Clone::clone(__self_0),
                        ty_name: ::core::clone::Clone::clone(__self_1),
                        hasher: ::core::clone::Clone::clone(__self_2),
                    }
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StorageAddressError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                StorageAddressError::MapTypeMustBeTuple => {
                    ::core::fmt::Formatter::write_str(f, "MapTypeMustBeTuple")
                }
                StorageAddressError::WrongNumberOfKeys {
                    actual: __self_0,
                    expected: __self_1,
                } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "WrongNumberOfKeys",
                        "actual",
                        __self_0,
                        "expected",
                        &__self_1,
                    )
                }
                StorageAddressError::WrongNumberOfHashers {
                    hashers: __self_0,
                    fields: __self_1,
                } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "WrongNumberOfHashers",
                        "hashers",
                        __self_0,
                        "fields",
                        &__self_1,
                    )
                }
                StorageAddressError::UnexpectedAddressBytes => {
                    ::core::fmt::Formatter::write_str(f, "UnexpectedAddressBytes")
                }
                StorageAddressError::HasherCannotReconstructKey {
                    ty_id: __self_0,
                    ty_name: __self_1,
                    hasher: __self_2,
                } => {
                    ::core::fmt::Formatter::debug_struct_field3_finish(
                        f,
                        "HasherCannotReconstructKey",
                        "ty_id",
                        __self_0,
                        "ty_name",
                        __self_1,
                        "hasher",
                        &__self_2,
                    )
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for StorageAddressError {}
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for StorageAddressError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                StorageAddressError::MapTypeMustBeTuple {} => {
                    __formatter.write_str("Storage map type must be a composite type")
                }
                StorageAddressError::WrongNumberOfKeys { actual, expected } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Storage lookup requires {0} keys but got {1} keys",
                                expected.as_display(), actual.as_display()
                            ),
                        )
                }
                StorageAddressError::WrongNumberOfHashers { hashers, fields } => {
                    __formatter
                        .write_str(
                            "Storage entry in metadata does not have the correct number of hashers to fields",
                        )
                }
                StorageAddressError::UnexpectedAddressBytes {} => {
                    __formatter
                        .write_str(
                            "Storage address bytes are not the expected format. Addresses need to be at least 16 bytes (pallet ++ entry) and follow a structure given by the hashers defined in the metadata.",
                        )
                }
                StorageAddressError::HasherCannotReconstructKey {
                    ty_id,
                    ty_name,
                    hasher,
                } => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "An invalid hasher was used to reconstruct a value of type {0} (id={1}) from a hash formed by a {2:?} hasher. This is only possible for concat-style hashers or the identity hasher",
                                ty_name.as_display(), ty_id.as_display(), hasher
                            ),
                        )
                }
            }
        }
    }
    /// Something went wrong trying to access details in the metadata.
    #[non_exhaustive]
    pub enum MetadataError {
        /// The DispatchError type isn't available in the metadata
        #[error("The DispatchError type isn't available")]
        DispatchErrorNotFound,
        /// Type not found in metadata.
        #[error("Type with ID {0} not found")]
        TypeNotFound(u32),
        /// Pallet not found (index).
        #[error("Pallet with index {0} not found")]
        PalletIndexNotFound(u8),
        /// Pallet not found (name).
        #[error("Pallet with name {0} not found")]
        PalletNameNotFound(String),
        /// Variant not found.
        #[error("Variant with index {0} not found")]
        VariantIndexNotFound(u8),
        /// Constant not found.
        #[error("Constant with name {0} not found")]
        ConstantNameNotFound(String),
        /// Call not found.
        #[error("Call with name {0} not found")]
        CallNameNotFound(String),
        /// Runtime trait not found.
        #[error("Runtime trait with name {0} not found")]
        RuntimeTraitNotFound(String),
        /// Runtime method not found.
        #[error("Runtime method with name {0} not found")]
        RuntimeMethodNotFound(String),
        /// Call type not found in metadata.
        #[error("Call type not found in pallet with index {0}")]
        CallTypeNotFoundInPallet(u8),
        /// Event type not found in metadata.
        #[error("Event type not found in pallet with index {0}")]
        EventTypeNotFoundInPallet(u8),
        /// Storage details not found in metadata.
        #[error("Storage details not found in pallet with name {0}")]
        StorageNotFoundInPallet(String),
        /// Storage entry not found.
        #[error("Storage entry {0} not found")]
        StorageEntryNotFound(String),
        /// The generated interface used is not compatible with the node.
        #[error("The generated code is not compatible with the node")]
        IncompatibleCodegen,
        /// Custom value not found.
        #[error("Custom value with name {0} not found")]
        CustomValueNameNotFound(String),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MetadataError {
        #[inline]
        fn clone(&self) -> MetadataError {
            match self {
                MetadataError::DispatchErrorNotFound => {
                    MetadataError::DispatchErrorNotFound
                }
                MetadataError::TypeNotFound(__self_0) => {
                    MetadataError::TypeNotFound(::core::clone::Clone::clone(__self_0))
                }
                MetadataError::PalletIndexNotFound(__self_0) => {
                    MetadataError::PalletIndexNotFound(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                MetadataError::PalletNameNotFound(__self_0) => {
                    MetadataError::PalletNameNotFound(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                MetadataError::VariantIndexNotFound(__self_0) => {
                    MetadataError::VariantIndexNotFound(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                MetadataError::ConstantNameNotFound(__self_0) => {
                    MetadataError::ConstantNameNotFound(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                MetadataError::CallNameNotFound(__self_0) => {
                    MetadataError::CallNameNotFound(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                MetadataError::RuntimeTraitNotFound(__self_0) => {
                    MetadataError::RuntimeTraitNotFound(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                MetadataError::RuntimeMethodNotFound(__self_0) => {
                    MetadataError::RuntimeMethodNotFound(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                MetadataError::CallTypeNotFoundInPallet(__self_0) => {
                    MetadataError::CallTypeNotFoundInPallet(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                MetadataError::EventTypeNotFoundInPallet(__self_0) => {
                    MetadataError::EventTypeNotFoundInPallet(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                MetadataError::StorageNotFoundInPallet(__self_0) => {
                    MetadataError::StorageNotFoundInPallet(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                MetadataError::StorageEntryNotFound(__self_0) => {
                    MetadataError::StorageEntryNotFound(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                MetadataError::IncompatibleCodegen => MetadataError::IncompatibleCodegen,
                MetadataError::CustomValueNameNotFound(__self_0) => {
                    MetadataError::CustomValueNameNotFound(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MetadataError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                MetadataError::DispatchErrorNotFound => {
                    ::core::fmt::Formatter::write_str(f, "DispatchErrorNotFound")
                }
                MetadataError::TypeNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TypeNotFound",
                        &__self_0,
                    )
                }
                MetadataError::PalletIndexNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PalletIndexNotFound",
                        &__self_0,
                    )
                }
                MetadataError::PalletNameNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PalletNameNotFound",
                        &__self_0,
                    )
                }
                MetadataError::VariantIndexNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "VariantIndexNotFound",
                        &__self_0,
                    )
                }
                MetadataError::ConstantNameNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ConstantNameNotFound",
                        &__self_0,
                    )
                }
                MetadataError::CallNameNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CallNameNotFound",
                        &__self_0,
                    )
                }
                MetadataError::RuntimeTraitNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RuntimeTraitNotFound",
                        &__self_0,
                    )
                }
                MetadataError::RuntimeMethodNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RuntimeMethodNotFound",
                        &__self_0,
                    )
                }
                MetadataError::CallTypeNotFoundInPallet(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CallTypeNotFoundInPallet",
                        &__self_0,
                    )
                }
                MetadataError::EventTypeNotFoundInPallet(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "EventTypeNotFoundInPallet",
                        &__self_0,
                    )
                }
                MetadataError::StorageNotFoundInPallet(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StorageNotFoundInPallet",
                        &__self_0,
                    )
                }
                MetadataError::StorageEntryNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StorageEntryNotFound",
                        &__self_0,
                    )
                }
                MetadataError::IncompatibleCodegen => {
                    ::core::fmt::Formatter::write_str(f, "IncompatibleCodegen")
                }
                MetadataError::CustomValueNameNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CustomValueNameNotFound",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MetadataError {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MetadataError {
        #[inline]
        fn eq(&self, other: &MetadataError) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        MetadataError::TypeNotFound(__self_0),
                        MetadataError::TypeNotFound(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MetadataError::PalletIndexNotFound(__self_0),
                        MetadataError::PalletIndexNotFound(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MetadataError::PalletNameNotFound(__self_0),
                        MetadataError::PalletNameNotFound(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MetadataError::VariantIndexNotFound(__self_0),
                        MetadataError::VariantIndexNotFound(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MetadataError::ConstantNameNotFound(__self_0),
                        MetadataError::ConstantNameNotFound(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MetadataError::CallNameNotFound(__self_0),
                        MetadataError::CallNameNotFound(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MetadataError::RuntimeTraitNotFound(__self_0),
                        MetadataError::RuntimeTraitNotFound(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MetadataError::RuntimeMethodNotFound(__self_0),
                        MetadataError::RuntimeMethodNotFound(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MetadataError::CallTypeNotFoundInPallet(__self_0),
                        MetadataError::CallTypeNotFoundInPallet(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MetadataError::EventTypeNotFoundInPallet(__self_0),
                        MetadataError::EventTypeNotFoundInPallet(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MetadataError::StorageNotFoundInPallet(__self_0),
                        MetadataError::StorageNotFoundInPallet(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MetadataError::StorageEntryNotFound(__self_0),
                        MetadataError::StorageEntryNotFound(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    (
                        MetadataError::CustomValueNameNotFound(__self_0),
                        MetadataError::CustomValueNameNotFound(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => true,
                }
        }
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for MetadataError {}
    #[allow(unused_qualifications)]
    impl ::core::fmt::Display for MetadataError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                MetadataError::DispatchErrorNotFound {} => {
                    __formatter.write_str("The DispatchError type isn't available")
                }
                MetadataError::TypeNotFound(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("Type with ID {0} not found", _0.as_display()),
                        )
                }
                MetadataError::PalletIndexNotFound(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Pallet with index {0} not found", _0.as_display()
                            ),
                        )
                }
                MetadataError::PalletNameNotFound(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Pallet with name {0} not found", _0.as_display()
                            ),
                        )
                }
                MetadataError::VariantIndexNotFound(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Variant with index {0} not found", _0.as_display()
                            ),
                        )
                }
                MetadataError::ConstantNameNotFound(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Constant with name {0} not found", _0.as_display()
                            ),
                        )
                }
                MetadataError::CallNameNotFound(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("Call with name {0} not found", _0.as_display()),
                        )
                }
                MetadataError::RuntimeTraitNotFound(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Runtime trait with name {0} not found", _0.as_display()
                            ),
                        )
                }
                MetadataError::RuntimeMethodNotFound(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Runtime method with name {0} not found", _0.as_display()
                            ),
                        )
                }
                MetadataError::CallTypeNotFoundInPallet(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Call type not found in pallet with index {0}", _0
                                .as_display()
                            ),
                        )
                }
                MetadataError::EventTypeNotFoundInPallet(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Event type not found in pallet with index {0}", _0
                                .as_display()
                            ),
                        )
                }
                MetadataError::StorageNotFoundInPallet(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Storage details not found in pallet with name {0}", _0
                                .as_display()
                            ),
                        )
                }
                MetadataError::StorageEntryNotFound(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!("Storage entry {0} not found", _0.as_display()),
                        )
                }
                MetadataError::IncompatibleCodegen {} => {
                    __formatter
                        .write_str("The generated code is not compatible with the node")
                }
                MetadataError::CustomValueNameNotFound(_0) => {
                    __formatter
                        .write_fmt(
                            format_args!(
                                "Custom value with name {0} not found", _0.as_display()
                            ),
                        )
                }
            }
        }
    }
}
pub mod events {
    //! This module exposes the types and such necessary for working with events.
    //! The two main entry points into events are [`crate::OnlineClient::events()`]
    //! and calls like [crate::tx::TxProgress::wait_for_finalized_success()].
    mod events_client {
        use crate::backend::{Backend, BackendExt, BlockRef};
        use crate::{client::OnlineClientT, error::Error, events::Events, Config};
        use derivative::Derivative;
        use std::future::Future;
        /// A client for working with events.
        #[derivative(Clone(bound = "Client: Clone"))]
        pub struct EventsClient<T, Client> {
            client: Client,
            _marker: std::marker::PhantomData<T>,
        }
        #[allow(unused_qualifications)]
        impl<T, Client> ::std::clone::Clone for EventsClient<T, Client>
        where
            Client: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    EventsClient { client: ref __arg_0, _marker: ref __arg_1 } => {
                        EventsClient {
                            client: (*__arg_0).clone(),
                            _marker: (*__arg_1).clone(),
                        }
                    }
                }
            }
        }
        impl<T, Client> EventsClient<T, Client> {
            /// Create a new [`EventsClient`].
            pub fn new(client: Client) -> Self {
                Self {
                    client,
                    _marker: std::marker::PhantomData,
                }
            }
        }
        impl<T, Client> EventsClient<T, Client>
        where
            T: Config,
            Client: OnlineClientT<T>,
        {
            /// Obtain events at some block hash.
            ///
            /// # Warning
            ///
            /// This call only supports blocks produced since the most recent
            /// runtime upgrade. You can attempt to retrieve events from older blocks,
            /// but may run into errors attempting to work with them.
            pub fn at(
                &self,
                block_ref: impl Into<BlockRef<T::Hash>>,
            ) -> impl Future<Output = Result<Events<T>, Error>> + Send + 'static {
                self.at_or_latest(Some(block_ref.into()))
            }
            /// Obtain events for the latest block.
            pub fn at_latest(
                &self,
            ) -> impl Future<Output = Result<Events<T>, Error>> + Send + 'static {
                self.at_or_latest(None)
            }
            /// Obtain events at some block hash.
            fn at_or_latest(
                &self,
                block_ref: Option<BlockRef<T::Hash>>,
            ) -> impl Future<Output = Result<Events<T>, Error>> + Send + 'static {
                let client = self.client.clone();
                async move {
                    let block_ref = match block_ref {
                        Some(r) => r,
                        None => client.backend().latest_finalized_block_ref().await?,
                    };
                    let event_bytes = get_event_bytes(client.backend(), block_ref.hash())
                        .await?;
                    Ok(Events::new(client.metadata(), block_ref.hash(), event_bytes))
                }
            }
        }
        fn system_events_key() -> [u8; 32] {
            let a = sp_core_hashing::twox_128(b"System");
            let b = sp_core_hashing::twox_128(b"Events");
            let mut res = [0; 32];
            res[0..16].clone_from_slice(&a);
            res[16..32].clone_from_slice(&b);
            res
        }
        pub(crate) async fn get_event_bytes<T: Config>(
            backend: &dyn Backend<T>,
            block_hash: T::Hash,
        ) -> Result<Vec<u8>, Error> {
            Ok(
                backend
                    .storage_fetch_value(system_events_key().to_vec(), block_hash)
                    .await?
                    .unwrap_or_default(),
            )
        }
    }
    mod events_type {
        //! A representation of a block of events.
        use super::{Phase, StaticEvent};
        use crate::{
            client::OnlineClientT, error::{Error, MetadataError},
            events::events_client::get_event_bytes, metadata::types::PalletMetadata,
            Config, Metadata,
        };
        use codec::{Compact, Decode};
        use derivative::Derivative;
        use scale_decode::DecodeAsType;
        use std::sync::Arc;
        /// A collection of events obtained from a block, bundled with the necessary
        /// information needed to decode and iterate over them.
        #[derivative(Clone(bound = ""))]
        pub struct Events<T: Config> {
            metadata: Metadata,
            block_hash: T::Hash,
            event_bytes: Arc<[u8]>,
            start_idx: usize,
            num_events: u32,
        }
        #[allow(unused_qualifications)]
        impl<T: Config> ::std::clone::Clone for Events<T> {
            fn clone(&self) -> Self {
                match *self {
                    Events {
                        metadata: ref __arg_0,
                        block_hash: ref __arg_1,
                        event_bytes: ref __arg_2,
                        start_idx: ref __arg_3,
                        num_events: ref __arg_4,
                    } => {
                        Events {
                            metadata: (*__arg_0).clone(),
                            block_hash: (*__arg_1).clone(),
                            event_bytes: (*__arg_2).clone(),
                            start_idx: (*__arg_3).clone(),
                            num_events: (*__arg_4).clone(),
                        }
                    }
                }
            }
        }
        impl<T: Config> std::fmt::Debug for Events<T> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.debug_struct("Events")
                    .field("block_hash", &self.block_hash)
                    .field("event_bytes", &self.event_bytes)
                    .field("start_idx", &self.start_idx)
                    .field("num_events", &self.num_events)
                    .finish()
            }
        }
        impl<T: Config> Events<T> {
            pub(crate) fn new(
                metadata: Metadata,
                block_hash: T::Hash,
                event_bytes: Vec<u8>,
            ) -> Self {
                let cursor = &mut &*event_bytes;
                let num_events = <Compact<u32>>::decode(cursor).unwrap_or(Compact(0)).0;
                let start_idx = event_bytes.len() - cursor.len();
                Self {
                    metadata,
                    block_hash,
                    event_bytes: event_bytes.into(),
                    start_idx,
                    num_events,
                }
            }
            /// Obtain the events from a block hash given custom metadata and a client.
            ///
            /// # Notes
            ///
            /// - Prefer to use [`crate::events::EventsClient::at`] to obtain the events.
            /// - Subxt may fail to decode things that aren't from a runtime using the
            ///   latest metadata version.
            /// - The client may not be able to obtain the block at the given hash. Only
            ///   archive nodes keep hold of all past block information.
            pub async fn new_from_client<Client>(
                metadata: Metadata,
                block_hash: T::Hash,
                client: Client,
            ) -> Result<Self, Error>
            where
                Client: OnlineClientT<T>,
            {
                let event_bytes = get_event_bytes(client.backend(), block_hash).await?;
                Ok(Events::new(metadata, block_hash, event_bytes))
            }
            /// The number of events.
            pub fn len(&self) -> u32 {
                self.num_events
            }
            /// Are there no events in this block?
            pub fn is_empty(&self) -> bool {
                self.num_events == 0
            }
            /// Return the block hash that these events are from.
            pub fn block_hash(&self) -> T::Hash {
                self.block_hash
            }
            /// Iterate over all of the events, using metadata to dynamically
            /// decode them as we go, and returning the raw bytes and other associated
            /// details. If an error occurs, all subsequent iterations return `None`.
            pub fn iter(
                &self,
            ) -> impl Iterator<
                Item = Result<EventDetails<T>, Error>,
            > + Send + Sync + 'static {
                let event_bytes = self.event_bytes.clone();
                let metadata = self.metadata.clone();
                let num_events = self.num_events;
                let mut pos = self.start_idx;
                let mut index = 0;
                std::iter::from_fn(move || {
                    if event_bytes.len() <= pos || num_events == index {
                        None
                    } else {
                        match EventDetails::decode_from(
                            metadata.clone(),
                            event_bytes.clone(),
                            pos,
                            index,
                        ) {
                            Ok(event_details) => {
                                pos += event_details.bytes().len();
                                index += 1;
                                Some(Ok(event_details))
                            }
                            Err(e) => {
                                pos = event_bytes.len();
                                Some(Err(e))
                            }
                        }
                    }
                })
            }
            /// Iterate through the events using metadata to dynamically decode and skip
            /// them, and return only those which should decode to the provided `Ev` type.
            /// If an error occurs, all subsequent iterations return `None`.
            pub fn find<Ev: StaticEvent>(
                &self,
            ) -> impl Iterator<Item = Result<Ev, Error>> + '_ {
                self.iter()
                    .filter_map(|ev| {
                        ev.and_then(|ev| ev.as_event::<Ev>().map_err(Into::into))
                            .transpose()
                    })
            }
            /// Iterate through the events using metadata to dynamically decode and skip
            /// them, and return the first event found which decodes to the provided `Ev` type.
            pub fn find_first<Ev: StaticEvent>(&self) -> Result<Option<Ev>, Error> {
                self.find::<Ev>().next().transpose()
            }
            /// Iterate through the events using metadata to dynamically decode and skip
            /// them, and return the last event found which decodes to the provided `Ev` type.
            pub fn find_last<Ev: StaticEvent>(&self) -> Result<Option<Ev>, Error> {
                self.find::<Ev>().last().transpose()
            }
            /// Find an event that decodes to the type provided. Returns true if it was found.
            pub fn has<Ev: StaticEvent>(&self) -> Result<bool, Error> {
                Ok(self.find::<Ev>().next().transpose()?.is_some())
            }
        }
        /// The event details.
        pub struct EventDetails<T: Config> {
            phase: Phase,
            /// The index of the event in the list of events in a given block.
            index: u32,
            all_bytes: Arc<[u8]>,
            start_idx: usize,
            event_start_idx: usize,
            event_fields_start_idx: usize,
            event_fields_end_idx: usize,
            end_idx: usize,
            metadata: Metadata,
            topics: Vec<T::Hash>,
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug + Config> ::core::fmt::Debug for EventDetails<T>
        where
            T::Hash: ::core::fmt::Debug,
        {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "phase",
                    "index",
                    "all_bytes",
                    "start_idx",
                    "event_start_idx",
                    "event_fields_start_idx",
                    "event_fields_end_idx",
                    "end_idx",
                    "metadata",
                    "topics",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.phase,
                    &self.index,
                    &self.all_bytes,
                    &self.start_idx,
                    &self.event_start_idx,
                    &self.event_fields_start_idx,
                    &self.event_fields_end_idx,
                    &self.end_idx,
                    &self.metadata,
                    &&self.topics,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "EventDetails",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone + Config> ::core::clone::Clone for EventDetails<T>
        where
            T::Hash: ::core::clone::Clone,
        {
            #[inline]
            fn clone(&self) -> EventDetails<T> {
                EventDetails {
                    phase: ::core::clone::Clone::clone(&self.phase),
                    index: ::core::clone::Clone::clone(&self.index),
                    all_bytes: ::core::clone::Clone::clone(&self.all_bytes),
                    start_idx: ::core::clone::Clone::clone(&self.start_idx),
                    event_start_idx: ::core::clone::Clone::clone(&self.event_start_idx),
                    event_fields_start_idx: ::core::clone::Clone::clone(
                        &self.event_fields_start_idx,
                    ),
                    event_fields_end_idx: ::core::clone::Clone::clone(
                        &self.event_fields_end_idx,
                    ),
                    end_idx: ::core::clone::Clone::clone(&self.end_idx),
                    metadata: ::core::clone::Clone::clone(&self.metadata),
                    topics: ::core::clone::Clone::clone(&self.topics),
                }
            }
        }
        impl<T: Config> EventDetails<T> {
            fn decode_from(
                metadata: Metadata,
                all_bytes: Arc<[u8]>,
                start_idx: usize,
                index: u32,
            ) -> Result<EventDetails<T>, Error> {
                let input = &mut &all_bytes[start_idx..];
                let phase = Phase::decode(input)?;
                let event_start_idx = all_bytes.len() - input.len();
                let pallet_index = u8::decode(input)?;
                let variant_index = u8::decode(input)?;
                let event_fields_start_idx = all_bytes.len() - input.len();
                let event_pallet = metadata.pallet_by_index_err(pallet_index)?;
                let event_variant = event_pallet
                    .event_variant_by_index(variant_index)
                    .ok_or(MetadataError::VariantIndexNotFound(variant_index))?;
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event subxt/src/events/events_type.rs:220",
                                "subxt::events::events_type",
                                ::tracing::Level::DEBUG,
                                ::core::option::Option::Some(
                                    "subxt/src/events/events_type.rs",
                                ),
                                ::core::option::Option::Some(220u32),
                                ::core::option::Option::Some("subxt::events::events_type"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!(
                                                    "Decoding Event \'{0}::{1}\'", event_pallet.name(), &
                                                    event_variant.name
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                for field_metadata in &event_variant.fields {
                    scale_decode::visitor::decode_with_visitor(
                            input,
                            field_metadata.ty.id,
                            metadata.types(),
                            scale_decode::visitor::IgnoreVisitor,
                        )
                        .map_err(scale_decode::Error::from)?;
                }
                let event_fields_end_idx = all_bytes.len() - input.len();
                let topics = Vec::<T::Hash>::decode(input)?;
                let end_idx = all_bytes.len() - input.len();
                Ok(EventDetails {
                    phase,
                    index,
                    start_idx,
                    event_start_idx,
                    event_fields_start_idx,
                    event_fields_end_idx,
                    end_idx,
                    all_bytes,
                    metadata,
                    topics,
                })
            }
            /// When was the event produced?
            pub fn phase(&self) -> Phase {
                self.phase
            }
            /// What index is this event in the stored events for this block.
            pub fn index(&self) -> u32 {
                self.index
            }
            /// The index of the pallet that the event originated from.
            pub fn pallet_index(&self) -> u8 {
                self.all_bytes[self.event_fields_start_idx - 2]
            }
            /// The index of the event variant that the event originated from.
            pub fn variant_index(&self) -> u8 {
                self.all_bytes[self.event_fields_start_idx - 1]
            }
            /// The name of the pallet from whence the Event originated.
            pub fn pallet_name(&self) -> &str {
                self.event_metadata().pallet.name()
            }
            /// The name of the event (ie the name of the variant that it corresponds to).
            pub fn variant_name(&self) -> &str {
                &self.event_metadata().variant.name
            }
            /// Fetch details from the metadata for this event.
            pub fn event_metadata(&self) -> EventMetadataDetails {
                let pallet = self
                    .metadata
                    .pallet_by_index(self.pallet_index())
                    .expect(
                        "event pallet to be found; we did this already during decoding",
                    );
                let variant = pallet
                    .event_variant_by_index(self.variant_index())
                    .expect(
                        "event variant to be found; we did this already during decoding",
                    );
                EventMetadataDetails {
                    pallet,
                    variant,
                }
            }
            /// Return _all_ of the bytes representing this event, which include, in order:
            /// - The phase.
            /// - Pallet and event index.
            /// - Event fields.
            /// - Event Topics.
            pub fn bytes(&self) -> &[u8] {
                &self.all_bytes[self.start_idx..self.end_idx]
            }
            /// Return the bytes representing the fields stored in this event.
            pub fn field_bytes(&self) -> &[u8] {
                &self.all_bytes[self.event_fields_start_idx..self.event_fields_end_idx]
            }
            /// Decode and provide the event fields back in the form of a [`scale_value::Composite`]
            /// type which represents the named or unnamed fields that were present in the event.
            pub fn field_values(
                &self,
            ) -> Result<scale_value::Composite<scale_value::scale::TypeId>, Error> {
                let bytes = &mut self.field_bytes();
                let event_metadata = self.event_metadata();
                let mut fields = event_metadata
                    .variant
                    .fields
                    .iter()
                    .map(|f| scale_decode::Field::new(f.ty.id, f.name.as_deref()));
                use scale_decode::DecodeAsFields;
                let decoded = <scale_value::Composite<
                    scale_value::scale::TypeId,
                >>::decode_as_fields(bytes, &mut fields, self.metadata.types())?;
                Ok(decoded)
            }
            /// Attempt to decode these [`EventDetails`] into a type representing the event fields.
            /// Such types are exposed in the codegen as `pallet_name::events::EventName` types.
            pub fn as_event<E: StaticEvent>(&self) -> Result<Option<E>, Error> {
                let ev_metadata = self.event_metadata();
                if ev_metadata.pallet.name() == E::PALLET
                    && ev_metadata.variant.name == E::EVENT
                {
                    let mut fields = ev_metadata
                        .variant
                        .fields
                        .iter()
                        .map(|f| scale_decode::Field::new(f.ty.id, f.name.as_deref()));
                    let decoded = E::decode_as_fields(
                        &mut self.field_bytes(),
                        &mut fields,
                        self.metadata.types(),
                    )?;
                    Ok(Some(decoded))
                } else {
                    Ok(None)
                }
            }
            /// Attempt to decode these [`EventDetails`] into a root event type (which includes
            /// the pallet and event enum variants as well as the event fields). A compatible
            /// type for this is exposed via static codegen as a root level `Event` type.
            pub fn as_root_event<E: DecodeAsType>(&self) -> Result<E, Error> {
                let bytes = &self
                    .all_bytes[self.event_start_idx..self.event_fields_end_idx];
                let decoded = E::decode_as_type(
                    &mut &bytes[..],
                    self.metadata.outer_enums().event_enum_ty(),
                    self.metadata.types(),
                )?;
                Ok(decoded)
            }
            /// Return the topics associated with this event.
            pub fn topics(&self) -> &[T::Hash] {
                &self.topics
            }
        }
        /// Details for the given event plucked from the metadata.
        pub struct EventMetadataDetails<'a> {
            pub pallet: PalletMetadata<'a>,
            pub variant: &'a scale_info::Variant<scale_info::form::PortableForm>,
        }
    }
    use codec::{Decode, Encode};
    pub use events_client::EventsClient;
    pub use events_type::{EventDetails, Events};
    use scale_decode::DecodeAsFields;
    /// Trait to uniquely identify the events's identity from the runtime metadata.
    ///
    /// Generated API structures that represent an event implement this trait.
    ///
    /// The trait is utilized to decode emitted events from a block, via obtaining the
    /// form of the `Event` from the metadata.
    pub trait StaticEvent: DecodeAsFields {
        /// Pallet name.
        const PALLET: &'static str;
        /// Event name.
        const EVENT: &'static str;
        /// Returns true if the given pallet and event names match this event.
        fn is_event(pallet: &str, event: &str) -> bool {
            Self::PALLET == pallet && Self::EVENT == event
        }
    }
    /// A phase of a block's execution.
    pub enum Phase {
        /// Applying an extrinsic.
        ApplyExtrinsic(u32),
        /// Finalizing the block.
        Finalization,
        /// Initializing the block.
        Initialization,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Phase {}
    #[automatically_derived]
    impl ::core::clone::Clone for Phase {
        #[inline]
        fn clone(&self) -> Phase {
            let _: ::core::clone::AssertParamIsClone<u32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Phase {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Phase::ApplyExtrinsic(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ApplyExtrinsic",
                        &__self_0,
                    )
                }
                Phase::Finalization => {
                    ::core::fmt::Formatter::write_str(f, "Finalization")
                }
                Phase::Initialization => {
                    ::core::fmt::Formatter::write_str(f, "Initialization")
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Phase {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Phase {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Phase {
        #[inline]
        fn eq(&self, other: &Phase) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
                && match (self, other) {
                    (
                        Phase::ApplyExtrinsic(__self_0),
                        Phase::ApplyExtrinsic(__arg1_0),
                    ) => *__self_0 == *__arg1_0,
                    _ => true,
                }
        }
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::codec::Decode for Phase {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                match __codec_input_edqy
                    .read_byte()
                    .map_err(|e| {
                        e.chain("Could not decode `Phase`, failed to read variant byte")
                    })?
                {
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 0usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(
                                Phase::ApplyExtrinsic({
                                    let __codec_res_edqy = <u32 as ::codec::Decode>::decode(
                                        __codec_input_edqy,
                                    );
                                    match __codec_res_edqy {
                                        ::core::result::Result::Err(e) => {
                                            return ::core::result::Result::Err(
                                                e.chain("Could not decode `Phase::ApplyExtrinsic.0`"),
                                            );
                                        }
                                        ::core::result::Result::Ok(__codec_res_edqy) => {
                                            __codec_res_edqy
                                        }
                                    }
                                }),
                            )
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 1usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(Phase::Finalization)
                        })();
                    }
                    #[allow(clippy::unnecessary_cast)]
                    __codec_x_edqy if __codec_x_edqy
                        == 2usize as ::core::primitive::u8 => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Ok(Phase::Initialization)
                        })();
                    }
                    _ => {
                        #[allow(clippy::redundant_closure_call)]
                        return (move || {
                            ::core::result::Result::Err(
                                <_ as ::core::convert::Into<
                                    _,
                                >>::into("Could not decode `Phase`, variant doesn't exist"),
                            )
                        })();
                    }
                }
            }
        }
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl ::codec::Encode for Phase {
            fn size_hint(&self) -> usize {
                1_usize
                    + match *self {
                        Phase::ApplyExtrinsic(ref aa) => {
                            0_usize.saturating_add(::codec::Encode::size_hint(aa))
                        }
                        Phase::Finalization => 0_usize,
                        Phase::Initialization => 0_usize,
                        _ => 0_usize,
                    }
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Phase::ApplyExtrinsic(ref aa) => {
                        __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                        ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                    }
                    Phase::Finalization => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                    }
                    Phase::Initialization => {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                    }
                    _ => {}
                }
            }
        }
        #[automatically_derived]
        impl ::codec::EncodeLike for Phase {}
    };
}
pub mod metadata {
    //! Types representing the metadata obtained from a node.
    mod decode_encode_traits {
        use super::Metadata;
        use crate::error::Error;
        /// This trait is implemented for all types that also implement [`scale_decode::DecodeAsType`].
        pub trait DecodeWithMetadata: Sized {
            /// Given some metadata and a type ID, attempt to SCALE decode the provided bytes into `Self`.
            fn decode_with_metadata(
                bytes: &mut &[u8],
                type_id: u32,
                metadata: &Metadata,
            ) -> Result<Self, Error>;
        }
        impl<T: scale_decode::DecodeAsType> DecodeWithMetadata for T {
            fn decode_with_metadata(
                bytes: &mut &[u8],
                type_id: u32,
                metadata: &Metadata,
            ) -> Result<T, Error> {
                let val = T::decode_as_type(bytes, type_id, metadata.types())?;
                Ok(val)
            }
        }
        /// This trait is implemented for all types that also implement [`scale_encode::EncodeAsType`].
        pub trait EncodeWithMetadata {
            /// SCALE encode this type to bytes, possibly with the help of metadata.
            fn encode_with_metadata(
                &self,
                type_id: u32,
                metadata: &Metadata,
                bytes: &mut Vec<u8>,
            ) -> Result<(), Error>;
        }
        impl<T: scale_encode::EncodeAsType> EncodeWithMetadata for T {
            /// SCALE encode this type to bytes, possibly with the help of metadata.
            fn encode_with_metadata(
                &self,
                type_id: u32,
                metadata: &Metadata,
                bytes: &mut Vec<u8>,
            ) -> Result<(), Error> {
                self.encode_as_type_to(type_id, metadata.types(), bytes)?;
                Ok(())
            }
        }
    }
    mod metadata_type {
        use crate::error::MetadataError;
        use std::sync::Arc;
        /// A cheaply clone-able representation of the runtime metadata received from a node.
        pub struct Metadata {
            inner: Arc<subxt_metadata::Metadata>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Metadata {
            #[inline]
            fn clone(&self) -> Metadata {
                Metadata {
                    inner: ::core::clone::Clone::clone(&self.inner),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Metadata {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Metadata",
                    "inner",
                    &&self.inner,
                )
            }
        }
        impl std::ops::Deref for Metadata {
            type Target = subxt_metadata::Metadata;
            fn deref(&self) -> &Self::Target {
                &self.inner
            }
        }
        impl Metadata {
            pub(crate) fn new(md: subxt_metadata::Metadata) -> Self {
                Metadata { inner: Arc::new(md) }
            }
            /// Identical to `metadata.pallet_by_name()`, but returns an error if the pallet is not found.
            pub fn pallet_by_name_err(
                &self,
                name: &str,
            ) -> Result<subxt_metadata::PalletMetadata, MetadataError> {
                self.pallet_by_name(name)
                    .ok_or_else(|| MetadataError::PalletNameNotFound(name.to_owned()))
            }
            /// Identical to `metadata.pallet_by_index()`, but returns an error if the pallet is not found.
            pub fn pallet_by_index_err(
                &self,
                index: u8,
            ) -> Result<subxt_metadata::PalletMetadata, MetadataError> {
                self.pallet_by_index(index)
                    .ok_or(MetadataError::PalletIndexNotFound(index))
            }
            /// Identical to `metadata.runtime_api_trait_by_name()`, but returns an error if the trait is not found.
            pub fn runtime_api_trait_by_name_err(
                &self,
                name: &str,
            ) -> Result<subxt_metadata::RuntimeApiMetadata, MetadataError> {
                self.runtime_api_trait_by_name(name)
                    .ok_or_else(|| MetadataError::RuntimeTraitNotFound(name.to_owned()))
            }
        }
        impl From<subxt_metadata::Metadata> for Metadata {
            fn from(md: subxt_metadata::Metadata) -> Self {
                Metadata::new(md)
            }
        }
        impl TryFrom<frame_metadata::RuntimeMetadataPrefixed> for Metadata {
            type Error = subxt_metadata::TryFromError;
            fn try_from(
                value: frame_metadata::RuntimeMetadataPrefixed,
            ) -> Result<Self, Self::Error> {
                subxt_metadata::Metadata::try_from(value).map(Metadata::from)
            }
        }
        impl codec::Decode for Metadata {
            fn decode<I: codec::Input>(input: &mut I) -> Result<Self, codec::Error> {
                subxt_metadata::Metadata::decode(input).map(Metadata::new)
            }
        }
    }
    pub use decode_encode_traits::{DecodeWithMetadata, EncodeWithMetadata};
    pub use metadata_type::Metadata;
    pub use subxt_metadata as types;
}
pub mod runtime_api {
    //! Types associated with executing runtime API calls.
    mod runtime_client {
        use super::runtime_types::RuntimeApi;
        use crate::{backend::BlockRef, client::OnlineClientT, error::Error, Config};
        use derivative::Derivative;
        use std::{future::Future, marker::PhantomData};
        /// Execute runtime API calls.
        #[derivative(Clone(bound = "Client: Clone"))]
        pub struct RuntimeApiClient<T, Client> {
            client: Client,
            _marker: PhantomData<T>,
        }
        #[allow(unused_qualifications)]
        impl<T, Client> ::std::clone::Clone for RuntimeApiClient<T, Client>
        where
            Client: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    RuntimeApiClient { client: ref __arg_0, _marker: ref __arg_1 } => {
                        RuntimeApiClient {
                            client: (*__arg_0).clone(),
                            _marker: (*__arg_1).clone(),
                        }
                    }
                }
            }
        }
        impl<T, Client> RuntimeApiClient<T, Client> {
            /// Create a new [`RuntimeApiClient`]
            pub fn new(client: Client) -> Self {
                Self {
                    client,
                    _marker: PhantomData,
                }
            }
        }
        impl<T, Client> RuntimeApiClient<T, Client>
        where
            T: Config,
            Client: OnlineClientT<T>,
        {
            /// Obtain a runtime API interface at some block hash.
            pub fn at(
                &self,
                block_ref: impl Into<BlockRef<T::Hash>>,
            ) -> RuntimeApi<T, Client> {
                RuntimeApi::new(self.client.clone(), block_ref.into())
            }
            /// Obtain a runtime API interface at the latest block hash.
            pub fn at_latest(
                &self,
            ) -> impl Future<
                Output = Result<RuntimeApi<T, Client>, Error>,
            > + Send + 'static {
                let client = self.client.clone();
                async move {
                    let block_ref = client.backend().latest_finalized_block_ref().await?;
                    Ok(RuntimeApi::new(client, block_ref))
                }
            }
        }
    }
    mod runtime_payload {
        use core::marker::PhantomData;
        use derivative::Derivative;
        use scale_encode::EncodeAsFields;
        use scale_value::Composite;
        use std::borrow::Cow;
        use crate::dynamic::DecodedValueThunk;
        use crate::error::MetadataError;
        use crate::{metadata::DecodeWithMetadata, Error, Metadata};
        /// This represents a runtime API payload that can call into the runtime of node.
        ///
        /// # Components
        ///
        /// - associated return type
        ///
        /// Resulting bytes of the call are interpreted into this type.
        ///
        /// - runtime function name
        ///
        /// The function name of the runtime API call. This is obtained by concatenating
        /// the runtime trait name with the trait's method.
        ///
        /// For example, the substrate runtime trait [Metadata](https://github.com/paritytech/substrate/blob/cb954820a8d8d765ce75021e244223a3b4d5722d/primitives/api/src/lib.rs#L745)
        /// contains the `metadata_at_version` function. The corresponding runtime function
        /// is `Metadata_metadata_at_version`.
        ///
        /// - encoded arguments
        ///
        /// Each argument of the runtime function must be scale-encoded.
        pub trait RuntimeApiPayload {
            /// The return type of the function call.
            type ReturnType: DecodeWithMetadata;
            /// The runtime API trait name.
            fn trait_name(&self) -> &str;
            /// The runtime API method name.
            fn method_name(&self) -> &str;
            /// Scale encode the arguments data.
            fn encode_args_to(
                &self,
                metadata: &Metadata,
                out: &mut Vec<u8>,
            ) -> Result<(), Error>;
            /// Encode arguments data and return the output. This is a convenience
            /// wrapper around [`RuntimeApiPayload::encode_args_to`].
            fn encode_args(&self, metadata: &Metadata) -> Result<Vec<u8>, Error> {
                let mut v = Vec::new();
                self.encode_args_to(metadata, &mut v)?;
                Ok(v)
            }
            /// Returns the statically generated validation hash.
            fn validation_hash(&self) -> Option<[u8; 32]> {
                None
            }
        }
        /// A runtime API payload containing the generic argument data
        /// and interpreting the result of the call as `ReturnTy`.
        ///
        /// This can be created from static values (ie those generated
        /// via the `subxt` macro) or dynamic values via [`dynamic`].
        #[derivative(
            Clone(bound = "ArgsData: Clone"),
            Debug(bound = "ArgsData: std::fmt::Debug"),
            Eq(bound = "ArgsData: std::cmp::Eq"),
            Ord(bound = "ArgsData: std::cmp::Ord"),
            PartialEq(bound = "ArgsData: std::cmp::PartialEq"),
            PartialOrd(bound = "ArgsData: std::cmp::PartialOrd")
        )]
        pub struct Payload<ArgsData, ReturnTy> {
            trait_name: Cow<'static, str>,
            method_name: Cow<'static, str>,
            args_data: ArgsData,
            validation_hash: Option<[u8; 32]>,
            _marker: PhantomData<ReturnTy>,
        }
        #[allow(unused_qualifications)]
        impl<ArgsData, ReturnTy> ::std::clone::Clone for Payload<ArgsData, ReturnTy>
        where
            ArgsData: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    Payload {
                        trait_name: ref __arg_0,
                        method_name: ref __arg_1,
                        args_data: ref __arg_2,
                        validation_hash: ref __arg_3,
                        _marker: ref __arg_4,
                    } => {
                        Payload {
                            trait_name: (*__arg_0).clone(),
                            method_name: (*__arg_1).clone(),
                            args_data: (*__arg_2).clone(),
                            validation_hash: (*__arg_3).clone(),
                            _marker: (*__arg_4).clone(),
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<ArgsData, ReturnTy> ::std::fmt::Debug for Payload<ArgsData, ReturnTy>
        where
            ArgsData: std::fmt::Debug,
        {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    Payload {
                        trait_name: ref __arg_0,
                        method_name: ref __arg_1,
                        args_data: ref __arg_2,
                        validation_hash: ref __arg_3,
                        _marker: ref __arg_4,
                    } => {
                        let mut __debug_trait_builder = __f.debug_struct("Payload");
                        let _ = __debug_trait_builder.field("trait_name", &&(*__arg_0));
                        let _ = __debug_trait_builder.field("method_name", &&(*__arg_1));
                        let _ = __debug_trait_builder.field("args_data", &&(*__arg_2));
                        let _ = __debug_trait_builder
                            .field("validation_hash", &&(*__arg_3));
                        let _ = __debug_trait_builder.field("_marker", &&(*__arg_4));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        impl<ArgsData, ReturnTy> ::std::cmp::Eq for Payload<ArgsData, ReturnTy>
        where
            ArgsData: std::cmp::Eq,
        {}
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<ArgsData, ReturnTy> ::std::cmp::PartialEq for Payload<ArgsData, ReturnTy>
        where
            ArgsData: std::cmp::PartialEq,
        {
            fn eq(&self, other: &Self) -> bool {
                true
                    && match *self {
                        Payload {
                            trait_name: ref __self_0,
                            method_name: ref __self_1,
                            args_data: ref __self_2,
                            validation_hash: ref __self_3,
                            _marker: ref __self_4,
                        } => {
                            match *other {
                                Payload {
                                    trait_name: ref __other_0,
                                    method_name: ref __other_1,
                                    args_data: ref __other_2,
                                    validation_hash: ref __other_3,
                                    _marker: ref __other_4,
                                } => {
                                    true && &(*__self_0) == &(*__other_0)
                                        && &(*__self_1) == &(*__other_1)
                                        && &(*__self_2) == &(*__other_2)
                                        && &(*__self_3) == &(*__other_3)
                                        && &(*__self_4) == &(*__other_4)
                                }
                            }
                        }
                    }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<ArgsData, ReturnTy> ::std::cmp::PartialOrd for Payload<ArgsData, ReturnTy>
        where
            ArgsData: std::cmp::PartialOrd,
        {
            fn partial_cmp(
                &self,
                other: &Self,
            ) -> ::std::option::Option<::std::cmp::Ordering> {
                match *self {
                    Payload {
                        trait_name: ref __self_0,
                        method_name: ref __self_1,
                        args_data: ref __self_2,
                        validation_hash: ref __self_3,
                        _marker: ref __self_4,
                    } => {
                        match *other {
                            Payload {
                                trait_name: ref __other_0,
                                method_name: ref __other_1,
                                args_data: ref __other_2,
                                validation_hash: ref __other_3,
                                _marker: ref __other_4,
                            } => {
                                match ::std::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0),
                                    &(*__other_0),
                                ) {
                                    ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                        match ::std::cmp::PartialOrd::partial_cmp(
                                            &(*__self_1),
                                            &(*__other_1),
                                        ) {
                                            ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                                match ::std::cmp::PartialOrd::partial_cmp(
                                                    &(*__self_2),
                                                    &(*__other_2),
                                                ) {
                                                    ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                                        match ::std::cmp::PartialOrd::partial_cmp(
                                                            &(*__self_3),
                                                            &(*__other_3),
                                                        ) {
                                                            ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                                                match ::std::cmp::PartialOrd::partial_cmp(
                                                                    &(*__self_4),
                                                                    &(*__other_4),
                                                                ) {
                                                                    ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal)
                                                                    }
                                                                    __derive_ordering_other => __derive_ordering_other,
                                                                }
                                                            }
                                                            __derive_ordering_other => __derive_ordering_other,
                                                        }
                                                    }
                                                    __derive_ordering_other => __derive_ordering_other,
                                                }
                                            }
                                            __derive_ordering_other => __derive_ordering_other,
                                        }
                                    }
                                    __derive_ordering_other => __derive_ordering_other,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<ArgsData, ReturnTy> ::std::cmp::Ord for Payload<ArgsData, ReturnTy>
        where
            ArgsData: std::cmp::Ord,
        {
            fn cmp(&self, other: &Self) -> ::std::cmp::Ordering {
                match *self {
                    Payload {
                        trait_name: ref __self_0,
                        method_name: ref __self_1,
                        args_data: ref __self_2,
                        validation_hash: ref __self_3,
                        _marker: ref __self_4,
                    } => {
                        match *other {
                            Payload {
                                trait_name: ref __other_0,
                                method_name: ref __other_1,
                                args_data: ref __other_2,
                                validation_hash: ref __other_3,
                                _marker: ref __other_4,
                            } => {
                                match ::std::cmp::Ord::cmp(&(*__self_0), &(*__other_0)) {
                                    ::std::cmp::Ordering::Equal => {
                                        match ::std::cmp::Ord::cmp(&(*__self_1), &(*__other_1)) {
                                            ::std::cmp::Ordering::Equal => {
                                                match ::std::cmp::Ord::cmp(&(*__self_2), &(*__other_2)) {
                                                    ::std::cmp::Ordering::Equal => {
                                                        match ::std::cmp::Ord::cmp(&(*__self_3), &(*__other_3)) {
                                                            ::std::cmp::Ordering::Equal => {
                                                                match ::std::cmp::Ord::cmp(&(*__self_4), &(*__other_4)) {
                                                                    ::std::cmp::Ordering::Equal => ::std::cmp::Ordering::Equal,
                                                                    __derive_ordering_other => __derive_ordering_other,
                                                                }
                                                            }
                                                            __derive_ordering_other => __derive_ordering_other,
                                                        }
                                                    }
                                                    __derive_ordering_other => __derive_ordering_other,
                                                }
                                            }
                                            __derive_ordering_other => __derive_ordering_other,
                                        }
                                    }
                                    __derive_ordering_other => __derive_ordering_other,
                                }
                            }
                        }
                    }
                }
            }
        }
        impl<ArgsData: EncodeAsFields, ReturnTy: DecodeWithMetadata> RuntimeApiPayload
        for Payload<ArgsData, ReturnTy> {
            type ReturnType = ReturnTy;
            fn trait_name(&self) -> &str {
                &self.trait_name
            }
            fn method_name(&self) -> &str {
                &self.method_name
            }
            fn encode_args_to(
                &self,
                metadata: &Metadata,
                out: &mut Vec<u8>,
            ) -> Result<(), Error> {
                let api_method = metadata
                    .runtime_api_trait_by_name_err(&self.trait_name)?
                    .method_by_name(&self.method_name)
                    .ok_or_else(|| MetadataError::RuntimeMethodNotFound(
                        (*self.method_name).to_owned(),
                    ))?;
                let mut fields = api_method
                    .inputs()
                    .map(|input| scale_encode::Field::named(input.ty, &input.name));
                self.args_data.encode_as_fields_to(&mut fields, metadata.types(), out)?;
                Ok(())
            }
            fn validation_hash(&self) -> Option<[u8; 32]> {
                self.validation_hash
            }
        }
        /// A dynamic runtime API payload.
        pub type DynamicRuntimeApiPayload = Payload<Composite<()>, DecodedValueThunk>;
        impl<ReturnTy, ArgsData> Payload<ArgsData, ReturnTy> {
            /// Create a new [`Payload`].
            pub fn new(
                trait_name: impl Into<String>,
                method_name: impl Into<String>,
                args_data: ArgsData,
            ) -> Self {
                Payload {
                    trait_name: Cow::Owned(trait_name.into()),
                    method_name: Cow::Owned(method_name.into()),
                    args_data,
                    validation_hash: None,
                    _marker: PhantomData,
                }
            }
            /// Create a new static [`Payload`] using static function name
            /// and scale-encoded argument data.
            ///
            /// This is only expected to be used from codegen.
            #[doc(hidden)]
            pub fn new_static(
                trait_name: &'static str,
                method_name: &'static str,
                args_data: ArgsData,
                hash: [u8; 32],
            ) -> Payload<ArgsData, ReturnTy> {
                Payload {
                    trait_name: Cow::Borrowed(trait_name),
                    method_name: Cow::Borrowed(method_name),
                    args_data,
                    validation_hash: Some(hash),
                    _marker: std::marker::PhantomData,
                }
            }
            /// Do not validate this call prior to submitting it.
            pub fn unvalidated(self) -> Self {
                Self {
                    validation_hash: None,
                    ..self
                }
            }
            /// Returns the trait name.
            pub fn trait_name(&self) -> &str {
                &self.trait_name
            }
            /// Returns the method name.
            pub fn method_name(&self) -> &str {
                &self.method_name
            }
            /// Returns the arguments data.
            pub fn args_data(&self) -> &ArgsData {
                &self.args_data
            }
        }
        /// Create a new [`DynamicRuntimeApiPayload`].
        pub fn dynamic(
            trait_name: impl Into<String>,
            method_name: impl Into<String>,
            args_data: impl Into<Composite<()>>,
        ) -> DynamicRuntimeApiPayload {
            Payload::new(trait_name, method_name, args_data.into())
        }
    }
    mod runtime_types {
        use crate::{
            backend::{BackendExt, BlockRef},
            client::OnlineClientT, error::{Error, MetadataError},
            metadata::DecodeWithMetadata, Config,
        };
        use codec::Decode;
        use derivative::Derivative;
        use std::{future::Future, marker::PhantomData};
        use super::RuntimeApiPayload;
        /// Execute runtime API calls.
        #[derivative(Clone(bound = "Client: Clone"))]
        pub struct RuntimeApi<T: Config, Client> {
            client: Client,
            block_ref: BlockRef<T::Hash>,
            _marker: PhantomData<T>,
        }
        #[allow(unused_qualifications)]
        impl<T: Config, Client> ::std::clone::Clone for RuntimeApi<T, Client>
        where
            Client: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    RuntimeApi {
                        client: ref __arg_0,
                        block_ref: ref __arg_1,
                        _marker: ref __arg_2,
                    } => {
                        RuntimeApi {
                            client: (*__arg_0).clone(),
                            block_ref: (*__arg_1).clone(),
                            _marker: (*__arg_2).clone(),
                        }
                    }
                }
            }
        }
        impl<T: Config, Client> RuntimeApi<T, Client> {
            /// Create a new [`RuntimeApi`]
            pub(crate) fn new(client: Client, block_ref: BlockRef<T::Hash>) -> Self {
                Self {
                    client,
                    block_ref,
                    _marker: PhantomData,
                }
            }
        }
        impl<T, Client> RuntimeApi<T, Client>
        where
            T: Config,
            Client: OnlineClientT<T>,
        {
            /// Execute a raw runtime API call.
            pub fn call_raw<'a, Res: Decode>(
                &self,
                function: &'a str,
                call_parameters: Option<&'a [u8]>,
            ) -> impl Future<Output = Result<Res, Error>> + 'a {
                let client = self.client.clone();
                let block_hash = self.block_ref.hash();
                async move {
                    let data: Res = client
                        .backend()
                        .call_decoding(function, call_parameters, block_hash)
                        .await?;
                    Ok(data)
                }
            }
            /// Execute a runtime API call.
            pub fn call<Call: RuntimeApiPayload>(
                &self,
                payload: Call,
            ) -> impl Future<Output = Result<Call::ReturnType, Error>> {
                let client = self.client.clone();
                let block_hash = self.block_ref.hash();
                async move {
                    let metadata = client.metadata();
                    let api_trait = metadata
                        .runtime_api_trait_by_name_err(payload.trait_name())?;
                    let api_method = api_trait
                        .method_by_name(payload.method_name())
                        .ok_or_else(|| {
                            MetadataError::RuntimeMethodNotFound(
                                payload.method_name().to_owned(),
                            )
                        })?;
                    if let Some(static_hash) = payload.validation_hash() {
                        let Some(runtime_hash) = api_trait
                            .method_hash(payload.method_name()) else {
                        return Err(MetadataError::IncompatibleCodegen.into());
                    };
                        if static_hash != runtime_hash {
                            return Err(MetadataError::IncompatibleCodegen.into());
                        }
                    }
                    let params = payload.encode_args(&metadata)?;
                    let call_name = {
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "{0}_{1}", payload.trait_name(), payload.method_name()
                            ),
                        );
                        res
                    };
                    let bytes = client
                        .backend()
                        .call(&call_name, Some(params.as_slice()), block_hash)
                        .await?;
                    let value = <Call::ReturnType as DecodeWithMetadata>::decode_with_metadata(
                        &mut &bytes[..],
                        api_method.output_ty(),
                        &metadata,
                    )?;
                    Ok(value)
                }
            }
        }
    }
    pub use runtime_client::RuntimeApiClient;
    pub use runtime_payload::{
        dynamic, DynamicRuntimeApiPayload, Payload, RuntimeApiPayload,
    };
    pub use runtime_types::RuntimeApi;
}
pub mod storage {
    //! Types associated with accessing and working with storage items.
    mod storage_address {
        use crate::{
            dynamic::DecodedValueThunk,
            error::{Error, MetadataError, StorageAddressError},
            metadata::{DecodeWithMetadata, EncodeWithMetadata, Metadata},
            utils::{Encoded, Static},
        };
        use derivative::Derivative;
        use scale_info::TypeDef;
        use std::borrow::Cow;
        use subxt_metadata::{StorageEntryType, StorageHasher};
        use super::StorageKey;
        /// This represents a storage address. Anything implementing this trait
        /// can be used to fetch and iterate over storage entries.
        pub trait StorageAddress {
            /// The target type of the value that lives at this address.
            type Target: DecodeWithMetadata;
            /// The keys type used to construct this address.
            type Keys: StorageKey;
            /// Can an entry be fetched from this address?
            /// Set this type to [`Yes`] to enable the corresponding calls to be made.
            type IsFetchable;
            /// Can a default entry be obtained from this address?
            /// Set this type to [`Yes`] to enable the corresponding calls to be made.
            type IsDefaultable;
            /// Can this address be iterated over?
            /// Set this type to [`Yes`] to enable the corresponding calls to be made.
            type IsIterable;
            /// The name of the pallet that the entry lives under.
            fn pallet_name(&self) -> &str;
            /// The name of the entry in a given pallet that the item is at.
            fn entry_name(&self) -> &str;
            /// Output the non-prefix bytes; that is, any additional bytes that need
            /// to be appended to the key to dig into maps.
            fn append_entry_bytes(
                &self,
                metadata: &Metadata,
                bytes: &mut Vec<u8>,
            ) -> Result<(), Error>;
            /// An optional hash which, if present, will be checked against
            /// the node metadata to confirm that the return type matches what
            /// we are expecting.
            fn validation_hash(&self) -> Option<[u8; 32]> {
                None
            }
        }
        /// Used to signal whether a [`StorageAddress`] can be iterated,
        /// fetched and returned with a default value in the type system.
        pub struct Yes;
        /// A concrete storage address. This can be created from static values (ie those generated
        /// via the `subxt` macro) or dynamic values via [`dynamic`].
        #[derivative(
            Clone(bound = "Keys: Clone"),
            Debug(bound = "Keys: std::fmt::Debug"),
            Eq(bound = "Keys: std::cmp::Eq"),
            Ord(bound = "Keys: std::cmp::Ord"),
            PartialEq(bound = "Keys: std::cmp::PartialEq"),
            PartialOrd(bound = "Keys: std::cmp::PartialOrd")
        )]
        pub struct Address<
            Keys: StorageKey,
            ReturnTy,
            Fetchable,
            Defaultable,
            Iterable,
        > {
            pallet_name: Cow<'static, str>,
            entry_name: Cow<'static, str>,
            keys: Keys,
            validation_hash: Option<[u8; 32]>,
            _marker: std::marker::PhantomData<
                (ReturnTy, Fetchable, Defaultable, Iterable),
            >,
        }
        #[allow(unused_qualifications)]
        impl<
            Keys: StorageKey,
            ReturnTy,
            Fetchable,
            Defaultable,
            Iterable,
        > ::std::clone::Clone
        for Address<Keys, ReturnTy, Fetchable, Defaultable, Iterable>
        where
            Keys: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    Address {
                        pallet_name: ref __arg_0,
                        entry_name: ref __arg_1,
                        keys: ref __arg_2,
                        validation_hash: ref __arg_3,
                        _marker: ref __arg_4,
                    } => {
                        Address {
                            pallet_name: (*__arg_0).clone(),
                            entry_name: (*__arg_1).clone(),
                            keys: (*__arg_2).clone(),
                            validation_hash: (*__arg_3).clone(),
                            _marker: (*__arg_4).clone(),
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<
            Keys: StorageKey,
            ReturnTy,
            Fetchable,
            Defaultable,
            Iterable,
        > ::std::fmt::Debug for Address<Keys, ReturnTy, Fetchable, Defaultable, Iterable>
        where
            Keys: std::fmt::Debug,
        {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    Address {
                        pallet_name: ref __arg_0,
                        entry_name: ref __arg_1,
                        keys: ref __arg_2,
                        validation_hash: ref __arg_3,
                        _marker: ref __arg_4,
                    } => {
                        let mut __debug_trait_builder = __f.debug_struct("Address");
                        let _ = __debug_trait_builder.field("pallet_name", &&(*__arg_0));
                        let _ = __debug_trait_builder.field("entry_name", &&(*__arg_1));
                        let _ = __debug_trait_builder.field("keys", &&(*__arg_2));
                        let _ = __debug_trait_builder
                            .field("validation_hash", &&(*__arg_3));
                        let _ = __debug_trait_builder.field("_marker", &&(*__arg_4));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        impl<Keys: StorageKey, ReturnTy, Fetchable, Defaultable, Iterable> ::std::cmp::Eq
        for Address<Keys, ReturnTy, Fetchable, Defaultable, Iterable>
        where
            Keys: std::cmp::Eq,
        {}
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<
            Keys: StorageKey,
            ReturnTy,
            Fetchable,
            Defaultable,
            Iterable,
        > ::std::cmp::PartialEq
        for Address<Keys, ReturnTy, Fetchable, Defaultable, Iterable>
        where
            Keys: std::cmp::PartialEq,
        {
            fn eq(&self, other: &Self) -> bool {
                true
                    && match *self {
                        Address {
                            pallet_name: ref __self_0,
                            entry_name: ref __self_1,
                            keys: ref __self_2,
                            validation_hash: ref __self_3,
                            _marker: ref __self_4,
                        } => {
                            match *other {
                                Address {
                                    pallet_name: ref __other_0,
                                    entry_name: ref __other_1,
                                    keys: ref __other_2,
                                    validation_hash: ref __other_3,
                                    _marker: ref __other_4,
                                } => {
                                    true && &(*__self_0) == &(*__other_0)
                                        && &(*__self_1) == &(*__other_1)
                                        && &(*__self_2) == &(*__other_2)
                                        && &(*__self_3) == &(*__other_3)
                                        && &(*__self_4) == &(*__other_4)
                                }
                            }
                        }
                    }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<
            Keys: StorageKey,
            ReturnTy,
            Fetchable,
            Defaultable,
            Iterable,
        > ::std::cmp::PartialOrd
        for Address<Keys, ReturnTy, Fetchable, Defaultable, Iterable>
        where
            Keys: std::cmp::PartialOrd,
        {
            fn partial_cmp(
                &self,
                other: &Self,
            ) -> ::std::option::Option<::std::cmp::Ordering> {
                match *self {
                    Address {
                        pallet_name: ref __self_0,
                        entry_name: ref __self_1,
                        keys: ref __self_2,
                        validation_hash: ref __self_3,
                        _marker: ref __self_4,
                    } => {
                        match *other {
                            Address {
                                pallet_name: ref __other_0,
                                entry_name: ref __other_1,
                                keys: ref __other_2,
                                validation_hash: ref __other_3,
                                _marker: ref __other_4,
                            } => {
                                match ::std::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0),
                                    &(*__other_0),
                                ) {
                                    ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                        match ::std::cmp::PartialOrd::partial_cmp(
                                            &(*__self_1),
                                            &(*__other_1),
                                        ) {
                                            ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                                match ::std::cmp::PartialOrd::partial_cmp(
                                                    &(*__self_2),
                                                    &(*__other_2),
                                                ) {
                                                    ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                                        match ::std::cmp::PartialOrd::partial_cmp(
                                                            &(*__self_3),
                                                            &(*__other_3),
                                                        ) {
                                                            ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                                                match ::std::cmp::PartialOrd::partial_cmp(
                                                                    &(*__self_4),
                                                                    &(*__other_4),
                                                                ) {
                                                                    ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal)
                                                                    }
                                                                    __derive_ordering_other => __derive_ordering_other,
                                                                }
                                                            }
                                                            __derive_ordering_other => __derive_ordering_other,
                                                        }
                                                    }
                                                    __derive_ordering_other => __derive_ordering_other,
                                                }
                                            }
                                            __derive_ordering_other => __derive_ordering_other,
                                        }
                                    }
                                    __derive_ordering_other => __derive_ordering_other,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<
            Keys: StorageKey,
            ReturnTy,
            Fetchable,
            Defaultable,
            Iterable,
        > ::std::cmp::Ord for Address<Keys, ReturnTy, Fetchable, Defaultable, Iterable>
        where
            Keys: std::cmp::Ord,
        {
            fn cmp(&self, other: &Self) -> ::std::cmp::Ordering {
                match *self {
                    Address {
                        pallet_name: ref __self_0,
                        entry_name: ref __self_1,
                        keys: ref __self_2,
                        validation_hash: ref __self_3,
                        _marker: ref __self_4,
                    } => {
                        match *other {
                            Address {
                                pallet_name: ref __other_0,
                                entry_name: ref __other_1,
                                keys: ref __other_2,
                                validation_hash: ref __other_3,
                                _marker: ref __other_4,
                            } => {
                                match ::std::cmp::Ord::cmp(&(*__self_0), &(*__other_0)) {
                                    ::std::cmp::Ordering::Equal => {
                                        match ::std::cmp::Ord::cmp(&(*__self_1), &(*__other_1)) {
                                            ::std::cmp::Ordering::Equal => {
                                                match ::std::cmp::Ord::cmp(&(*__self_2), &(*__other_2)) {
                                                    ::std::cmp::Ordering::Equal => {
                                                        match ::std::cmp::Ord::cmp(&(*__self_3), &(*__other_3)) {
                                                            ::std::cmp::Ordering::Equal => {
                                                                match ::std::cmp::Ord::cmp(&(*__self_4), &(*__other_4)) {
                                                                    ::std::cmp::Ordering::Equal => ::std::cmp::Ordering::Equal,
                                                                    __derive_ordering_other => __derive_ordering_other,
                                                                }
                                                            }
                                                            __derive_ordering_other => __derive_ordering_other,
                                                        }
                                                    }
                                                    __derive_ordering_other => __derive_ordering_other,
                                                }
                                            }
                                            __derive_ordering_other => __derive_ordering_other,
                                        }
                                    }
                                    __derive_ordering_other => __derive_ordering_other,
                                }
                            }
                        }
                    }
                }
            }
        }
        /// A storage key for static encoded values.
        /// The original value is only present at construction, but can be decoded from the contained bytes.
        #[derivative(Clone(bound = ""), Debug(bound = ""))]
        pub struct StaticStorageKey<K: ?Sized> {
            pub(super) bytes: Static<Encoded>,
            pub(super) _marker: std::marker::PhantomData<K>,
        }
        #[allow(unused_qualifications)]
        impl<K: ?Sized> ::std::clone::Clone for StaticStorageKey<K> {
            fn clone(&self) -> Self {
                match *self {
                    StaticStorageKey { bytes: ref __arg_0, _marker: ref __arg_1 } => {
                        StaticStorageKey {
                            bytes: (*__arg_0).clone(),
                            _marker: (*__arg_1).clone(),
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<K: ?Sized> ::std::fmt::Debug for StaticStorageKey<K> {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    StaticStorageKey { bytes: ref __arg_0, _marker: ref __arg_1 } => {
                        let mut __debug_trait_builder = __f
                            .debug_struct("StaticStorageKey");
                        let _ = __debug_trait_builder.field("bytes", &&(*__arg_0));
                        let _ = __debug_trait_builder.field("_marker", &&(*__arg_1));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        impl<K: codec::Encode + ?Sized> StaticStorageKey<K> {
            /// Creates a new static storage key
            pub fn new(key: &K) -> Self {
                StaticStorageKey {
                    bytes: Static(Encoded(key.encode())),
                    _marker: std::marker::PhantomData,
                }
            }
            /// Returns the scale-encoded bytes that make up this key
            pub fn bytes(&self) -> &[u8] {
                &self.bytes.0.0
            }
        }
        /// A typical storage address constructed at runtime rather than via the `subxt` macro; this
        /// has no restriction on what it can be used for (since we don't statically know).
        pub type DynamicAddress<Keys> = Address<Keys, DecodedValueThunk, Yes, Yes, Yes>;
        impl<Keys: StorageKey> DynamicAddress<Keys> {
            /// Creates a new dynamic address. As `Keys` you can use a `Vec<scale_value::Value>`
            pub fn new(
                pallet_name: impl Into<String>,
                entry_name: impl Into<String>,
                keys: Keys,
            ) -> Self {
                Self {
                    pallet_name: Cow::Owned(pallet_name.into()),
                    entry_name: Cow::Owned(entry_name.into()),
                    keys,
                    validation_hash: None,
                    _marker: std::marker::PhantomData,
                }
            }
        }
        impl<
            Keys,
            ReturnTy,
            Fetchable,
            Defaultable,
            Iterable,
        > Address<Keys, ReturnTy, Fetchable, Defaultable, Iterable>
        where
            Keys: StorageKey,
            ReturnTy: DecodeWithMetadata,
        {
            /// Create a new [`Address`] using static strings for the pallet and call name.
            /// This is only expected to be used from codegen.
            #[doc(hidden)]
            pub fn new_static(
                pallet_name: &'static str,
                entry_name: &'static str,
                keys: Keys,
                hash: [u8; 32],
            ) -> Self {
                Self {
                    pallet_name: Cow::Borrowed(pallet_name),
                    entry_name: Cow::Borrowed(entry_name),
                    keys,
                    validation_hash: Some(hash),
                    _marker: std::marker::PhantomData,
                }
            }
        }
        impl<
            Keys,
            ReturnTy,
            Fetchable,
            Defaultable,
            Iterable,
        > Address<Keys, ReturnTy, Fetchable, Defaultable, Iterable>
        where
            Keys: StorageKey,
            ReturnTy: DecodeWithMetadata,
        {
            /// Do not validate this storage entry prior to accessing it.
            pub fn unvalidated(self) -> Self {
                Self {
                    validation_hash: None,
                    ..self
                }
            }
            /// Return bytes representing the root of this storage entry (ie a hash of
            /// the pallet and entry name). Use [`crate::storage::StorageClient::address_bytes()`]
            /// to obtain the bytes representing the entire address.
            pub fn to_root_bytes(&self) -> Vec<u8> {
                super::utils::storage_address_root_bytes(self)
            }
        }
        impl<Keys, ReturnTy, Fetchable, Defaultable, Iterable> StorageAddress
        for Address<Keys, ReturnTy, Fetchable, Defaultable, Iterable>
        where
            Keys: StorageKey,
            ReturnTy: DecodeWithMetadata,
        {
            type Target = ReturnTy;
            type Keys = Keys;
            type IsFetchable = Fetchable;
            type IsDefaultable = Defaultable;
            type IsIterable = Iterable;
            fn pallet_name(&self) -> &str {
                &self.pallet_name
            }
            fn entry_name(&self) -> &str {
                &self.entry_name
            }
            fn append_entry_bytes(
                &self,
                metadata: &Metadata,
                bytes: &mut Vec<u8>,
            ) -> Result<(), Error> {
                let pallet = metadata.pallet_by_name_err(self.pallet_name())?;
                let storage = pallet
                    .storage()
                    .ok_or_else(|| MetadataError::StorageNotFoundInPallet(
                        self.pallet_name().to_owned(),
                    ))?;
                let entry = storage
                    .entry_by_name(self.entry_name())
                    .ok_or_else(|| MetadataError::StorageEntryNotFound(
                        self.entry_name().to_owned(),
                    ))?;
                let keys_iter = self.keys.keys_iter();
                let keys_len = self.keys.keys_len();
                if keys_len == 0 {
                    return Ok(());
                }
                let StorageEntryType::Map { hashers, key_ty, .. } = entry
                    .entry_type() else {
                return Err(
                    StorageAddressError::WrongNumberOfKeys {
                        expected: 0,
                        actual: keys_len,
                    }
                        .into(),
                );
            };
                let ty = metadata
                    .types()
                    .resolve(*key_ty)
                    .ok_or(MetadataError::TypeNotFound(*key_ty))?;
                let type_ids = match &ty.type_def {
                    TypeDef::Tuple(tuple) => {
                        either::Either::Left(tuple.fields.iter().map(|f| f.id))
                    }
                    _other => either::Either::Right(std::iter::once(*key_ty)),
                };
                if hashers.len() == 1 {
                    let mut input = Vec::new();
                    let iter = keys_iter.zip(type_ids);
                    for (key, type_id) in iter {
                        key.encode_with_metadata(type_id, metadata, &mut input)?;
                    }
                    hash_bytes(&input, &hashers[0], bytes);
                } else if hashers.len() >= type_ids.len() {
                    let iter = keys_iter.zip(type_ids).zip(hashers);
                    for ((key, type_id), hasher) in iter {
                        let mut input = Vec::new();
                        key.encode_with_metadata(type_id, metadata, &mut input)?;
                        hash_bytes(&input, hasher, bytes);
                    }
                } else {
                    return Err(
                        StorageAddressError::WrongNumberOfHashers {
                            hashers: hashers.len(),
                            fields: type_ids.len(),
                        }
                            .into(),
                    );
                }
                Ok(())
            }
            fn validation_hash(&self) -> Option<[u8; 32]> {
                self.validation_hash
            }
        }
        /// Construct a new dynamic storage lookup.
        pub fn dynamic<Keys: StorageKey>(
            pallet_name: impl Into<String>,
            entry_name: impl Into<String>,
            storage_entry_keys: Keys,
        ) -> DynamicAddress<Keys> {
            DynamicAddress::new(pallet_name, entry_name, storage_entry_keys)
        }
        /// Take some SCALE encoded bytes and a [`StorageHasher`] and hash the bytes accordingly.
        fn hash_bytes(input: &[u8], hasher: &StorageHasher, bytes: &mut Vec<u8>) {
            match hasher {
                StorageHasher::Identity => bytes.extend(input),
                StorageHasher::Blake2_128 => {
                    bytes.extend(sp_core_hashing::blake2_128(input))
                }
                StorageHasher::Blake2_128Concat => {
                    bytes.extend(sp_core_hashing::blake2_128(input));
                    bytes.extend(input);
                }
                StorageHasher::Blake2_256 => {
                    bytes.extend(sp_core_hashing::blake2_256(input))
                }
                StorageHasher::Twox128 => bytes.extend(sp_core_hashing::twox_128(input)),
                StorageHasher::Twox256 => bytes.extend(sp_core_hashing::twox_256(input)),
                StorageHasher::Twox64Concat => {
                    bytes.extend(sp_core_hashing::twox_64(input));
                    bytes.extend(input);
                }
            }
        }
    }
    mod storage_client {
        use super::{
            storage_type::{validate_storage_address, Storage},
            utils, StorageAddress,
        };
        use crate::{
            backend::BlockRef, client::{OfflineClientT, OnlineClientT},
            error::Error, Config,
        };
        use derivative::Derivative;
        use std::{future::Future, marker::PhantomData};
        /// Query the runtime storage.
        #[derivative(Clone(bound = "Client: Clone"))]
        pub struct StorageClient<T, Client> {
            client: Client,
            _marker: PhantomData<T>,
        }
        #[allow(unused_qualifications)]
        impl<T, Client> ::std::clone::Clone for StorageClient<T, Client>
        where
            Client: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    StorageClient { client: ref __arg_0, _marker: ref __arg_1 } => {
                        StorageClient {
                            client: (*__arg_0).clone(),
                            _marker: (*__arg_1).clone(),
                        }
                    }
                }
            }
        }
        impl<T, Client> StorageClient<T, Client> {
            /// Create a new [`StorageClient`]
            pub fn new(client: Client) -> Self {
                Self {
                    client,
                    _marker: PhantomData,
                }
            }
        }
        impl<T, Client> StorageClient<T, Client>
        where
            T: Config,
            Client: OfflineClientT<T>,
        {
            /// Run the validation logic against some storage address you'd like to access. Returns `Ok(())`
            /// if the address is valid (or if it's not possible to check since the address has no validation hash).
            /// Return an error if the address was not valid or something went wrong trying to validate it (ie
            /// the pallet or storage entry in question do not exist at all).
            pub fn validate<Address: StorageAddress>(
                &self,
                address: &Address,
            ) -> Result<(), Error> {
                let metadata = self.client.metadata();
                let pallet_metadata = metadata
                    .pallet_by_name_err(address.pallet_name())?;
                validate_storage_address(address, pallet_metadata)
            }
            /// Convert some storage address into the raw bytes that would be submitted to the node in order
            /// to retrieve the entries at the root of the associated address.
            pub fn address_root_bytes<Address: StorageAddress>(
                &self,
                address: &Address,
            ) -> Vec<u8> {
                utils::storage_address_root_bytes(address)
            }
            /// Convert some storage address into the raw bytes that would be submitted to the node in order
            /// to retrieve an entry. This fails if [`StorageAddress::append_entry_bytes`] does; in the built-in
            /// implementation this would be if the pallet and storage entry being asked for is not available on the
            /// node you're communicating with, or if the metadata is missing some type information (which should not
            /// happen).
            pub fn address_bytes<Address: StorageAddress>(
                &self,
                address: &Address,
            ) -> Result<Vec<u8>, Error> {
                utils::storage_address_bytes(address, &self.client.metadata())
            }
        }
        impl<T, Client> StorageClient<T, Client>
        where
            T: Config,
            Client: OnlineClientT<T>,
        {
            /// Obtain storage at some block hash.
            pub fn at(
                &self,
                block_ref: impl Into<BlockRef<T::Hash>>,
            ) -> Storage<T, Client> {
                Storage::new(self.client.clone(), block_ref.into())
            }
            /// Obtain storage at the latest block hash.
            pub fn at_latest(
                &self,
            ) -> impl Future<
                Output = Result<Storage<T, Client>, Error>,
            > + Send + 'static {
                let client = self.client.clone();
                async move {
                    let block_ref = client.backend().latest_finalized_block_ref().await?;
                    Ok(Storage::new(client, block_ref))
                }
            }
        }
    }
    mod storage_key {
        use super::{
            storage_address::StaticStorageKey,
            utils::{
                hash_contains_unhashed_value, strip_storage_addess_root_bytes,
                strip_storage_hash_bytes,
            },
        };
        use crate::{
            dynamic::DecodedValueThunk, error::{Error, StorageAddressError},
            metadata::{DecodeWithMetadata, Metadata},
            utils::{Encoded, Static},
        };
        use scale_encode::EncodeAsType;
        use subxt_metadata::StorageHasher;
        /// This trait should be implemented by anything that can be used as one or multiple storage keys.
        pub trait StorageKey {
            /// Iterator over the storage keys, each key implements EncodeAsType to
            /// give the corresponding bytes to a `StorageHasher`.
            fn keys_iter(&self) -> impl Iterator<Item = &dyn EncodeAsType>;
            /// How many keys are there in total? Each key is an element that needs to be individually hashed.
            fn keys_len(&self) -> usize;
            /// Attempts to decode the StorageKey from a storage address that has been stripped of its root bytes.
            ///
            /// Example: Imagine The `StorageKey` is a tuple (A,B) and the hashers are: [Blake2_128Concat, Twox64Concat].
            /// Then the memory layout of the storage address is:
            /// ```txt
            /// | 8 bytes pallet hash | 8 bytes entry hash | 16 bytes hash of A | ... bytes of A | 8 bytes hash of B | ... bytes of B |
            /// ```
            /// `cursor` should point into a region after those first 16 bytes, at the start of a new hash.
            /// `hashers_and_ty_ids` should consume all the hashers that have been used for decoding, such that there are less hashers coming to the next key.
            fn decode_from_bytes(
                cursor: &mut &[u8],
                hashers_and_ty_ids: &mut &[(StorageHasher, u32)],
                metadata: &Metadata,
            ) -> Result<Self, Error>
            where
                Self: Sized + 'static;
        }
        /// Implement `StorageKey` for `()` which can be used for keyless storage entries.
        impl StorageKey for () {
            fn keys_iter(&self) -> impl Iterator<Item = &dyn EncodeAsType> {
                std::iter::empty()
            }
            fn keys_len(&self) -> usize {
                0
            }
            fn decode_from_bytes(
                cursor: &mut &[u8],
                hashers_and_ty_ids: &mut &[(StorageHasher, u32)],
                _metadata: &Metadata,
            ) -> Result<Self, Error> {
                if hashers_and_ty_ids.is_empty() {
                    return Err(
                        StorageAddressError::WrongNumberOfHashers {
                            hashers: 0,
                            fields: 1,
                        }
                            .into(),
                    );
                }
                *hashers_and_ty_ids = &hashers_and_ty_ids[1..];
                Ok(())
            }
        }
        impl<K: EncodeAsType + codec::Decode + ?Sized> StorageKey
        for StaticStorageKey<K> {
            fn keys_iter(&self) -> impl Iterator<Item = &dyn EncodeAsType> {
                std::iter::once(&self.bytes as &dyn EncodeAsType)
            }
            fn keys_len(&self) -> usize {
                1
            }
            fn decode_from_bytes(
                cursor: &mut &[u8],
                hashers_and_ty_ids: &mut &[(StorageHasher, u32)],
                metadata: &Metadata,
            ) -> Result<Self, Error>
            where
                Self: Sized + 'static,
            {
                let Some((hasher, ty_id)) = hashers_and_ty_ids.first() else {
                return Err(
                    StorageAddressError::WrongNumberOfHashers {
                        hashers: 0,
                        fields: 1,
                    }
                        .into(),
                );
            };
                *hashers_and_ty_ids = &hashers_and_ty_ids[1..];
                decode_storage_key_from_hash(cursor, hasher, *ty_id, metadata)
            }
        }
        pub fn decode_storage_key_from_hash<K: ?Sized>(
            cursor: &mut &[u8],
            hasher: &StorageHasher,
            ty_id: u32,
            metadata: &Metadata,
        ) -> Result<StaticStorageKey<K>, Error> {
            strip_storage_hash_bytes(cursor, hasher)?;
            let bytes = *cursor;
            if let Err(err)
                = scale_decode::visitor::decode_with_visitor(
                    cursor,
                    ty_id,
                    metadata.types(),
                    scale_decode::visitor::IgnoreVisitor,
                ) {
                return Err(scale_decode::Error::from(err).into());
            }
            let bytes_decoded = bytes.len() - cursor.len();
            if !hash_contains_unhashed_value(hasher) && bytes_decoded > 0 {
                let ty_name = metadata
                    .types()
                    .resolve(ty_id)
                    .expect(
                        "ty_id is in metadata, because decode_with_visitor did not fail above; qed",
                    )
                    .path
                    .to_string();
                return Err(
                    StorageAddressError::HasherCannotReconstructKey {
                        ty_id,
                        ty_name,
                        hasher: *hasher,
                    }
                        .into(),
                );
            }
            let key_bytes = bytes[..bytes_decoded].to_vec();
            let key = StaticStorageKey {
                bytes: Static(Encoded(key_bytes)),
                _marker: std::marker::PhantomData::<K>,
            };
            Ok(key)
        }
        impl StorageKey for Vec<scale_value::Value> {
            fn keys_iter(&self) -> impl Iterator<Item = &dyn EncodeAsType> {
                self.iter().map(|e| e as &dyn EncodeAsType)
            }
            fn keys_len(&self) -> usize {
                self.len()
            }
            fn decode_from_bytes(
                cursor: &mut &[u8],
                hashers_and_ty_ids: &mut &[(StorageHasher, u32)],
                metadata: &Metadata,
            ) -> Result<Self, Error>
            where
                Self: Sized + 'static,
            {
                let mut hashers_and_ty_ids_iter = hashers_and_ty_ids.iter();
                let mut result: Vec<scale_value::Value> = ::alloc::vec::Vec::new();
                let mut n = 0;
                while !cursor.is_empty() {
                    let Some((hasher, ty_id)) = hashers_and_ty_ids_iter.next() else {
                    return Err(StorageAddressError::UnexpectedAddressBytes.into());
                };
                    strip_storage_hash_bytes(cursor, hasher)?;
                    let decoded = DecodedValueThunk::decode_with_metadata(
                        cursor,
                        *ty_id,
                        metadata,
                    )?;
                    let value = decoded.to_value()?;
                    result.push(value.remove_context());
                    n += 1;
                }
                *hashers_and_ty_ids = &hashers_and_ty_ids[n..];
                Ok(result)
            }
        }
        #[rustfmt::skip]
        const _: () = {
            {
                impl<A: StorageKey, B: StorageKey> StorageKey for (A, B) {
                    fn keys_iter(&self) -> impl Iterator<Item = &dyn EncodeAsType> {
                        ()
                    }
                    fn keys_len(&self) -> usize {
                        (self.0.keys_len()) + (self.1.keys_len()) + 0
                    }
                    fn decode_from_bytes(
                        cursor: &mut &[u8],
                        hashers_and_ty_ids: &mut &[(StorageHasher, u32)],
                        metadata: &Metadata,
                    ) -> Result<Self, Error>
                    where
                        Self: Sized + 'static,
                    {
                        const TUPLE_LEN: usize = (0 * 0 + 1) + (0 * 1 + 1) + 0;
                        let tuple: Self = (
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[0];
                                let key = A::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[1];
                                let key = B::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                        );
                        return Ok(tuple);
                    }
                }
            };
            {
                impl<A: StorageKey, B: StorageKey, C: StorageKey> StorageKey
                for (A, B, C) {
                    fn keys_iter(&self) -> impl Iterator<Item = &dyn EncodeAsType> {
                        ()
                    }
                    fn keys_len(&self) -> usize {
                        (self.0.keys_len()) + (self.1.keys_len()) + (self.2.keys_len())
                            + 0
                    }
                    fn decode_from_bytes(
                        cursor: &mut &[u8],
                        hashers_and_ty_ids: &mut &[(StorageHasher, u32)],
                        metadata: &Metadata,
                    ) -> Result<Self, Error>
                    where
                        Self: Sized + 'static,
                    {
                        const TUPLE_LEN: usize = (0 * 0 + 1) + (0 * 1 + 1) + (0 * 2 + 1)
                            + 0;
                        let tuple: Self = (
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[0];
                                let key = A::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[1];
                                let key = B::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[2];
                                let key = C::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                        );
                        return Ok(tuple);
                    }
                }
            };
            {
                impl<
                    A: StorageKey,
                    B: StorageKey,
                    C: StorageKey,
                    D: StorageKey,
                > StorageKey for (A, B, C, D) {
                    fn keys_iter(&self) -> impl Iterator<Item = &dyn EncodeAsType> {
                        ()
                    }
                    fn keys_len(&self) -> usize {
                        (self.0.keys_len()) + (self.1.keys_len()) + (self.2.keys_len())
                            + (self.3.keys_len()) + 0
                    }
                    fn decode_from_bytes(
                        cursor: &mut &[u8],
                        hashers_and_ty_ids: &mut &[(StorageHasher, u32)],
                        metadata: &Metadata,
                    ) -> Result<Self, Error>
                    where
                        Self: Sized + 'static,
                    {
                        const TUPLE_LEN: usize = (0 * 0 + 1) + (0 * 1 + 1) + (0 * 2 + 1)
                            + (0 * 3 + 1) + 0;
                        let tuple: Self = (
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[0];
                                let key = A::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[1];
                                let key = B::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[2];
                                let key = C::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[3];
                                let key = D::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                        );
                        return Ok(tuple);
                    }
                }
            };
            {
                impl<
                    A: StorageKey,
                    B: StorageKey,
                    C: StorageKey,
                    D: StorageKey,
                    E: StorageKey,
                > StorageKey for (A, B, C, D, E) {
                    fn keys_iter(&self) -> impl Iterator<Item = &dyn EncodeAsType> {
                        ()
                    }
                    fn keys_len(&self) -> usize {
                        (self.0.keys_len()) + (self.1.keys_len()) + (self.2.keys_len())
                            + (self.3.keys_len()) + (self.4.keys_len()) + 0
                    }
                    fn decode_from_bytes(
                        cursor: &mut &[u8],
                        hashers_and_ty_ids: &mut &[(StorageHasher, u32)],
                        metadata: &Metadata,
                    ) -> Result<Self, Error>
                    where
                        Self: Sized + 'static,
                    {
                        const TUPLE_LEN: usize = (0 * 0 + 1) + (0 * 1 + 1) + (0 * 2 + 1)
                            + (0 * 3 + 1) + (0 * 4 + 1) + 0;
                        let tuple: Self = (
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[0];
                                let key = A::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[1];
                                let key = B::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[2];
                                let key = C::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[3];
                                let key = D::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[4];
                                let key = E::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                        );
                        return Ok(tuple);
                    }
                }
            };
            {
                impl<
                    A: StorageKey,
                    B: StorageKey,
                    C: StorageKey,
                    D: StorageKey,
                    E: StorageKey,
                    F: StorageKey,
                > StorageKey for (A, B, C, D, E, F) {
                    fn keys_iter(&self) -> impl Iterator<Item = &dyn EncodeAsType> {
                        ()
                    }
                    fn keys_len(&self) -> usize {
                        (self.0.keys_len()) + (self.1.keys_len()) + (self.2.keys_len())
                            + (self.3.keys_len()) + (self.4.keys_len())
                            + (self.5.keys_len()) + 0
                    }
                    fn decode_from_bytes(
                        cursor: &mut &[u8],
                        hashers_and_ty_ids: &mut &[(StorageHasher, u32)],
                        metadata: &Metadata,
                    ) -> Result<Self, Error>
                    where
                        Self: Sized + 'static,
                    {
                        const TUPLE_LEN: usize = (0 * 0 + 1) + (0 * 1 + 1) + (0 * 2 + 1)
                            + (0 * 3 + 1) + (0 * 4 + 1) + (0 * 5 + 1) + 0;
                        let tuple: Self = (
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[0];
                                let key = A::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[1];
                                let key = B::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[2];
                                let key = C::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[3];
                                let key = D::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[4];
                                let key = E::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[5];
                                let key = F::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                        );
                        return Ok(tuple);
                    }
                }
            };
            {
                impl<
                    A: StorageKey,
                    B: StorageKey,
                    C: StorageKey,
                    D: StorageKey,
                    E: StorageKey,
                    F: StorageKey,
                    G: StorageKey,
                > StorageKey for (A, B, C, D, E, F, G) {
                    fn keys_iter(&self) -> impl Iterator<Item = &dyn EncodeAsType> {
                        ()
                    }
                    fn keys_len(&self) -> usize {
                        (self.0.keys_len()) + (self.1.keys_len()) + (self.2.keys_len())
                            + (self.3.keys_len()) + (self.4.keys_len())
                            + (self.5.keys_len()) + (self.6.keys_len()) + 0
                    }
                    fn decode_from_bytes(
                        cursor: &mut &[u8],
                        hashers_and_ty_ids: &mut &[(StorageHasher, u32)],
                        metadata: &Metadata,
                    ) -> Result<Self, Error>
                    where
                        Self: Sized + 'static,
                    {
                        const TUPLE_LEN: usize = (0 * 0 + 1) + (0 * 1 + 1) + (0 * 2 + 1)
                            + (0 * 3 + 1) + (0 * 4 + 1) + (0 * 5 + 1) + (0 * 6 + 1) + 0;
                        let tuple: Self = (
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[0];
                                let key = A::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[1];
                                let key = B::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[2];
                                let key = C::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[3];
                                let key = D::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[4];
                                let key = E::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[5];
                                let key = F::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[6];
                                let key = G::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                        );
                        return Ok(tuple);
                    }
                }
            };
            {
                impl<
                    A: StorageKey,
                    B: StorageKey,
                    C: StorageKey,
                    D: StorageKey,
                    E: StorageKey,
                    F: StorageKey,
                    G: StorageKey,
                    H: StorageKey,
                > StorageKey for (A, B, C, D, E, F, G, H) {
                    fn keys_iter(&self) -> impl Iterator<Item = &dyn EncodeAsType> {
                        ()
                    }
                    fn keys_len(&self) -> usize {
                        (self.0.keys_len()) + (self.1.keys_len()) + (self.2.keys_len())
                            + (self.3.keys_len()) + (self.4.keys_len())
                            + (self.5.keys_len()) + (self.6.keys_len())
                            + (self.7.keys_len()) + 0
                    }
                    fn decode_from_bytes(
                        cursor: &mut &[u8],
                        hashers_and_ty_ids: &mut &[(StorageHasher, u32)],
                        metadata: &Metadata,
                    ) -> Result<Self, Error>
                    where
                        Self: Sized + 'static,
                    {
                        const TUPLE_LEN: usize = (0 * 0 + 1) + (0 * 1 + 1) + (0 * 2 + 1)
                            + (0 * 3 + 1) + (0 * 4 + 1) + (0 * 5 + 1) + (0 * 6 + 1)
                            + (0 * 7 + 1) + 0;
                        let tuple: Self = (
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[0];
                                let key = A::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[1];
                                let key = B::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[2];
                                let key = C::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[3];
                                let key = D::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[4];
                                let key = E::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[5];
                                let key = F::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[6];
                                let key = G::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                            {
                                let (hasher, ty_id) = &hashers_and_ty_ids[7];
                                let key = H::decode_from_bytes(
                                    cursor,
                                    hashers_and_ty_ids,
                                    metadata,
                                )?;
                                key
                            },
                        );
                        return Ok(tuple);
                    }
                }
            };
        };
    }
    mod storage_type {
        use super::storage_address::{StorageAddress, Yes};
        use super::utils::strip_storage_addess_root_bytes;
        use super::StorageKey;
        use crate::{
            backend::{BackendExt, BlockRef},
            client::OnlineClientT, error::{Error, MetadataError, StorageAddressError},
            metadata::{DecodeWithMetadata, Metadata},
            Config,
        };
        use codec::Decode;
        use derivative::Derivative;
        use futures::StreamExt;
        use scale_info::TypeDef;
        use std::{future::Future, marker::PhantomData};
        use subxt_metadata::StorageHasher;
        use subxt_metadata::{PalletMetadata, StorageEntryMetadata, StorageEntryType};
        /// This is returned from a couple of storage functions.
        pub use crate::backend::StreamOfResults;
        /// Query the runtime storage.
        #[derivative(Clone(bound = "Client: Clone"))]
        pub struct Storage<T: Config, Client> {
            client: Client,
            block_ref: BlockRef<T::Hash>,
            _marker: PhantomData<T>,
        }
        #[allow(unused_qualifications)]
        impl<T: Config, Client> ::std::clone::Clone for Storage<T, Client>
        where
            Client: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    Storage {
                        client: ref __arg_0,
                        block_ref: ref __arg_1,
                        _marker: ref __arg_2,
                    } => {
                        Storage {
                            client: (*__arg_0).clone(),
                            block_ref: (*__arg_1).clone(),
                            _marker: (*__arg_2).clone(),
                        }
                    }
                }
            }
        }
        impl<T: Config, Client> Storage<T, Client> {
            /// Create a new [`Storage`]
            pub(crate) fn new(client: Client, block_ref: BlockRef<T::Hash>) -> Self {
                Self {
                    client,
                    block_ref,
                    _marker: PhantomData,
                }
            }
        }
        impl<T, Client> Storage<T, Client>
        where
            T: Config,
            Client: OnlineClientT<T>,
        {
            /// Fetch the raw encoded value at the key given.
            pub fn fetch_raw(
                &self,
                key: impl Into<Vec<u8>>,
            ) -> impl Future<Output = Result<Option<Vec<u8>>, Error>> + 'static {
                let client = self.client.clone();
                let key = key.into();
                let block_ref = self.block_ref.clone();
                async move {
                    let data = client
                        .backend()
                        .storage_fetch_value(key, block_ref.hash())
                        .await?;
                    Ok(data)
                }
            }
            /// Stream all of the raw keys underneath the key given
            pub fn fetch_raw_keys(
                &self,
                key: impl Into<Vec<u8>>,
            ) -> impl Future<
                Output = Result<StreamOfResults<Vec<u8>>, Error>,
            > + 'static {
                let client = self.client.clone();
                let block_hash = self.block_ref.hash();
                let key = key.into();
                async move {
                    let keys = client
                        .backend()
                        .storage_fetch_descendant_keys(key, block_hash)
                        .await?;
                    Ok(keys)
                }
            }
            /// Fetch a decoded value from storage at a given address.
            ///
            /// # Example
            ///
            /// ```no_run
            /// use subxt::{ PolkadotConfig, OnlineClient };
            ///
            /// #[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale")]
            /// pub mod polkadot {}
            ///
            /// # #[tokio::main]
            /// # async fn main() {
            /// let api = OnlineClient::<PolkadotConfig>::new().await.unwrap();
            ///
            /// // Address to a storage entry we'd like to access.
            /// let address = polkadot::storage().xcm_pallet().queries(&12345);
            ///
            /// // Fetch just the keys, returning up to 10 keys.
            /// let value = api
            ///     .storage()
            ///     .at_latest()
            ///     .await
            ///     .unwrap()
            ///     .fetch(&address)
            ///     .await
            ///     .unwrap();
            ///
            /// println!("Value: {:?}", value);
            /// # }
            /// ```
            pub fn fetch<'address, Address>(
                &self,
                address: &'address Address,
            ) -> impl Future<Output = Result<Option<Address::Target>, Error>> + 'address
            where
                Address: StorageAddress<IsFetchable = Yes> + 'address,
            {
                let client = self.clone();
                async move {
                    let metadata = client.client.metadata();
                    let (pallet, entry) = lookup_entry_details(
                        address.pallet_name(),
                        address.entry_name(),
                        &metadata,
                    )?;
                    validate_storage_address(address, pallet)?;
                    let lookup_bytes = super::utils::storage_address_bytes(
                        address,
                        &metadata,
                    )?;
                    if let Some(data) = client.fetch_raw(lookup_bytes).await? {
                        let val = decode_storage_with_metadata::<
                            Address::Target,
                        >(&mut &*data, &metadata, entry)?;
                        Ok(Some(val))
                    } else {
                        Ok(None)
                    }
                }
            }
            /// Fetch a StorageKey that has a default value with an optional block hash.
            pub fn fetch_or_default<'address, Address>(
                &self,
                address: &'address Address,
            ) -> impl Future<Output = Result<Address::Target, Error>> + 'address
            where
                Address: StorageAddress<IsFetchable = Yes, IsDefaultable = Yes>
                    + 'address,
            {
                let client = self.clone();
                async move {
                    let pallet_name = address.pallet_name();
                    let entry_name = address.entry_name();
                    if let Some(data) = client.fetch(address).await? {
                        Ok(data)
                    } else {
                        let metadata = client.client.metadata();
                        let (_pallet_metadata, storage_entry) = lookup_entry_details(
                            pallet_name,
                            entry_name,
                            &metadata,
                        )?;
                        let return_ty_id = return_type_from_storage_entry_type(
                            storage_entry.entry_type(),
                        );
                        let bytes = &mut storage_entry.default_bytes();
                        let val = Address::Target::decode_with_metadata(
                            bytes,
                            return_ty_id,
                            &metadata,
                        )?;
                        Ok(val)
                    }
                }
            }
            /// Returns an iterator of key value pairs.
            ///
            /// ```no_run
            /// use subxt::{ PolkadotConfig, OnlineClient };
            ///
            /// #[subxt::subxt(runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale")]
            /// pub mod polkadot {}
            ///
            /// # #[tokio::main]
            /// # async fn main() {
            /// let api = OnlineClient::<PolkadotConfig>::new().await.unwrap();
            ///
            /// // Address to the root of a storage entry that we'd like to iterate over.
            /// let address = polkadot::storage().xcm_pallet().version_notifiers_iter();
            ///
            /// // Iterate over keys and values at that address.
            /// let mut iter = api
            ///     .storage()
            ///     .at_latest()
            ///     .await
            ///     .unwrap()
            ///     .iter(address)
            ///     .await
            ///     .unwrap();
            ///
            /// while let Some(Ok(kv)) = iter.next().await {
            ///     println!("Key bytes: 0x{}", hex::encode(&kv.key_bytes));
            ///     println!("Value: {}", kv.value);
            /// }
            /// # }
            /// ```
            pub fn iter<Address>(
                &self,
                address: Address,
            ) -> impl Future<
                Output = Result<StreamOfResults<StorageKeyValuePair<Address>>, Error>,
            > + 'static
            where
                Address: StorageAddress<IsIterable = Yes> + 'static,
                Address::Keys: 'static + Sized,
            {
                let client = self.client.clone();
                let block_ref = self.block_ref.clone();
                async move {
                    let metadata = client.metadata();
                    let (pallet, entry) = lookup_entry_details(
                        address.pallet_name(),
                        address.entry_name(),
                        &metadata,
                    )?;
                    validate_storage_address(&address, pallet)?;
                    let entry = entry.entry_type();
                    let return_type_id = entry.value_ty();
                    let hasher_type_id_pairs = storage_hasher_type_id_pairs(
                        entry,
                        &metadata,
                    )?;
                    let address_bytes = super::utils::storage_address_bytes(
                        &address,
                        &metadata,
                    )?;
                    let s = client
                        .backend()
                        .storage_fetch_descendant_values(address_bytes, block_ref.hash())
                        .await?
                        .map(move |kv| {
                            let kv = match kv {
                                Ok(kv) => kv,
                                Err(e) => return Err(e),
                            };
                            let value = Address::Target::decode_with_metadata(
                                &mut &*kv.value,
                                return_type_id,
                                &metadata,
                            )?;
                            let key_bytes = kv.key;
                            let cursor = &mut &key_bytes[..];
                            strip_storage_addess_root_bytes(cursor)?;
                            let keys = <Address::Keys as StorageKey>::decode_from_bytes(
                                cursor,
                                &hasher_type_id_pairs,
                                &metadata,
                            )?;
                            Ok(StorageKeyValuePair::<Address> {
                                keys,
                                key_bytes,
                                value,
                            })
                        });
                    let s = StreamOfResults::new(Box::pin(s));
                    Ok(s)
                }
            }
            /// The storage version of a pallet.
            /// The storage version refers to the `frame_support::traits::Metadata::StorageVersion` type.
            pub async fn storage_version(
                &self,
                pallet_name: impl AsRef<str>,
            ) -> Result<u16, Error> {
                self.client
                    .metadata()
                    .pallet_by_name(pallet_name.as_ref())
                    .ok_or_else(|| MetadataError::PalletNameNotFound(
                        pallet_name.as_ref().into(),
                    ))?;
                pub const STORAGE_VERSION_STORAGE_KEY_POSTFIX: &[u8] = b":__STORAGE_VERSION__:";
                let mut key_bytes: Vec<u8> = ::alloc::vec::Vec::new();
                key_bytes
                    .extend(&sp_core_hashing::twox_128(pallet_name.as_ref().as_bytes()));
                key_bytes
                    .extend(
                        &sp_core_hashing::twox_128(STORAGE_VERSION_STORAGE_KEY_POSTFIX),
                    );
                let storage_version_bytes = self
                    .fetch_raw(key_bytes)
                    .await?
                    .ok_or_else(|| {
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Unexpected: entry for storage version in pallet \"{0}\" not found",
                                    pallet_name.as_ref()
                                ),
                            );
                            res
                        }
                    })?;
                u16::decode(&mut &storage_version_bytes[..]).map_err(Into::into)
            }
            /// Fetch the runtime WASM code.
            pub async fn runtime_wasm_code(&self) -> Result<Vec<u8>, Error> {
                const CODE: &str = ":code";
                self.fetch_raw(CODE.as_bytes())
                    .await?
                    .ok_or_else(|| {
                        {
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "Unexpected: entry for well known key \"{0}\" not found",
                                    CODE
                                ),
                            );
                            res
                        }
                            .into()
                    })
            }
        }
        pub(crate) fn storage_hasher_type_id_pairs(
            entry: &StorageEntryType,
            metadata: &Metadata,
        ) -> Result<Vec<(StorageHasher, u32)>, Error> {
            match entry {
                StorageEntryType::Plain(_) => Ok(::alloc::vec::Vec::new()),
                StorageEntryType::Map { hashers, key_ty, .. } => {
                    let ty = metadata
                        .types()
                        .resolve(*key_ty)
                        .ok_or(MetadataError::TypeNotFound(*key_ty))?;
                    match &ty.type_def {
                        TypeDef::Tuple(tuple) => {
                            if hashers.len() < tuple.fields.len() {
                                return Err(
                                    StorageAddressError::WrongNumberOfHashers {
                                        hashers: hashers.len(),
                                        fields: tuple.fields.len(),
                                    }
                                        .into(),
                                );
                            }
                            let pairs: Vec<(StorageHasher, u32)> = tuple
                                .fields
                                .iter()
                                .zip(hashers.iter())
                                .map(|(e, h)| (*h, e.id))
                                .collect();
                            Ok(pairs)
                        }
                        _other => {
                            if hashers.is_empty() {
                                return Err(
                                    StorageAddressError::WrongNumberOfHashers {
                                        hashers: 0,
                                        fields: 1,
                                    }
                                        .into(),
                                );
                            }
                            Ok(
                                <[_]>::into_vec(
                                    #[rustc_box]
                                    ::alloc::boxed::Box::new([(hashers[0], *key_ty)]),
                                ),
                            )
                        }
                    }
                }
            }
        }
        /// A pair of keys and values together with all the bytes that make up the storage address.
        /// `keys` is `None` if non-concat hashers are used. In this case the keys could not be extracted back from the key_bytes.
        pub struct StorageKeyValuePair<T: StorageAddress> {
            /// The bytes that make up the address of the storage entry.
            pub key_bytes: Vec<u8>,
            /// The keys that can be used to construct the address of this storage entry.
            pub keys: T::Keys,
            /// The value of the storage entry.
            pub value: T::Target,
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone + StorageAddress> ::core::clone::Clone
        for StorageKeyValuePair<T>
        where
            T::Keys: ::core::clone::Clone,
            T::Target: ::core::clone::Clone,
        {
            #[inline]
            fn clone(&self) -> StorageKeyValuePair<T> {
                StorageKeyValuePair {
                    key_bytes: ::core::clone::Clone::clone(&self.key_bytes),
                    keys: ::core::clone::Clone::clone(&self.keys),
                    value: ::core::clone::Clone::clone(&self.value),
                }
            }
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug + StorageAddress> ::core::fmt::Debug
        for StorageKeyValuePair<T>
        where
            T::Keys: ::core::fmt::Debug,
            T::Target: ::core::fmt::Debug,
        {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "StorageKeyValuePair",
                    "key_bytes",
                    &self.key_bytes,
                    "keys",
                    &self.keys,
                    "value",
                    &&self.value,
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::cmp::Eq + StorageAddress> ::core::cmp::Eq
        for StorageKeyValuePair<T>
        where
            T::Keys: ::core::cmp::Eq,
            T::Target: ::core::cmp::Eq,
        {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<T::Keys>;
                let _: ::core::cmp::AssertParamIsEq<T::Target>;
            }
        }
        #[automatically_derived]
        impl<T: StorageAddress> ::core::marker::StructuralPartialEq
        for StorageKeyValuePair<T> {}
        #[automatically_derived]
        impl<T: ::core::cmp::PartialEq + StorageAddress> ::core::cmp::PartialEq
        for StorageKeyValuePair<T>
        where
            T::Keys: ::core::cmp::PartialEq,
            T::Target: ::core::cmp::PartialEq,
        {
            #[inline]
            fn eq(&self, other: &StorageKeyValuePair<T>) -> bool {
                self.key_bytes == other.key_bytes && self.keys == other.keys
                    && self.value == other.value
            }
        }
        #[automatically_derived]
        impl<T: ::core::cmp::Ord + StorageAddress> ::core::cmp::Ord
        for StorageKeyValuePair<T>
        where
            T::Keys: ::core::cmp::Ord,
            T::Target: ::core::cmp::Ord,
        {
            #[inline]
            fn cmp(&self, other: &StorageKeyValuePair<T>) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.key_bytes, &other.key_bytes) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.keys, &other.keys) {
                            ::core::cmp::Ordering::Equal => {
                                ::core::cmp::Ord::cmp(&self.value, &other.value)
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<T: ::core::cmp::PartialOrd + StorageAddress> ::core::cmp::PartialOrd
        for StorageKeyValuePair<T>
        where
            T::Keys: ::core::cmp::PartialOrd,
            T::Target: ::core::cmp::PartialOrd,
        {
            #[inline]
            fn partial_cmp(
                &self,
                other: &StorageKeyValuePair<T>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.key_bytes,
                    &other.key_bytes,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.keys,
                            &other.keys,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &self.value,
                                    &other.value,
                                )
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        /// Validate a storage address against the metadata.
        pub(crate) fn validate_storage_address<Address: StorageAddress>(
            address: &Address,
            pallet: PalletMetadata<'_>,
        ) -> Result<(), Error> {
            if let Some(hash) = address.validation_hash() {
                validate_storage(pallet, address.entry_name(), hash)?;
            }
            Ok(())
        }
        /// Return details about the given storage entry.
        fn lookup_entry_details<'a>(
            pallet_name: &str,
            entry_name: &str,
            metadata: &'a Metadata,
        ) -> Result<(PalletMetadata<'a>, &'a StorageEntryMetadata), Error> {
            let pallet_metadata = metadata.pallet_by_name_err(pallet_name)?;
            let storage_metadata = pallet_metadata
                .storage()
                .ok_or_else(|| MetadataError::StorageNotFoundInPallet(
                    pallet_name.to_owned(),
                ))?;
            let storage_entry = storage_metadata
                .entry_by_name(entry_name)
                .ok_or_else(|| MetadataError::StorageEntryNotFound(
                    entry_name.to_owned(),
                ))?;
            Ok((pallet_metadata, storage_entry))
        }
        /// Validate a storage entry against the metadata.
        fn validate_storage(
            pallet: PalletMetadata<'_>,
            storage_name: &str,
            hash: [u8; 32],
        ) -> Result<(), Error> {
            let Some(expected_hash) = pallet.storage_hash(storage_name) else {
            return Err(MetadataError::IncompatibleCodegen.into());
        };
            if expected_hash != hash {
                return Err(MetadataError::IncompatibleCodegen.into());
            }
            Ok(())
        }
        /// Fetch the return type out of a [`StorageEntryType`].
        fn return_type_from_storage_entry_type(entry: &StorageEntryType) -> u32 {
            match entry {
                StorageEntryType::Plain(ty) => *ty,
                StorageEntryType::Map { value_ty, .. } => *value_ty,
            }
        }
        /// Given some bytes, a pallet and storage name, decode the response.
        fn decode_storage_with_metadata<T: DecodeWithMetadata>(
            bytes: &mut &[u8],
            metadata: &Metadata,
            storage_metadata: &StorageEntryMetadata,
        ) -> Result<T, Error> {
            let ty = storage_metadata.entry_type();
            let return_ty = return_type_from_storage_entry_type(ty);
            let val = T::decode_with_metadata(bytes, return_ty, metadata)?;
            Ok(val)
        }
    }
    pub mod utils {
        //! these utility methods complement the [`StorageAddress`] trait, but
        //! aren't things that should ever be overridden, and so don't exist on
        //! the trait itself.
        use subxt_metadata::StorageHasher;
        use super::StorageAddress;
        use crate::{
            error::{Error, StorageAddressError},
            metadata::Metadata,
        };
        /// Return the root of a given [`StorageAddress`]: hash the pallet name and entry name
        /// and append those bytes to the output.
        pub(crate) fn write_storage_address_root_bytes<Address: StorageAddress>(
            addr: &Address,
            out: &mut Vec<u8>,
        ) {
            out.extend(sp_core_hashing::twox_128(addr.pallet_name().as_bytes()));
            out.extend(sp_core_hashing::twox_128(addr.entry_name().as_bytes()));
        }
        /// Outputs the [`storage_address_root_bytes`] as well as any additional bytes that represent
        /// a lookup in a storage map at that location.
        pub(crate) fn storage_address_bytes<Address: StorageAddress>(
            addr: &Address,
            metadata: &Metadata,
        ) -> Result<Vec<u8>, Error> {
            let mut bytes = Vec::new();
            write_storage_address_root_bytes(addr, &mut bytes);
            addr.append_entry_bytes(metadata, &mut bytes)?;
            Ok(bytes)
        }
        /// Outputs a vector containing the bytes written by [`write_storage_address_root_bytes`].
        pub(crate) fn storage_address_root_bytes<Address: StorageAddress>(
            addr: &Address,
        ) -> Vec<u8> {
            let mut bytes = Vec::new();
            write_storage_address_root_bytes(addr, &mut bytes);
            bytes
        }
        /// Strips the first 16 bytes (8 for the pallet hash, 8 for the entry hash) off some storage address bytes.
        pub(crate) fn strip_storage_addess_root_bytes(
            address_bytes: &mut &[u8],
        ) -> Result<(), StorageAddressError> {
            if address_bytes.len() >= 16 {
                *address_bytes = &address_bytes[16..];
                Ok(())
            } else {
                Err(StorageAddressError::UnexpectedAddressBytes)
            }
        }
        /// Strips the first few bytes off a hash to possibly skip to the plan key value,
        /// if [`hash_contains_unhashed_value()`] for this StorageHasher.
        ///
        /// Returns `Err(..)` if there are not enough bytes.
        /// Returns `Ok(())` otherwise
        pub fn strip_storage_hash_bytes(
            hash: &mut &[u8],
            hasher: &StorageHasher,
        ) -> Result<(), StorageAddressError> {
            let bytes_to_strip = match hasher {
                StorageHasher::Blake2_128Concat => 16,
                StorageHasher::Twox64Concat => 8,
                StorageHasher::Blake2_128 => 16,
                StorageHasher::Blake2_256 => 32,
                StorageHasher::Twox128 => 16,
                StorageHasher::Twox256 => 32,
                StorageHasher::Identity => 0,
            };
            if hash.len() < bytes_to_strip {
                return Err(StorageAddressError::UnexpectedAddressBytes);
            }
            *hash = &hash[bytes_to_strip..];
            Ok(())
        }
        /// This value is contained within the hash for concat-stle hashers
        /// ([`StorageHasher::Identity`] or [`StorageHasher::Identity`]) and the
        /// identity hash function ([`StorageHasher::Identity`]).
        pub fn hash_contains_unhashed_value(hasher: &StorageHasher) -> bool {
            match hasher {
                StorageHasher::Blake2_128Concat
                | StorageHasher::Twox64Concat
                | StorageHasher::Identity => true,
                _ => false,
            }
        }
    }
    pub use storage_client::StorageClient;
    pub use storage_type::{Storage, StorageKeyValuePair};
    /// Types representing an address which describes where a storage
    /// entry lives and how to properly decode it.
    pub mod address {
        pub use super::storage_address::{
            dynamic, Address, DynamicAddress, StaticStorageKey, StorageAddress, Yes,
        };
    }
    pub use storage_key::StorageKey;
    pub use storage_address::{dynamic, Address, DynamicAddress, StorageAddress};
}
pub mod tx {
    //! Create and submit extrinsics.
    //!
    //! An extrinsic is submitted with an "signed extra" and "additional" parameters, which can be
    //! different for each chain. The trait [`crate::config::ExtrinsicParams`] determines exactly which
    //! additional and signed extra parameters are used when constructing an extrinsic, and is a part
    //! of the chain configuration (see [`crate::config::Config`]).
    use crate::macros::cfg_substrate_compat;
    mod signer {
        //! A library to **sub**mit e**xt**rinsics to a
        //! [substrate](https://github.com/paritytech/substrate) node via RPC.
        use crate::macros::cfg_substrate_compat;
        use crate::Config;
        /// Signing transactions requires a [`Signer`]. This is responsible for
        /// providing the "from" account that the transaction is being signed by,
        /// as well as actually signing a SCALE encoded payload.
        pub trait Signer<T: Config> {
            /// Return the "from" account ID.
            fn account_id(&self) -> T::AccountId;
            /// Return the "from" address.
            fn address(&self) -> T::Address;
            /// Takes a signer payload for an extrinsic, and returns a signature based on it.
            ///
            /// Some signers may fail, for instance because the hardware on which the keys are located has
            /// refused the operation.
            fn sign(&self, signer_payload: &[u8]) -> T::Signature;
        }
    }
    mod tx_client {
        use std::borrow::Cow;
        use crate::{
            backend::{BackendExt, BlockRef, TransactionStatus},
            client::{OfflineClientT, OnlineClientT},
            config::{Config, ExtrinsicParams, ExtrinsicParamsEncoder, Hasher},
            error::{Error, MetadataError},
            tx::{Signer as SignerT, TxPayload, TxProgress},
            utils::{Encoded, PhantomDataSendSync},
        };
        use codec::{Compact, Decode, Encode};
        use derivative::Derivative;
        use sp_core_hashing::blake2_256;
        /// A client for working with transactions.
        #[derivative(Clone(bound = "Client: Clone"))]
        pub struct TxClient<T: Config, Client> {
            client: Client,
            _marker: PhantomDataSendSync<T>,
        }
        #[allow(unused_qualifications)]
        impl<T: Config, Client> ::std::clone::Clone for TxClient<T, Client>
        where
            Client: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    TxClient { client: ref __arg_0, _marker: ref __arg_1 } => {
                        TxClient {
                            client: (*__arg_0).clone(),
                            _marker: (*__arg_1).clone(),
                        }
                    }
                }
            }
        }
        impl<T: Config, Client> TxClient<T, Client> {
            /// Create a new [`TxClient`]
            pub fn new(client: Client) -> Self {
                Self {
                    client,
                    _marker: PhantomDataSendSync::new(),
                }
            }
        }
        impl<T: Config, C: OfflineClientT<T>> TxClient<T, C> {
            /// Run the validation logic against some extrinsic you'd like to submit. Returns `Ok(())`
            /// if the call is valid (or if it's not possible to check since the call has no validation hash).
            /// Return an error if the call was not valid or something went wrong trying to validate it (ie
            /// the pallet or call in question do not exist at all).
            pub fn validate<Call>(&self, call: &Call) -> Result<(), Error>
            where
                Call: TxPayload,
            {
                if let Some(details) = call.validation_details() {
                    let expected_hash = self
                        .client
                        .metadata()
                        .pallet_by_name_err(details.pallet_name)?
                        .call_hash(details.call_name)
                        .ok_or_else(|| MetadataError::CallNameNotFound(
                            details.call_name.to_owned(),
                        ))?;
                    if details.hash != expected_hash {
                        return Err(MetadataError::IncompatibleCodegen.into());
                    }
                }
                Ok(())
            }
            /// Return the SCALE encoded bytes representing the call data of the transaction.
            pub fn call_data<Call>(&self, call: &Call) -> Result<Vec<u8>, Error>
            where
                Call: TxPayload,
            {
                let metadata = self.client.metadata();
                let mut bytes = Vec::new();
                call.encode_call_data_to(&metadata, &mut bytes)?;
                Ok(bytes)
            }
            /// Creates an unsigned extrinsic without submitting it.
            pub fn create_unsigned<Call>(
                &self,
                call: &Call,
            ) -> Result<SubmittableExtrinsic<T, C>, Error>
            where
                Call: TxPayload,
            {
                self.validate(call)?;
                let extrinsic = {
                    let mut encoded_inner = Vec::new();
                    4u8.encode_to(&mut encoded_inner);
                    call.encode_call_data_to(
                        &self.client.metadata(),
                        &mut encoded_inner,
                    )?;
                    let len = Compact(
                        u32::try_from(encoded_inner.len())
                            .expect("extrinsic size expected to be <4GB"),
                    );
                    let mut encoded = Vec::new();
                    len.encode_to(&mut encoded);
                    encoded.extend(encoded_inner);
                    encoded
                };
                Ok(SubmittableExtrinsic::from_bytes(self.client.clone(), extrinsic))
            }
            /// Create a partial extrinsic.
            pub fn create_partial_signed_with_nonce<Call>(
                &self,
                call: &Call,
                account_nonce: u64,
                other_params: <T::ExtrinsicParams as ExtrinsicParams<T>>::OtherParams,
            ) -> Result<PartialExtrinsic<T, C>, Error>
            where
                Call: TxPayload,
            {
                self.validate(call)?;
                let call_data = self.call_data(call)?;
                let additional_and_extra_params = <T::ExtrinsicParams as ExtrinsicParams<
                    T,
                >>::new(account_nonce, self.client.clone(), other_params)?;
                Ok(PartialExtrinsic {
                    client: self.client.clone(),
                    call_data,
                    additional_and_extra_params,
                })
            }
            /// Creates a signed extrinsic without submitting it.
            pub fn create_signed_with_nonce<Call, Signer>(
                &self,
                call: &Call,
                signer: &Signer,
                account_nonce: u64,
                other_params: <T::ExtrinsicParams as ExtrinsicParams<T>>::OtherParams,
            ) -> Result<SubmittableExtrinsic<T, C>, Error>
            where
                Call: TxPayload,
                Signer: SignerT<T>,
            {
                self.validate(call)?;
                let partial_signed = self
                    .create_partial_signed_with_nonce(
                        call,
                        account_nonce,
                        other_params,
                    )?;
                Ok(partial_signed.sign(signer))
            }
        }
        impl<T, C> TxClient<T, C>
        where
            T: Config,
            C: OnlineClientT<T>,
        {
            /// Get the account nonce for a given account ID.
            pub async fn account_nonce(
                &self,
                account_id: &T::AccountId,
            ) -> Result<u64, Error> {
                let block_ref = self
                    .client
                    .backend()
                    .latest_finalized_block_ref()
                    .await?;
                crate::blocks::get_account_nonce(
                        &self.client,
                        account_id,
                        block_ref.hash(),
                    )
                    .await
            }
            /// Creates a partial signed extrinsic, without submitting it.
            pub async fn create_partial_signed<Call>(
                &self,
                call: &Call,
                account_id: &T::AccountId,
                other_params: <T::ExtrinsicParams as ExtrinsicParams<T>>::OtherParams,
            ) -> Result<PartialExtrinsic<T, C>, Error>
            where
                Call: TxPayload,
            {
                let account_nonce = self.account_nonce(account_id).await?;
                self.create_partial_signed_with_nonce(call, account_nonce, other_params)
            }
            /// Creates a signed extrinsic, without submitting it.
            pub async fn create_signed<Call, Signer>(
                &self,
                call: &Call,
                signer: &Signer,
                other_params: <T::ExtrinsicParams as ExtrinsicParams<T>>::OtherParams,
            ) -> Result<SubmittableExtrinsic<T, C>, Error>
            where
                Call: TxPayload,
                Signer: SignerT<T>,
            {
                let account_nonce = self.account_nonce(&signer.account_id()).await?;
                self.create_signed_with_nonce(call, signer, account_nonce, other_params)
            }
            /// Creates and signs an extrinsic and submits it to the chain. Passes default parameters
            /// to construct the "signed extra" and "additional" payloads needed by the extrinsic.
            ///
            /// Returns a [`TxProgress`], which can be used to track the status of the transaction
            /// and obtain details about it, once it has made it into a block.
            pub async fn sign_and_submit_then_watch_default<Call, Signer>(
                &self,
                call: &Call,
                signer: &Signer,
            ) -> Result<TxProgress<T, C>, Error>
            where
                Call: TxPayload,
                Signer: SignerT<T>,
                <T::ExtrinsicParams as ExtrinsicParams<T>>::OtherParams: Default,
            {
                self.sign_and_submit_then_watch(call, signer, Default::default()).await
            }
            /// Creates and signs an extrinsic and submits it to the chain.
            ///
            /// Returns a [`TxProgress`], which can be used to track the status of the transaction
            /// and obtain details about it, once it has made it into a block.
            pub async fn sign_and_submit_then_watch<Call, Signer>(
                &self,
                call: &Call,
                signer: &Signer,
                other_params: <T::ExtrinsicParams as ExtrinsicParams<T>>::OtherParams,
            ) -> Result<TxProgress<T, C>, Error>
            where
                Call: TxPayload,
                Signer: SignerT<T>,
            {
                self.create_signed(call, signer, other_params)
                    .await?
                    .submit_and_watch()
                    .await
            }
            /// Creates and signs an extrinsic and submits to the chain for block inclusion. Passes
            /// default parameters to construct the "signed extra" and "additional" payloads needed
            /// by the extrinsic.
            ///
            /// Returns `Ok` with the extrinsic hash if it is valid extrinsic.
            ///
            /// # Note
            ///
            /// Success does not mean the extrinsic has been included in the block, just that it is valid
            /// and has been included in the transaction pool.
            pub async fn sign_and_submit_default<Call, Signer>(
                &self,
                call: &Call,
                signer: &Signer,
            ) -> Result<T::Hash, Error>
            where
                Call: TxPayload,
                Signer: SignerT<T>,
                <T::ExtrinsicParams as ExtrinsicParams<T>>::OtherParams: Default,
            {
                self.sign_and_submit(call, signer, Default::default()).await
            }
            /// Creates and signs an extrinsic and submits to the chain for block inclusion.
            ///
            /// Returns `Ok` with the extrinsic hash if it is valid extrinsic.
            ///
            /// # Note
            ///
            /// Success does not mean the extrinsic has been included in the block, just that it is valid
            /// and has been included in the transaction pool.
            pub async fn sign_and_submit<Call, Signer>(
                &self,
                call: &Call,
                signer: &Signer,
                other_params: <T::ExtrinsicParams as ExtrinsicParams<T>>::OtherParams,
            ) -> Result<T::Hash, Error>
            where
                Call: TxPayload,
                Signer: SignerT<T>,
            {
                self.create_signed(call, signer, other_params).await?.submit().await
            }
        }
        /// This payload contains the information needed to produce an extrinsic.
        pub struct PartialExtrinsic<T: Config, C> {
            client: C,
            call_data: Vec<u8>,
            additional_and_extra_params: T::ExtrinsicParams,
        }
        impl<T, C> PartialExtrinsic<T, C>
        where
            T: Config,
            C: OfflineClientT<T>,
        {
            fn with_signer_payload<F, R>(&self, f: F) -> R
            where
                F: for<'a> FnOnce(Cow<'a, [u8]>) -> R,
            {
                let mut bytes = self.call_data.clone();
                self.additional_and_extra_params.encode_extra_to(&mut bytes);
                self.additional_and_extra_params.encode_additional_to(&mut bytes);
                if bytes.len() > 256 {
                    f(Cow::Borrowed(blake2_256(&bytes).as_ref()))
                } else {
                    f(Cow::Owned(bytes))
                }
            }
            /// Return the signer payload for this extrinsic. These are the bytes that must
            /// be signed in order to produce a valid signature for the extrinsic.
            pub fn signer_payload(&self) -> Vec<u8> {
                self.with_signer_payload(|bytes| bytes.to_vec())
            }
            /// Return the bytes representing the call data for this partially constructed
            /// extrinsic.
            pub fn call_data(&self) -> &[u8] {
                &self.call_data
            }
            /// Convert this [`PartialExtrinsic`] into a [`SubmittableExtrinsic`], ready to submit.
            /// The provided `signer` is responsible for providing the "from" address for the transaction,
            /// as well as providing a signature to attach to it.
            pub fn sign<Signer>(&self, signer: &Signer) -> SubmittableExtrinsic<T, C>
            where
                Signer: SignerT<T>,
            {
                let signature = self.with_signer_payload(|bytes| signer.sign(&bytes));
                self.sign_with_address_and_signature(&signer.address(), &signature)
            }
            /// Convert this [`PartialExtrinsic`] into a [`SubmittableExtrinsic`], ready to submit.
            /// An address, and something representing a signature that can be SCALE encoded, are both
            /// needed in order to construct it. If you have a `Signer` to hand, you can use
            /// [`PartialExtrinsic::sign()`] instead.
            pub fn sign_with_address_and_signature(
                &self,
                address: &T::Address,
                signature: &T::Signature,
            ) -> SubmittableExtrinsic<T, C> {
                let extrinsic = {
                    let mut encoded_inner = Vec::new();
                    (0b10000000 + 4u8).encode_to(&mut encoded_inner);
                    address.encode_to(&mut encoded_inner);
                    signature.encode_to(&mut encoded_inner);
                    self.additional_and_extra_params.encode_extra_to(&mut encoded_inner);
                    encoded_inner.extend(&self.call_data);
                    let len = Compact(
                        u32::try_from(encoded_inner.len())
                            .expect("extrinsic size expected to be <4GB"),
                    );
                    let mut encoded = Vec::new();
                    len.encode_to(&mut encoded);
                    encoded.extend(encoded_inner);
                    encoded
                };
                SubmittableExtrinsic::from_bytes(self.client.clone(), extrinsic)
            }
        }
        /// This represents an extrinsic that has been signed and is ready to submit.
        pub struct SubmittableExtrinsic<T, C> {
            client: C,
            encoded: Encoded,
            marker: std::marker::PhantomData<T>,
        }
        impl<T, C> SubmittableExtrinsic<T, C>
        where
            T: Config,
            C: OfflineClientT<T>,
        {
            /// Create a [`SubmittableExtrinsic`] from some already-signed and prepared
            /// extrinsic bytes, and some client (anything implementing [`OfflineClientT`]
            /// or [`OnlineClientT`]).
            ///
            /// Prefer to use [`TxClient`] to create and sign extrinsics. This is simply
            /// exposed in case you want to skip this process and submit something you've
            /// already created.
            pub fn from_bytes(client: C, tx_bytes: Vec<u8>) -> Self {
                Self {
                    client,
                    encoded: Encoded(tx_bytes),
                    marker: std::marker::PhantomData,
                }
            }
            /// Calculate and return the hash of the extrinsic, based on the configured hasher.
            pub fn hash(&self) -> T::Hash {
                T::Hasher::hash_of(&self.encoded)
            }
            /// Returns the SCALE encoded extrinsic bytes.
            pub fn encoded(&self) -> &[u8] {
                &self.encoded.0
            }
            /// Consumes [`SubmittableExtrinsic`] and returns the SCALE encoded
            /// extrinsic bytes.
            pub fn into_encoded(self) -> Vec<u8> {
                self.encoded.0
            }
        }
        impl<T, C> SubmittableExtrinsic<T, C>
        where
            T: Config,
            C: OnlineClientT<T>,
        {
            /// Submits the extrinsic to the chain.
            ///
            /// Returns a [`TxProgress`], which can be used to track the status of the transaction
            /// and obtain details about it, once it has made it into a block.
            pub async fn submit_and_watch(&self) -> Result<TxProgress<T, C>, Error> {
                let ext_hash = self.hash();
                let sub = self
                    .client
                    .backend()
                    .submit_transaction(&self.encoded.0)
                    .await?;
                Ok(TxProgress::new(sub, self.client.clone(), ext_hash))
            }
            /// Submits the extrinsic to the chain for block inclusion.
            ///
            /// It's usually better to call `submit_and_watch` to get an idea of the progress of the
            /// submission and whether it's eventually successful or not. This call does not guarantee
            /// success, and is just sending the transaction to the chain.
            pub async fn submit(&self) -> Result<T::Hash, Error> {
                let ext_hash = self.hash();
                let mut sub = self
                    .client
                    .backend()
                    .submit_transaction(&self.encoded.0)
                    .await?;
                match sub.next().await {
                    Some(Ok(status)) => {
                        match status {
                            TransactionStatus::Validated
                            | TransactionStatus::Broadcasted { .. }
                            | TransactionStatus::InBestBlock { .. }
                            | TransactionStatus::NoLongerInBestBlock
                            | TransactionStatus::InFinalizedBlock { .. } => Ok(ext_hash),
                            TransactionStatus::Error { message } => {
                                Err(
                                    Error::Other({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Transaction error: {0}", message),
                                        );
                                        res
                                    }),
                                )
                            }
                            TransactionStatus::Invalid { message } => {
                                Err(
                                    Error::Other({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Transaction invalid: {0}", message),
                                        );
                                        res
                                    }),
                                )
                            }
                            TransactionStatus::Dropped { message } => {
                                Err(
                                    Error::Other({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Transaction dropped: {0}", message),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    Some(Err(e)) => Err(e),
                    None => {
                        Err(
                            Error::Other(
                                "Transaction broadcast was unsuccessful; stream terminated early"
                                    .into(),
                            ),
                        )
                    }
                }
            }
            /// Validate a transaction by submitting it to the relevant Runtime API. A transaction that is
            /// valid can be added to a block, but may still end up in an error state.
            ///
            /// Returns `Ok` with a [`ValidationResult`], which is the result of attempting to dry run the extrinsic.
            pub async fn validate(&self) -> Result<ValidationResult, Error> {
                let latest_block_ref = self
                    .client
                    .backend()
                    .latest_finalized_block_ref()
                    .await?;
                self.validate_at(latest_block_ref).await
            }
            /// Validate a transaction by submitting it to the relevant Runtime API. A transaction that is
            /// valid can be added to a block, but may still end up in an error state.
            ///
            /// Returns `Ok` with a [`ValidationResult`], which is the result of attempting to dry run the extrinsic.
            pub async fn validate_at(
                &self,
                at: impl Into<BlockRef<T::Hash>>,
            ) -> Result<ValidationResult, Error> {
                let block_hash = at.into().hash();
                let mut params = Vec::with_capacity(8 + self.encoded.0.len() + 8);
                2u8.encode_to(&mut params);
                params.extend(self.encoded().iter());
                block_hash.encode_to(&mut params);
                let res: Vec<u8> = self
                    .client
                    .backend()
                    .call(
                        "TaggedTransactionQueue_validate_transaction",
                        Some(&params),
                        block_hash,
                    )
                    .await?;
                ValidationResult::try_from_bytes(res)
            }
            /// This returns an estimate for what the extrinsic is expected to cost to execute, less any tips.
            /// The actual amount paid can vary from block to block based on node traffic and other factors.
            pub async fn partial_fee_estimate(&self) -> Result<u128, Error> {
                let mut params = self.encoded().to_vec();
                (self.encoded().len() as u32).encode_to(&mut params);
                let latest_block_ref = self
                    .client
                    .backend()
                    .latest_finalized_block_ref()
                    .await?;
                let (_, _, _, partial_fee) = self
                    .client
                    .backend()
                    .call_decoding::<
                        (Compact<u64>, Compact<u64>, u8, u128),
                    >(
                        "TransactionPaymentApi_query_info",
                        Some(&params),
                        latest_block_ref.hash(),
                    )
                    .await?;
                Ok(partial_fee)
            }
        }
        impl ValidationResult {
            #[allow(clippy::get_first)]
            fn try_from_bytes(bytes: Vec<u8>) -> Result<ValidationResult, crate::Error> {
                if bytes.get(0) == Some(&0) {
                    let res = TransactionValid::decode(&mut &bytes[1..])?;
                    Ok(ValidationResult::Valid(res))
                } else if bytes.get(0) == Some(&1) && bytes.get(1) == Some(&0) {
                    let res = TransactionInvalid::decode(&mut &bytes[2..])?;
                    Ok(ValidationResult::Invalid(res))
                } else if bytes.get(0) == Some(&1) && bytes.get(1) == Some(&1) {
                    let res = TransactionUnknown::decode(&mut &bytes[2..])?;
                    Ok(ValidationResult::Unknown(res))
                } else {
                    Err(crate::Error::Unknown(bytes))
                }
            }
        }
        /// The result of performing [`SubmittableExtrinsic::validate()`].
        pub enum ValidationResult {
            /// The transaction is valid
            Valid(TransactionValid),
            /// The transaction is invalid
            Invalid(TransactionInvalid),
            /// Unable to validate the transaction
            Unknown(TransactionUnknown),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ValidationResult {
            #[inline]
            fn clone(&self) -> ValidationResult {
                match self {
                    ValidationResult::Valid(__self_0) => {
                        ValidationResult::Valid(::core::clone::Clone::clone(__self_0))
                    }
                    ValidationResult::Invalid(__self_0) => {
                        ValidationResult::Invalid(::core::clone::Clone::clone(__self_0))
                    }
                    ValidationResult::Unknown(__self_0) => {
                        ValidationResult::Unknown(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ValidationResult {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    ValidationResult::Valid(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Valid",
                            &__self_0,
                        )
                    }
                    ValidationResult::Invalid(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Invalid",
                            &__self_0,
                        )
                    }
                    ValidationResult::Unknown(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Unknown",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ValidationResult {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ValidationResult {
            #[inline]
            fn eq(&self, other: &ValidationResult) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            ValidationResult::Valid(__self_0),
                            ValidationResult::Valid(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ValidationResult::Invalid(__self_0),
                            ValidationResult::Invalid(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            ValidationResult::Unknown(__self_0),
                            ValidationResult::Unknown(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        impl ValidationResult {
            /// Is the transaction valid.
            pub fn is_valid(&self) -> bool {
                match self {
                    ValidationResult::Valid(_) => true,
                    _ => false,
                }
            }
        }
        /// Transaction is valid; here is some more information about it.
        pub struct TransactionValid {
            /// Priority of the transaction.
            ///
            /// Priority determines the ordering of two transactions that have all
            /// their dependencies (required tags) satisfied.
            pub priority: u64,
            /// Transaction dependencies
            ///
            /// A non-empty list signifies that some other transactions which provide
            /// given tags are required to be included before that one.
            pub requires: Vec<Vec<u8>>,
            /// Provided tags
            ///
            /// A list of tags this transaction provides. Successfully importing the transaction
            /// will enable other transactions that depend on (require) those tags to be included as well.
            /// Provided and required tags allow Substrate to build a dependency graph of transactions
            /// and import them in the right (linear) order.
            pub provides: Vec<Vec<u8>>,
            /// Transaction longevity
            ///
            /// Longevity describes minimum number of blocks the validity is correct.
            /// After this period transaction should be removed from the pool or revalidated.
            pub longevity: u64,
            /// A flag indicating if the transaction should be propagated to other peers.
            ///
            /// By setting `false` here the transaction will still be considered for
            /// including in blocks that are authored on the current node, but will
            /// never be sent to other peers.
            pub propagate: bool,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Decode for TransactionValid {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(TransactionValid {
                        priority: {
                            let __codec_res_edqy = <u64 as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `TransactionValid::priority`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                        requires: {
                            let __codec_res_edqy = <Vec<
                                Vec<u8>,
                            > as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `TransactionValid::requires`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                        provides: {
                            let __codec_res_edqy = <Vec<
                                Vec<u8>,
                            > as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `TransactionValid::provides`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                        longevity: {
                            let __codec_res_edqy = <u64 as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `TransactionValid::longevity`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                        propagate: {
                            let __codec_res_edqy = <bool as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `TransactionValid::propagate`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                    })
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for TransactionValid {
            #[inline]
            fn clone(&self) -> TransactionValid {
                TransactionValid {
                    priority: ::core::clone::Clone::clone(&self.priority),
                    requires: ::core::clone::Clone::clone(&self.requires),
                    provides: ::core::clone::Clone::clone(&self.provides),
                    longevity: ::core::clone::Clone::clone(&self.longevity),
                    propagate: ::core::clone::Clone::clone(&self.propagate),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TransactionValid {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "TransactionValid",
                    "priority",
                    &self.priority,
                    "requires",
                    &self.requires,
                    "provides",
                    &self.provides,
                    "longevity",
                    &self.longevity,
                    "propagate",
                    &&self.propagate,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TransactionValid {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TransactionValid {
            #[inline]
            fn eq(&self, other: &TransactionValid) -> bool {
                self.priority == other.priority && self.requires == other.requires
                    && self.provides == other.provides
                    && self.longevity == other.longevity
                    && self.propagate == other.propagate
            }
        }
        /// The runtime was unable to validate the transaction.
        pub enum TransactionUnknown {
            /// Could not lookup some information that is required to validate the transaction.
            CannotLookup,
            /// No validator found for the given unsigned transaction.
            NoUnsignedValidator,
            /// Any other custom unknown validity that is not covered by this enum.
            Custom(u8),
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Decode for TransactionUnknown {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy
                        .read_byte()
                        .map_err(|e| {
                            e
                                .chain(
                                    "Could not decode `TransactionUnknown`, failed to read variant byte",
                                )
                        })?
                    {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 0usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(TransactionUnknown::CannotLookup)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 1usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    TransactionUnknown::NoUnsignedValidator,
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 2usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    TransactionUnknown::Custom({
                                        let __codec_res_edqy = <u8 as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `TransactionUnknown::Custom.0`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    }),
                                )
                            })();
                        }
                        _ => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Err(
                                    <_ as ::core::convert::Into<
                                        _,
                                    >>::into(
                                        "Could not decode `TransactionUnknown`, variant doesn't exist",
                                    ),
                                )
                            })();
                        }
                    }
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for TransactionUnknown {
            #[inline]
            fn clone(&self) -> TransactionUnknown {
                match self {
                    TransactionUnknown::CannotLookup => TransactionUnknown::CannotLookup,
                    TransactionUnknown::NoUnsignedValidator => {
                        TransactionUnknown::NoUnsignedValidator
                    }
                    TransactionUnknown::Custom(__self_0) => {
                        TransactionUnknown::Custom(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TransactionUnknown {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    TransactionUnknown::CannotLookup => {
                        ::core::fmt::Formatter::write_str(f, "CannotLookup")
                    }
                    TransactionUnknown::NoUnsignedValidator => {
                        ::core::fmt::Formatter::write_str(f, "NoUnsignedValidator")
                    }
                    TransactionUnknown::Custom(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Custom",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TransactionUnknown {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TransactionUnknown {
            #[inline]
            fn eq(&self, other: &TransactionUnknown) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            TransactionUnknown::Custom(__self_0),
                            TransactionUnknown::Custom(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => true,
                    }
            }
        }
        /// The transaction is invalid.
        pub enum TransactionInvalid {
            /// The call of the transaction is not expected.
            Call,
            /// General error to do with the inability to pay some fees (e.g. account balance too low).
            Payment,
            /// General error to do with the transaction not yet being valid (e.g. nonce too high).
            Future,
            /// General error to do with the transaction being outdated (e.g. nonce too low).
            Stale,
            /// General error to do with the transaction's proofs (e.g. signature).
            ///
            /// # Possible causes
            ///
            /// When using a signed extension that provides additional data for signing, it is required
            /// that the signing and the verifying side use the same additional data. Additional
            /// data will only be used to generate the signature, but will not be part of the transaction
            /// itself. As the verifying side does not know which additional data was used while signing
            /// it will only be able to assume a bad signature and cannot express a more meaningful error.
            BadProof,
            /// The transaction birth block is ancient.
            ///
            /// # Possible causes
            ///
            /// For `FRAME`-based runtimes this would be caused by `current block number
            /// - Era::birth block number > BlockHashCount`. (e.g. in Polkadot `BlockHashCount` = 2400, so
            ///   a
            /// transaction with birth block number 1337 would be valid up until block number 1337 + 2400,
            /// after which point the transaction would be considered to have an ancient birth block.)
            AncientBirthBlock,
            /// The transaction would exhaust the resources of current block.
            ///
            /// The transaction might be valid, but there are not enough resources
            /// left in the current block.
            ExhaustsResources,
            /// Any other custom invalid validity that is not covered by this enum.
            Custom(u8),
            /// An extrinsic with a Mandatory dispatch resulted in Error. This is indicative of either a
            /// malicious validator or a buggy `provide_inherent`. In any case, it can result in
            /// dangerously overweight blocks and therefore if found, invalidates the block.
            BadMandatory,
            /// An extrinsic with a mandatory dispatch tried to be validated.
            /// This is invalid; only inherent extrinsics are allowed to have mandatory dispatches.
            MandatoryValidation,
            /// The sending address is disabled or known to be invalid.
            BadSigner,
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Decode for TransactionInvalid {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy
                        .read_byte()
                        .map_err(|e| {
                            e
                                .chain(
                                    "Could not decode `TransactionInvalid`, failed to read variant byte",
                                )
                        })?
                    {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 0usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(TransactionInvalid::Call)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 1usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(TransactionInvalid::Payment)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 2usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(TransactionInvalid::Future)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 3usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(TransactionInvalid::Stale)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 4usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(TransactionInvalid::BadProof)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 5usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    TransactionInvalid::AncientBirthBlock,
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 6usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    TransactionInvalid::ExhaustsResources,
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 7usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    TransactionInvalid::Custom({
                                        let __codec_res_edqy = <u8 as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `TransactionInvalid::Custom.0`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    }),
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 8usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(TransactionInvalid::BadMandatory)
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 9usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    TransactionInvalid::MandatoryValidation,
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 10usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(TransactionInvalid::BadSigner)
                            })();
                        }
                        _ => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Err(
                                    <_ as ::core::convert::Into<
                                        _,
                                    >>::into(
                                        "Could not decode `TransactionInvalid`, variant doesn't exist",
                                    ),
                                )
                            })();
                        }
                    }
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for TransactionInvalid {
            #[inline]
            fn clone(&self) -> TransactionInvalid {
                match self {
                    TransactionInvalid::Call => TransactionInvalid::Call,
                    TransactionInvalid::Payment => TransactionInvalid::Payment,
                    TransactionInvalid::Future => TransactionInvalid::Future,
                    TransactionInvalid::Stale => TransactionInvalid::Stale,
                    TransactionInvalid::BadProof => TransactionInvalid::BadProof,
                    TransactionInvalid::AncientBirthBlock => {
                        TransactionInvalid::AncientBirthBlock
                    }
                    TransactionInvalid::ExhaustsResources => {
                        TransactionInvalid::ExhaustsResources
                    }
                    TransactionInvalid::Custom(__self_0) => {
                        TransactionInvalid::Custom(::core::clone::Clone::clone(__self_0))
                    }
                    TransactionInvalid::BadMandatory => TransactionInvalid::BadMandatory,
                    TransactionInvalid::MandatoryValidation => {
                        TransactionInvalid::MandatoryValidation
                    }
                    TransactionInvalid::BadSigner => TransactionInvalid::BadSigner,
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TransactionInvalid {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    TransactionInvalid::Call => {
                        ::core::fmt::Formatter::write_str(f, "Call")
                    }
                    TransactionInvalid::Payment => {
                        ::core::fmt::Formatter::write_str(f, "Payment")
                    }
                    TransactionInvalid::Future => {
                        ::core::fmt::Formatter::write_str(f, "Future")
                    }
                    TransactionInvalid::Stale => {
                        ::core::fmt::Formatter::write_str(f, "Stale")
                    }
                    TransactionInvalid::BadProof => {
                        ::core::fmt::Formatter::write_str(f, "BadProof")
                    }
                    TransactionInvalid::AncientBirthBlock => {
                        ::core::fmt::Formatter::write_str(f, "AncientBirthBlock")
                    }
                    TransactionInvalid::ExhaustsResources => {
                        ::core::fmt::Formatter::write_str(f, "ExhaustsResources")
                    }
                    TransactionInvalid::Custom(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Custom",
                            &__self_0,
                        )
                    }
                    TransactionInvalid::BadMandatory => {
                        ::core::fmt::Formatter::write_str(f, "BadMandatory")
                    }
                    TransactionInvalid::MandatoryValidation => {
                        ::core::fmt::Formatter::write_str(f, "MandatoryValidation")
                    }
                    TransactionInvalid::BadSigner => {
                        ::core::fmt::Formatter::write_str(f, "BadSigner")
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TransactionInvalid {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TransactionInvalid {
            #[inline]
            fn eq(&self, other: &TransactionInvalid) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            TransactionInvalid::Custom(__self_0),
                            TransactionInvalid::Custom(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => true,
                    }
            }
        }
    }
    mod tx_payload {
        //! This module contains the trait and types used to represent
        //! transactions that can be submitted.
        use crate::{
            dynamic::Value, error::{Error, MetadataError},
            metadata::Metadata,
        };
        use codec::Encode;
        use derivative::Derivative;
        use scale_encode::EncodeAsFields;
        use scale_value::{Composite, ValueDef, Variant};
        use std::{borrow::Cow, sync::Arc};
        /// This represents a transaction payload that can be submitted
        /// to a node.
        pub trait TxPayload {
            /// Encode call data to the provided output.
            fn encode_call_data_to(
                &self,
                metadata: &Metadata,
                out: &mut Vec<u8>,
            ) -> Result<(), Error>;
            /// Encode call data and return the output. This is a convenience
            /// wrapper around [`TxPayload::encode_call_data_to`].
            fn encode_call_data(&self, metadata: &Metadata) -> Result<Vec<u8>, Error> {
                let mut v = Vec::new();
                self.encode_call_data_to(metadata, &mut v)?;
                Ok(v)
            }
            /// Returns the details needed to validate the call, which
            /// include a statically generated hash, the pallet name,
            /// and the call name.
            fn validation_details(&self) -> Option<ValidationDetails<'_>> {
                None
            }
        }
        pub struct ValidationDetails<'a> {
            /// The pallet name.
            pub pallet_name: &'a str,
            /// The call name.
            pub call_name: &'a str,
            /// A hash (this is generated at compile time in our codegen)
            /// to compare against the runtime code.
            pub hash: [u8; 32],
        }
        /// A transaction payload containing some generic `CallData`.
        #[derivative(
            Clone(bound = "CallData: Clone"),
            Debug(bound = "CallData: std::fmt::Debug"),
            Eq(bound = "CallData: std::cmp::Eq"),
            Ord(bound = "CallData: std::cmp::Ord"),
            PartialEq(bound = "CallData: std::cmp::PartialEq"),
            PartialOrd(bound = "CallData: std::cmp::PartialOrd")
        )]
        pub struct Payload<CallData> {
            pallet_name: Cow<'static, str>,
            call_name: Cow<'static, str>,
            call_data: CallData,
            validation_hash: Option<[u8; 32]>,
        }
        #[allow(unused_qualifications)]
        impl<CallData> ::std::clone::Clone for Payload<CallData>
        where
            CallData: Clone,
        {
            fn clone(&self) -> Self {
                match *self {
                    Payload {
                        pallet_name: ref __arg_0,
                        call_name: ref __arg_1,
                        call_data: ref __arg_2,
                        validation_hash: ref __arg_3,
                    } => {
                        Payload {
                            pallet_name: (*__arg_0).clone(),
                            call_name: (*__arg_1).clone(),
                            call_data: (*__arg_2).clone(),
                            validation_hash: (*__arg_3).clone(),
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<CallData> ::std::fmt::Debug for Payload<CallData>
        where
            CallData: std::fmt::Debug,
        {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    Payload {
                        pallet_name: ref __arg_0,
                        call_name: ref __arg_1,
                        call_data: ref __arg_2,
                        validation_hash: ref __arg_3,
                    } => {
                        let mut __debug_trait_builder = __f.debug_struct("Payload");
                        let _ = __debug_trait_builder.field("pallet_name", &&(*__arg_0));
                        let _ = __debug_trait_builder.field("call_name", &&(*__arg_1));
                        let _ = __debug_trait_builder.field("call_data", &&(*__arg_2));
                        let _ = __debug_trait_builder
                            .field("validation_hash", &&(*__arg_3));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        impl<CallData> ::std::cmp::Eq for Payload<CallData>
        where
            CallData: std::cmp::Eq,
        {}
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<CallData> ::std::cmp::PartialEq for Payload<CallData>
        where
            CallData: std::cmp::PartialEq,
        {
            fn eq(&self, other: &Self) -> bool {
                true
                    && match *self {
                        Payload {
                            pallet_name: ref __self_0,
                            call_name: ref __self_1,
                            call_data: ref __self_2,
                            validation_hash: ref __self_3,
                        } => {
                            match *other {
                                Payload {
                                    pallet_name: ref __other_0,
                                    call_name: ref __other_1,
                                    call_data: ref __other_2,
                                    validation_hash: ref __other_3,
                                } => {
                                    true && &(*__self_0) == &(*__other_0)
                                        && &(*__self_1) == &(*__other_1)
                                        && &(*__self_2) == &(*__other_2)
                                        && &(*__self_3) == &(*__other_3)
                                }
                            }
                        }
                    }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<CallData> ::std::cmp::PartialOrd for Payload<CallData>
        where
            CallData: std::cmp::PartialOrd,
        {
            fn partial_cmp(
                &self,
                other: &Self,
            ) -> ::std::option::Option<::std::cmp::Ordering> {
                match *self {
                    Payload {
                        pallet_name: ref __self_0,
                        call_name: ref __self_1,
                        call_data: ref __self_2,
                        validation_hash: ref __self_3,
                    } => {
                        match *other {
                            Payload {
                                pallet_name: ref __other_0,
                                call_name: ref __other_1,
                                call_data: ref __other_2,
                                validation_hash: ref __other_3,
                            } => {
                                match ::std::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0),
                                    &(*__other_0),
                                ) {
                                    ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                        match ::std::cmp::PartialOrd::partial_cmp(
                                            &(*__self_1),
                                            &(*__other_1),
                                        ) {
                                            ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                                match ::std::cmp::PartialOrd::partial_cmp(
                                                    &(*__self_2),
                                                    &(*__other_2),
                                                ) {
                                                    ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                                        match ::std::cmp::PartialOrd::partial_cmp(
                                                            &(*__self_3),
                                                            &(*__other_3),
                                                        ) {
                                                            ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {
                                                                ::std::option::Option::Some(::std::cmp::Ordering::Equal)
                                                            }
                                                            __derive_ordering_other => __derive_ordering_other,
                                                        }
                                                    }
                                                    __derive_ordering_other => __derive_ordering_other,
                                                }
                                            }
                                            __derive_ordering_other => __derive_ordering_other,
                                        }
                                    }
                                    __derive_ordering_other => __derive_ordering_other,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<CallData> ::std::cmp::Ord for Payload<CallData>
        where
            CallData: std::cmp::Ord,
        {
            fn cmp(&self, other: &Self) -> ::std::cmp::Ordering {
                match *self {
                    Payload {
                        pallet_name: ref __self_0,
                        call_name: ref __self_1,
                        call_data: ref __self_2,
                        validation_hash: ref __self_3,
                    } => {
                        match *other {
                            Payload {
                                pallet_name: ref __other_0,
                                call_name: ref __other_1,
                                call_data: ref __other_2,
                                validation_hash: ref __other_3,
                            } => {
                                match ::std::cmp::Ord::cmp(&(*__self_0), &(*__other_0)) {
                                    ::std::cmp::Ordering::Equal => {
                                        match ::std::cmp::Ord::cmp(&(*__self_1), &(*__other_1)) {
                                            ::std::cmp::Ordering::Equal => {
                                                match ::std::cmp::Ord::cmp(&(*__self_2), &(*__other_2)) {
                                                    ::std::cmp::Ordering::Equal => {
                                                        match ::std::cmp::Ord::cmp(&(*__self_3), &(*__other_3)) {
                                                            ::std::cmp::Ordering::Equal => ::std::cmp::Ordering::Equal,
                                                            __derive_ordering_other => __derive_ordering_other,
                                                        }
                                                    }
                                                    __derive_ordering_other => __derive_ordering_other,
                                                }
                                            }
                                            __derive_ordering_other => __derive_ordering_other,
                                        }
                                    }
                                    __derive_ordering_other => __derive_ordering_other,
                                }
                            }
                        }
                    }
                }
            }
        }
        /// A boxed transaction payload.
        pub type BoxedPayload = Payload<Arc<dyn EncodeAsFields + Send + Sync + 'static>>;
        /// The type of a payload typically used for dynamic transaction payloads.
        pub type DynamicPayload = Payload<Composite<()>>;
        impl<CallData> Payload<CallData> {
            /// Create a new [`Payload`].
            pub fn new(
                pallet_name: impl Into<String>,
                call_name: impl Into<String>,
                call_data: CallData,
            ) -> Self {
                Payload {
                    pallet_name: Cow::Owned(pallet_name.into()),
                    call_name: Cow::Owned(call_name.into()),
                    call_data,
                    validation_hash: None,
                }
            }
            /// Create a new [`Payload`] using static strings for the pallet and call name.
            /// This is only expected to be used from codegen.
            #[doc(hidden)]
            pub fn new_static(
                pallet_name: &'static str,
                call_name: &'static str,
                call_data: CallData,
                validation_hash: [u8; 32],
            ) -> Self {
                Payload {
                    pallet_name: Cow::Borrowed(pallet_name),
                    call_name: Cow::Borrowed(call_name),
                    call_data,
                    validation_hash: Some(validation_hash),
                }
            }
            /// Box the payload.
            pub fn boxed(self) -> BoxedPayload
            where
                CallData: EncodeAsFields + Send + Sync + 'static,
            {
                BoxedPayload {
                    pallet_name: self.pallet_name,
                    call_name: self.call_name,
                    call_data: Arc::new(self.call_data),
                    validation_hash: self.validation_hash,
                }
            }
            /// Do not validate this call prior to submitting it.
            pub fn unvalidated(self) -> Self {
                Self {
                    validation_hash: None,
                    ..self
                }
            }
            /// Returns the call data.
            pub fn call_data(&self) -> &CallData {
                &self.call_data
            }
            /// Returns the pallet name.
            pub fn pallet_name(&self) -> &str {
                &self.pallet_name
            }
            /// Returns the call name.
            pub fn call_name(&self) -> &str {
                &self.call_name
            }
        }
        impl Payload<Composite<()>> {
            /// Convert the dynamic `Composite` payload into a [`Value`].
            /// This is useful if you want to use this as an argument for a
            /// larger dynamic call that wants to use this as a nested call.
            pub fn into_value(self) -> Value<()> {
                let call = Value {
                    context: (),
                    value: ValueDef::Variant(Variant {
                        name: self.call_name.into_owned(),
                        values: self.call_data,
                    }),
                };
                Value::unnamed_variant(self.pallet_name, [call])
            }
        }
        impl<CallData: EncodeAsFields> TxPayload for Payload<CallData> {
            fn encode_call_data_to(
                &self,
                metadata: &Metadata,
                out: &mut Vec<u8>,
            ) -> Result<(), Error> {
                let pallet = metadata.pallet_by_name_err(&self.pallet_name)?;
                let call = pallet
                    .call_variant_by_name(&self.call_name)
                    .ok_or_else(|| MetadataError::CallNameNotFound(
                        (*self.call_name).to_owned(),
                    ))?;
                let pallet_index = pallet.index();
                let call_index = call.index;
                pallet_index.encode_to(out);
                call_index.encode_to(out);
                let mut fields = call
                    .fields
                    .iter()
                    .map(|f| scale_encode::Field::new(f.ty.id, f.name.as_deref()));
                self.call_data.encode_as_fields_to(&mut fields, metadata.types(), out)?;
                Ok(())
            }
            fn validation_details(&self) -> Option<ValidationDetails<'_>> {
                self.validation_hash
                    .map(|hash| ValidationDetails {
                        pallet_name: &self.pallet_name,
                        call_name: &self.call_name,
                        hash,
                    })
            }
        }
        /// Construct a transaction at runtime; essentially an alias to [`Payload::new()`]
        /// which provides a [`Composite`] value for the call data.
        pub fn dynamic(
            pallet_name: impl Into<String>,
            call_name: impl Into<String>,
            call_data: impl Into<Composite<()>>,
        ) -> DynamicPayload {
            Payload::new(pallet_name, call_name, call_data.into())
        }
    }
    mod tx_progress {
        //! Types representing extrinsics/transactions that have been submitted to a node.
        use std::task::Poll;
        use crate::utils::strip_compact_prefix;
        use crate::{
            backend::{BlockRef, StreamOfResults, TransactionStatus as BackendTxStatus},
            client::OnlineClientT,
            error::{DispatchError, Error, RpcError, TransactionError},
            events::EventsClient, Config,
        };
        use derivative::Derivative;
        use futures::{Stream, StreamExt};
        /// This struct represents a subscription to the progress of some transaction.
        pub struct TxProgress<T: Config, C> {
            sub: Option<StreamOfResults<BackendTxStatus<T::Hash>>>,
            ext_hash: T::Hash,
            client: C,
        }
        impl<T: Config, C> std::fmt::Debug for TxProgress<T, C> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.debug_struct("TxProgress")
                    .field("sub", &"<subscription>")
                    .field("ext_hash", &self.ext_hash)
                    .field("client", &"<client>")
                    .finish()
            }
        }
        impl<T: Config, C> Unpin for TxProgress<T, C> {}
        impl<T: Config, C> TxProgress<T, C> {
            /// Instantiate a new [`TxProgress`] from a custom subscription.
            pub fn new(
                sub: StreamOfResults<BackendTxStatus<T::Hash>>,
                client: C,
                ext_hash: T::Hash,
            ) -> Self {
                Self {
                    sub: Some(sub),
                    client,
                    ext_hash,
                }
            }
            /// Return the hash of the extrinsic.
            pub fn extrinsic_hash(&self) -> T::Hash {
                self.ext_hash
            }
        }
        impl<T, C> TxProgress<T, C>
        where
            T: Config,
            C: OnlineClientT<T>,
        {
            /// Return the next transaction status when it's emitted. This just delegates to the
            /// [`futures::Stream`] implementation for [`TxProgress`], but allows you to
            /// avoid importing that trait if you don't otherwise need it.
            pub async fn next(&mut self) -> Option<Result<TxStatus<T, C>, Error>> {
                StreamExt::next(self).await
            }
            /// Wait for the transaction to be finalized, and return a [`TxInBlock`]
            /// instance when it is, or an error if there was a problem waiting for finalization.
            ///
            /// **Note:** consumes `self`. If you'd like to perform multiple actions as the state of the
            /// transaction progresses, use [`TxProgress::next()`] instead.
            ///
            /// **Note:** transaction statuses like `Invalid`/`Usurped`/`Dropped` indicate with some
            /// probability that the transaction will not make it into a block but there is no guarantee
            /// that this is true. In those cases the stream is closed however, so you currently have no way to find
            /// out if they finally made it into a block or not.
            pub async fn wait_for_finalized(mut self) -> Result<TxInBlock<T, C>, Error> {
                while let Some(status) = self.next().await {
                    match status? {
                        TxStatus::InFinalizedBlock(s) => return Ok(s),
                        TxStatus::Error { message } => {
                            return Err(TransactionError::Error(message).into());
                        }
                        TxStatus::Invalid { message } => {
                            return Err(TransactionError::Invalid(message).into());
                        }
                        TxStatus::Dropped { message } => {
                            return Err(TransactionError::Dropped(message).into());
                        }
                        _ => continue,
                    }
                }
                Err(RpcError::SubscriptionDropped.into())
            }
            /// Wait for the transaction to be finalized, and for the transaction events to indicate
            /// that the transaction was successful. Returns the events associated with the transaction,
            /// as well as a couple of other details (block hash and extrinsic hash).
            ///
            /// **Note:** consumes self. If you'd like to perform multiple actions as progress is made,
            /// use [`TxProgress::next()`] instead.
            ///
            /// **Note:** transaction statuses like `Invalid`/`Usurped`/`Dropped` indicate with some
            /// probability that the transaction will not make it into a block but there is no guarantee
            /// that this is true. In those cases the stream is closed however, so you currently have no way to find
            /// out if they finally made it into a block or not.
            pub async fn wait_for_finalized_success(
                self,
            ) -> Result<crate::blocks::ExtrinsicEvents<T>, Error> {
                let evs = self.wait_for_finalized().await?.wait_for_success().await?;
                Ok(evs)
            }
        }
        impl<T: Config, C: Clone> Stream for TxProgress<T, C> {
            type Item = Result<TxStatus<T, C>, Error>;
            fn poll_next(
                mut self: std::pin::Pin<&mut Self>,
                cx: &mut std::task::Context<'_>,
            ) -> std::task::Poll<Option<Self::Item>> {
                let sub = match self.sub.as_mut() {
                    Some(sub) => sub,
                    None => return Poll::Ready(None),
                };
                sub.poll_next_unpin(cx)
                    .map_ok(|status| {
                        match status {
                            BackendTxStatus::Validated => TxStatus::Validated,
                            BackendTxStatus::Broadcasted { num_peers } => {
                                TxStatus::Broadcasted { num_peers }
                            }
                            BackendTxStatus::NoLongerInBestBlock => {
                                TxStatus::NoLongerInBestBlock
                            }
                            BackendTxStatus::InBestBlock { hash } => {
                                TxStatus::InBestBlock(
                                    TxInBlock::new(hash, self.ext_hash, self.client.clone()),
                                )
                            }
                            BackendTxStatus::InFinalizedBlock { hash } => {
                                self.sub = None;
                                TxStatus::InFinalizedBlock(
                                    TxInBlock::new(hash, self.ext_hash, self.client.clone()),
                                )
                            }
                            BackendTxStatus::Error { message } => {
                                self.sub = None;
                                TxStatus::Error { message }
                            }
                            BackendTxStatus::Invalid { message } => {
                                self.sub = None;
                                TxStatus::Invalid { message }
                            }
                            BackendTxStatus::Dropped { message } => {
                                self.sub = None;
                                TxStatus::Dropped { message }
                            }
                        }
                    })
            }
        }
        /// Possible transaction statuses returned from our [`TxProgress::next()`] call.
        #[derivative(Debug(bound = "C: std::fmt::Debug"))]
        pub enum TxStatus<T: Config, C> {
            /// Transaction is part of the future queue.
            Validated,
            /// The transaction has been broadcast to other nodes.
            Broadcasted {
                /// Number of peers it's been broadcast to.
                num_peers: u32,
            },
            /// Transaction is no longer in a best block.
            NoLongerInBestBlock,
            /// Transaction has been included in block with given hash.
            InBestBlock(TxInBlock<T, C>),
            /// Transaction has been finalized by a finality-gadget, e.g GRANDPA
            InFinalizedBlock(TxInBlock<T, C>),
            /// Something went wrong in the node.
            Error {
                /// Human readable message; what went wrong.
                message: String,
            },
            /// Transaction is invalid (bad nonce, signature etc).
            Invalid {
                /// Human readable message; why was it invalid.
                message: String,
            },
            /// The transaction was dropped.
            Dropped {
                /// Human readable message; why was it dropped.
                message: String,
            },
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<T: Config, C> ::std::fmt::Debug for TxStatus<T, C>
        where
            C: std::fmt::Debug,
        {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    TxStatus::Validated => {
                        let mut __debug_trait_builder = __f.debug_tuple("Validated");
                        __debug_trait_builder.finish()
                    }
                    TxStatus::Broadcasted { num_peers: ref __arg_0 } => {
                        let mut __debug_trait_builder = __f.debug_struct("Broadcasted");
                        let _ = __debug_trait_builder.field("num_peers", &&(*__arg_0));
                        __debug_trait_builder.finish()
                    }
                    TxStatus::NoLongerInBestBlock => {
                        let mut __debug_trait_builder = __f
                            .debug_tuple("NoLongerInBestBlock");
                        __debug_trait_builder.finish()
                    }
                    TxStatus::InBestBlock(ref __arg_0) => {
                        let mut __debug_trait_builder = __f.debug_tuple("InBestBlock");
                        let _ = __debug_trait_builder.field(&&(*__arg_0));
                        __debug_trait_builder.finish()
                    }
                    TxStatus::InFinalizedBlock(ref __arg_0) => {
                        let mut __debug_trait_builder = __f
                            .debug_tuple("InFinalizedBlock");
                        let _ = __debug_trait_builder.field(&&(*__arg_0));
                        __debug_trait_builder.finish()
                    }
                    TxStatus::Error { message: ref __arg_0 } => {
                        let mut __debug_trait_builder = __f.debug_struct("Error");
                        let _ = __debug_trait_builder.field("message", &&(*__arg_0));
                        __debug_trait_builder.finish()
                    }
                    TxStatus::Invalid { message: ref __arg_0 } => {
                        let mut __debug_trait_builder = __f.debug_struct("Invalid");
                        let _ = __debug_trait_builder.field("message", &&(*__arg_0));
                        __debug_trait_builder.finish()
                    }
                    TxStatus::Dropped { message: ref __arg_0 } => {
                        let mut __debug_trait_builder = __f.debug_struct("Dropped");
                        let _ = __debug_trait_builder.field("message", &&(*__arg_0));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        impl<T: Config, C> TxStatus<T, C> {
            /// A convenience method to return the finalized details. Returns
            /// [`None`] if the enum variant is not [`TxStatus::InFinalizedBlock`].
            pub fn as_finalized(&self) -> Option<&TxInBlock<T, C>> {
                match self {
                    Self::InFinalizedBlock(val) => Some(val),
                    _ => None,
                }
            }
            /// A convenience method to return the best block details. Returns
            /// [`None`] if the enum variant is not [`TxStatus::InBestBlock`].
            pub fn as_in_block(&self) -> Option<&TxInBlock<T, C>> {
                match self {
                    Self::InBestBlock(val) => Some(val),
                    _ => None,
                }
            }
        }
        /// This struct represents a transaction that has made it into a block.
        #[derivative(Debug(bound = "C: std::fmt::Debug"))]
        pub struct TxInBlock<T: Config, C> {
            block_ref: BlockRef<T::Hash>,
            ext_hash: T::Hash,
            client: C,
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<T: Config, C> ::std::fmt::Debug for TxInBlock<T, C>
        where
            C: std::fmt::Debug,
        {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    TxInBlock {
                        block_ref: ref __arg_0,
                        ext_hash: ref __arg_1,
                        client: ref __arg_2,
                    } => {
                        let mut __debug_trait_builder = __f.debug_struct("TxInBlock");
                        let _ = __debug_trait_builder.field("block_ref", &&(*__arg_0));
                        let _ = __debug_trait_builder.field("ext_hash", &&(*__arg_1));
                        let _ = __debug_trait_builder.field("client", &&(*__arg_2));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        impl<T: Config, C> TxInBlock<T, C> {
            pub(crate) fn new(
                block_ref: BlockRef<T::Hash>,
                ext_hash: T::Hash,
                client: C,
            ) -> Self {
                Self {
                    block_ref,
                    ext_hash,
                    client,
                }
            }
            /// Return the hash of the block that the transaction has made it into.
            pub fn block_hash(&self) -> T::Hash {
                self.block_ref.hash()
            }
            /// Return the hash of the extrinsic that was submitted.
            pub fn extrinsic_hash(&self) -> T::Hash {
                self.ext_hash
            }
        }
        impl<T: Config, C: OnlineClientT<T>> TxInBlock<T, C> {
            /// Fetch the events associated with this transaction. If the transaction
            /// was successful (ie no `ExtrinsicFailed`) events were found, then we return
            /// the events associated with it. If the transaction was not successful, or
            /// something else went wrong, we return an error.
            ///
            /// **Note:** If multiple `ExtrinsicFailed` errors are returned (for instance
            /// because a pallet chooses to emit one as an event, which is considered
            /// abnormal behaviour), it is not specified which of the errors is returned here.
            /// You can use [`TxInBlock::fetch_events`] instead if you'd like to
            /// work with multiple "error" events.
            ///
            /// **Note:** This has to download block details from the node and decode events
            /// from them.
            pub async fn wait_for_success(
                &self,
            ) -> Result<crate::blocks::ExtrinsicEvents<T>, Error> {
                let events = self.fetch_events().await?;
                for ev in events.iter() {
                    let ev = ev?;
                    if ev.pallet_name() == "System"
                        && ev.variant_name() == "ExtrinsicFailed"
                    {
                        let dispatch_error = DispatchError::decode_from(
                            ev.field_bytes(),
                            self.client.metadata(),
                        )?;
                        return Err(dispatch_error.into());
                    }
                }
                Ok(events)
            }
            /// Fetch all of the events associated with this transaction. This succeeds whether
            /// the transaction was a success or not; it's up to you to handle the error and
            /// success events however you prefer.
            ///
            /// **Note:** This has to download block details from the node and decode events
            /// from them.
            pub async fn fetch_events(
                &self,
            ) -> Result<crate::blocks::ExtrinsicEvents<T>, Error> {
                let block_body = self
                    .client
                    .backend()
                    .block_body(self.block_ref.hash())
                    .await?
                    .ok_or(Error::Transaction(TransactionError::BlockNotFound))?;
                let extrinsic_idx = block_body
                    .iter()
                    .position(|ext| {
                        use crate::config::Hasher;
                        let Ok((_, stripped)) = strip_compact_prefix(ext) else {
                        return false;
                    };
                        let hash = T::Hasher::hash_of(&stripped);
                        hash == self.ext_hash
                    })
                    .ok_or(Error::Transaction(TransactionError::BlockNotFound))?;
                let events = EventsClient::new(self.client.clone())
                    .at(self.block_ref.clone())
                    .await?;
                Ok(
                    crate::blocks::ExtrinsicEvents::new(
                        self.ext_hash,
                        extrinsic_idx as u32,
                        events,
                    ),
                )
            }
        }
    }
    pub use self::{
        signer::Signer,
        tx_client::{
            PartialExtrinsic, SubmittableExtrinsic, TransactionInvalid,
            TransactionUnknown, TxClient, ValidationResult,
        },
        tx_payload::{dynamic, BoxedPayload, DynamicPayload, Payload, TxPayload},
        tx_progress::{TxInBlock, TxProgress, TxStatus},
    };
}
pub mod utils {
    //! Miscellaneous utility helpers.
    mod account_id {
        //! The "default" Substrate/Polkadot AccountId. This is used in codegen, as well as signing related bits.
        //! This doesn't contain much functionality itself, but is easy to convert to/from an `sp_core::AccountId32`
        //! for instance, to gain functionality without forcing a dependency on Substrate crates here.
        use codec::{Decode, Encode};
        use serde::{Deserialize, Serialize};
        /// A 32-byte cryptographic identifier. This is a simplified version of Substrate's
        /// `sp_core::crypto::AccountId32`. To obtain more functionality, convert this into
        /// that type.
        pub struct AccountId32(pub [u8; 32]);
        #[automatically_derived]
        impl ::core::clone::Clone for AccountId32 {
            #[inline]
            fn clone(&self) -> AccountId32 {
                AccountId32(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for AccountId32 {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<[u8; 32]>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for AccountId32 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for AccountId32 {
            #[inline]
            fn eq(&self, other: &AccountId32) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for AccountId32 {
            #[inline]
            fn cmp(&self, other: &AccountId32) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for AccountId32 {
            #[inline]
            fn partial_cmp(
                &self,
                other: &AccountId32,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Encode for AccountId32 {
                fn size_hint(&self) -> usize {
                    ::codec::Encode::size_hint(&&self.0)
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    ::codec::Encode::encode_to(&&self.0, __codec_dest_edqy)
                }
                fn encode(&self) -> ::codec::alloc::vec::Vec<::core::primitive::u8> {
                    ::codec::Encode::encode(&&self.0)
                }
                fn using_encoded<
                    __CodecOutputReturn,
                    __CodecUsingEncodedCallback: ::core::ops::FnOnce(
                            &[::core::primitive::u8],
                        ) -> __CodecOutputReturn,
                >(&self, f: __CodecUsingEncodedCallback) -> __CodecOutputReturn {
                    ::codec::Encode::using_encoded(&&self.0, f)
                }
            }
            #[automatically_derived]
            impl ::codec::EncodeLike for AccountId32 {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Decode for AccountId32 {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(
                        AccountId32({
                            let __codec_res_edqy = <[u8; 32] as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `AccountId32.0`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        }),
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for AccountId32 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "AccountId32",
                    &&self.0,
                )
            }
        }
        impl ::scale_encode::EncodeAsType for AccountId32 {
            #[allow(unused_variables)]
            fn encode_as_type_to(
                &self,
                __encode_as_type_type_id: u32,
                __encode_as_type_types: &::scale_encode::PortableRegistry,
                __encode_as_type_out: &mut ::scale_encode::Vec<u8>,
            ) -> Result<(), ::scale_encode::Error> {
                let AccountId32(_0) = self;
                ::scale_encode::Composite(
                        [
                            (
                                None as Option<&'static str>,
                                _0 as &dyn ::scale_encode::EncodeAsType,
                            ),
                        ]
                            .into_iter(),
                    )
                    .encode_as_type_to(
                        __encode_as_type_type_id,
                        __encode_as_type_types,
                        __encode_as_type_out,
                    )
            }
        }
        impl ::scale_encode::EncodeAsFields for AccountId32 {
            #[allow(unused_variables)]
            fn encode_as_fields_to(
                &self,
                __encode_as_type_fields: &mut dyn ::scale_encode::FieldIter<'_>,
                __encode_as_type_types: &::scale_encode::PortableRegistry,
                __encode_as_type_out: &mut ::scale_encode::Vec<u8>,
            ) -> Result<(), ::scale_encode::Error> {
                let AccountId32(_0) = self;
                ::scale_encode::Composite(
                        [
                            (
                                None as Option<&'static str>,
                                _0 as &dyn ::scale_encode::EncodeAsType,
                            ),
                        ]
                            .into_iter(),
                    )
                    .encode_as_fields_to(
                        __encode_as_type_fields,
                        __encode_as_type_types,
                        __encode_as_type_out,
                    )
            }
        }
        const _: () = {
            pub struct Visitor(::core::marker::PhantomData<()>);
            use ::scale_decode::vec;
            use ::scale_decode::ToString;
            impl ::scale_decode::IntoVisitor for AccountId32 {
                type Visitor = Visitor;
                fn into_visitor() -> Self::Visitor {
                    Visitor(::core::marker::PhantomData)
                }
            }
            impl ::scale_decode::Visitor for Visitor {
                type Error = ::scale_decode::Error;
                type Value<'scale, 'info> = AccountId32;
                fn visit_composite<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Composite<'scale, 'info>,
                    type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    self.visit_tuple(&mut value.as_tuple(), type_id)
                }
                fn visit_tuple<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Tuple<'scale, 'info>,
                    type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 1usize {
                        return Err(
                            ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                actual_len: value.remaining(),
                                expected_len: 1usize,
                            }),
                        );
                    }
                    let vals = value;
                    Ok(
                        AccountId32({
                            let val = vals
                                .next()
                                .expect(
                                    "field count should have been checked already on tuple type; please file a bug report",
                                )?;
                            val.decode_as_type().map_err(|e| e.at_idx(0usize))?
                        }),
                    )
                }
            }
            impl ::scale_decode::DecodeAsFields for AccountId32 {
                fn decode_as_fields<'info>(
                    input: &mut &[u8],
                    fields: &mut dyn ::scale_decode::FieldIter<'info>,
                    types: &'info ::scale_decode::PortableRegistry,
                ) -> Result<Self, ::scale_decode::Error> {
                    let path = ::scale_decode::EMPTY_SCALE_INFO_PATH;
                    let mut composite = ::scale_decode::visitor::types::Composite::new(
                        input,
                        path,
                        fields,
                        types,
                        false,
                    );
                    use ::scale_decode::{Visitor, IntoVisitor};
                    let val = <AccountId32>::into_visitor()
                        .visit_composite(
                            &mut composite,
                            ::scale_decode::visitor::TypeId(0),
                        );
                    composite.skip_decoding()?;
                    *input = composite.bytes_from_undecoded();
                    val.map_err(From::from)
                }
            }
        };
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            impl ::scale_info::TypeInfo for AccountId32 {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder()
                        .path(
                            ::scale_info::Path::new_with_replace(
                                "AccountId32",
                                "subxt::utils::account_id",
                                &[],
                            ),
                        )
                        .type_params(::alloc::vec::Vec::new())
                        .docs(
                            &[
                                "A 32-byte cryptographic identifier. This is a simplified version of Substrate's",
                                "`sp_core::crypto::AccountId32`. To obtain more functionality, convert this into",
                                "that type.",
                            ],
                        )
                        .composite(
                            ::scale_info::build::Fields::unnamed()
                                .field(|f| f.ty::<[u8; 32]>().type_name("[u8; 32]")),
                        )
                }
            }
        };
        impl AsRef<[u8]> for AccountId32 {
            fn as_ref(&self) -> &[u8] {
                &self.0[..]
            }
        }
        impl AsRef<[u8; 32]> for AccountId32 {
            fn as_ref(&self) -> &[u8; 32] {
                &self.0
            }
        }
        impl From<[u8; 32]> for AccountId32 {
            fn from(x: [u8; 32]) -> Self {
                AccountId32(x)
            }
        }
        impl AccountId32 {
            fn to_ss58check(&self) -> String {
                const SUBSTRATE_SS58_PREFIX: u8 = 42;
                let mut v = <[_]>::into_vec(
                    #[rustc_box]
                    ::alloc::boxed::Box::new([SUBSTRATE_SS58_PREFIX]),
                );
                v.extend(self.0);
                let r = ss58hash(&v);
                v.extend(&r[0..2]);
                use base58::ToBase58;
                v.to_base58()
            }
            fn from_ss58check(s: &str) -> Result<Self, FromSs58Error> {
                const CHECKSUM_LEN: usize = 2;
                let body_len = 32;
                use base58::FromBase58;
                let data = s.from_base58().map_err(|_| FromSs58Error::BadBase58)?;
                if data.len() < 2 {
                    return Err(FromSs58Error::BadLength);
                }
                let prefix_len = match data[0] {
                    0..=63 => 1,
                    64..=127 => 2,
                    _ => return Err(FromSs58Error::InvalidPrefix),
                };
                if data.len() != prefix_len + body_len + CHECKSUM_LEN {
                    return Err(FromSs58Error::BadLength);
                }
                let hash = ss58hash(&data[0..body_len + prefix_len]);
                let checksum = &hash[0..CHECKSUM_LEN];
                if data[body_len + prefix_len..body_len + prefix_len + CHECKSUM_LEN]
                    != *checksum
                {
                    return Err(FromSs58Error::InvalidChecksum);
                }
                let result = data[prefix_len..body_len + prefix_len]
                    .try_into()
                    .map_err(|_| FromSs58Error::BadLength)?;
                Ok(AccountId32(result))
            }
        }
        /// An error obtained from trying to interpret an SS58 encoded string into an AccountId32
        #[allow(missing_docs)]
        pub enum FromSs58Error {
            #[error("Base 58 requirement is violated")]
            BadBase58,
            #[error("Length is bad")]
            BadLength,
            #[error("Invalid checksum")]
            InvalidChecksum,
            #[error("Invalid SS58 prefix byte.")]
            InvalidPrefix,
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for FromSs58Error {}
        #[allow(unused_qualifications)]
        impl ::core::fmt::Display for FromSs58Error {
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    FromSs58Error::BadBase58 {} => {
                        __formatter.write_str("Base 58 requirement is violated")
                    }
                    FromSs58Error::BadLength {} => __formatter.write_str("Length is bad"),
                    FromSs58Error::InvalidChecksum {} => {
                        __formatter.write_str("Invalid checksum")
                    }
                    FromSs58Error::InvalidPrefix {} => {
                        __formatter.write_str("Invalid SS58 prefix byte.")
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::clone::Clone for FromSs58Error {
            #[inline]
            fn clone(&self) -> FromSs58Error {
                *self
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::marker::Copy for FromSs58Error {}
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::cmp::Eq for FromSs58Error {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::marker::StructuralPartialEq for FromSs58Error {}
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::cmp::PartialEq for FromSs58Error {
            #[inline]
            fn eq(&self, other: &FromSs58Error) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::fmt::Debug for FromSs58Error {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        FromSs58Error::BadBase58 => "BadBase58",
                        FromSs58Error::BadLength => "BadLength",
                        FromSs58Error::InvalidChecksum => "InvalidChecksum",
                        FromSs58Error::InvalidPrefix => "InvalidPrefix",
                    },
                )
            }
        }
        fn ss58hash(data: &[u8]) -> Vec<u8> {
            use blake2::{Blake2b512, Digest};
            const PREFIX: &[u8] = b"SS58PRE";
            let mut ctx = Blake2b512::new();
            ctx.update(PREFIX);
            ctx.update(data);
            ctx.finalize().to_vec()
        }
        impl Serialize for AccountId32 {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                serializer.serialize_str(&self.to_ss58check())
            }
        }
        impl<'de> Deserialize<'de> for AccountId32 {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                AccountId32::from_ss58check(&String::deserialize(deserializer)?)
                    .map_err(|e| serde::de::Error::custom({
                        let res = ::alloc::fmt::format(format_args!("{0:?}", e));
                        res
                    }))
            }
        }
        impl std::fmt::Display for AccountId32 {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                f.write_fmt(format_args!("{0}", self.to_ss58check()))
            }
        }
        impl std::str::FromStr for AccountId32 {
            type Err = FromSs58Error;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                AccountId32::from_ss58check(s)
            }
        }
    }
    pub mod bits {
        //! Generic `scale_bits` over `bitvec`-like `BitOrder` and `BitFormat` types.
        use codec::{Compact, Input};
        use scale_bits::{
            scale::format::{Format, OrderFormat, StoreFormat},
            Bits,
        };
        use scale_decode::IntoVisitor;
        use std::marker::PhantomData;
        /// Associates `bitvec::store::BitStore` trait with corresponding, type-erased `scale_bits::StoreFormat` enum.
        ///
        /// Used to decode bit sequences by providing `scale_bits::StoreFormat` using
        /// `bitvec`-like type type parameters.
        pub trait BitStore {
            /// Corresponding `scale_bits::StoreFormat` value.
            const FORMAT: StoreFormat;
            /// Number of bits that the backing store types holds.
            const BITS: u32;
        }
        impl BitStore for u8 {
            const FORMAT: StoreFormat = StoreFormat::U8;
            const BITS: u32 = <u8>::BITS;
        }
        impl BitStore for u16 {
            const FORMAT: StoreFormat = StoreFormat::U16;
            const BITS: u32 = <u16>::BITS;
        }
        impl BitStore for u32 {
            const FORMAT: StoreFormat = StoreFormat::U32;
            const BITS: u32 = <u32>::BITS;
        }
        impl BitStore for u64 {
            const FORMAT: StoreFormat = StoreFormat::U64;
            const BITS: u32 = <u64>::BITS;
        }
        /// Associates `bitvec::order::BitOrder` trait with corresponding, type-erased `scale_bits::OrderFormat` enum.
        ///
        /// Used to decode bit sequences in runtime by providing `scale_bits::OrderFormat` using
        /// `bitvec`-like type type parameters.
        pub trait BitOrder {
            /// Corresponding `scale_bits::OrderFormat` value.
            const FORMAT: OrderFormat;
        }
        ///Type-level value that corresponds to `scale_bits::OrderFormat::Lsb0` at run-time
        /// and `bitvec::order::BitOrder::Lsb0` at the type level.
        pub enum Lsb0 {}
        #[automatically_derived]
        impl ::core::clone::Clone for Lsb0 {
            #[inline]
            fn clone(&self) -> Lsb0 {
                match *self {}
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Lsb0 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {}
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Lsb0 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Lsb0 {
            #[inline]
            fn eq(&self, other: &Lsb0) -> bool {
                match *self {}
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Lsb0 {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl BitOrder for Lsb0 {
            const FORMAT: OrderFormat = OrderFormat::Lsb0;
        }
        ///Type-level value that corresponds to `scale_bits::OrderFormat::Msb0` at run-time
        /// and `bitvec::order::BitOrder::Msb0` at the type level.
        pub enum Msb0 {}
        #[automatically_derived]
        impl ::core::clone::Clone for Msb0 {
            #[inline]
            fn clone(&self) -> Msb0 {
                match *self {}
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Msb0 {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {}
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Msb0 {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Msb0 {
            #[inline]
            fn eq(&self, other: &Msb0) -> bool {
                match *self {}
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Msb0 {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        impl BitOrder for Msb0 {
            const FORMAT: OrderFormat = OrderFormat::Msb0;
        }
        /// Constructs a run-time format parameters based on the corresponding type-level parameters.
        fn bit_format<Store: BitStore, Order: BitOrder>() -> Format {
            Format {
                order: Order::FORMAT,
                store: Store::FORMAT,
            }
        }
        /// `scale_bits::Bits` generic over the bit store (`u8`/`u16`/`u32`/`u64`) and bit order (LSB, MSB)
        /// used for SCALE encoding/decoding. Uses `scale_bits::Bits`-default `u8` and LSB format underneath.
        pub struct DecodedBits<Store, Order> {
            bits: Bits,
            _marker: PhantomData<(Store, Order)>,
        }
        #[automatically_derived]
        impl<Store: ::core::fmt::Debug, Order: ::core::fmt::Debug> ::core::fmt::Debug
        for DecodedBits<Store, Order> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "DecodedBits",
                    "bits",
                    &self.bits,
                    "_marker",
                    &&self._marker,
                )
            }
        }
        #[automatically_derived]
        impl<
            Store: ::core::clone::Clone,
            Order: ::core::clone::Clone,
        > ::core::clone::Clone for DecodedBits<Store, Order> {
            #[inline]
            fn clone(&self) -> DecodedBits<Store, Order> {
                DecodedBits {
                    bits: ::core::clone::Clone::clone(&self.bits),
                    _marker: ::core::clone::Clone::clone(&self._marker),
                }
            }
        }
        #[automatically_derived]
        impl<Store, Order> ::core::marker::StructuralPartialEq
        for DecodedBits<Store, Order> {}
        #[automatically_derived]
        impl<
            Store: ::core::cmp::PartialEq,
            Order: ::core::cmp::PartialEq,
        > ::core::cmp::PartialEq for DecodedBits<Store, Order> {
            #[inline]
            fn eq(&self, other: &DecodedBits<Store, Order>) -> bool {
                self.bits == other.bits && self._marker == other._marker
            }
        }
        #[automatically_derived]
        impl<Store: ::core::cmp::Eq, Order: ::core::cmp::Eq> ::core::cmp::Eq
        for DecodedBits<Store, Order> {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Bits>;
                let _: ::core::cmp::AssertParamIsEq<PhantomData<(Store, Order)>>;
            }
        }
        impl<Store, Order> DecodedBits<Store, Order> {
            /// Extracts the underlying `scale_bits::Bits` value.
            pub fn into_bits(self) -> Bits {
                self.bits
            }
            /// References the underlying `scale_bits::Bits` value.
            pub fn as_bits(&self) -> &Bits {
                &self.bits
            }
        }
        impl<Store, Order> core::iter::FromIterator<bool> for DecodedBits<Store, Order> {
            fn from_iter<T: IntoIterator<Item = bool>>(iter: T) -> Self {
                DecodedBits {
                    bits: Bits::from_iter(iter),
                    _marker: PhantomData,
                }
            }
        }
        impl<Store: BitStore, Order: BitOrder> codec::Decode
        for DecodedBits<Store, Order> {
            fn decode<I: Input>(input: &mut I) -> Result<Self, codec::Error> {
                /// Equivalent of `BitSlice::MAX_BITS` on 32bit machine.
                const ARCH32BIT_BITSLICE_MAX_BITS: u32 = 0x1fff_ffff;
                let Compact(bits) = <Compact<u32>>::decode(input)?;
                if bits > ARCH32BIT_BITSLICE_MAX_BITS {
                    return Err("Attempt to decode a BitVec with too many bits".into());
                }
                let elements = (bits / Store::BITS) + u32::from(bits % Store::BITS != 0);
                let bytes_in_elem = Store::BITS.saturating_div(u8::BITS);
                let bytes_needed = (elements * bytes_in_elem) as usize;
                let mut storage = codec::Encode::encode(&Compact(bits));
                let prefix_len = storage.len();
                storage.reserve_exact(bytes_needed);
                storage.extend(::alloc::vec::from_elem(0, bytes_needed));
                input.read(&mut storage[prefix_len..])?;
                let decoder = scale_bits::decode_using_format_from(
                    &storage,
                    bit_format::<Store, Order>(),
                )?;
                let bits = decoder.collect::<Result<Vec<_>, _>>()?;
                let bits = Bits::from_iter(bits);
                Ok(DecodedBits {
                    bits,
                    _marker: PhantomData,
                })
            }
        }
        impl<Store: BitStore, Order: BitOrder> codec::Encode
        for DecodedBits<Store, Order> {
            fn size_hint(&self) -> usize {
                self.bits.size_hint()
            }
            fn encoded_size(&self) -> usize {
                self.bits.encoded_size()
            }
            fn encode(&self) -> Vec<u8> {
                scale_bits::encode_using_format(
                    self.bits.iter(),
                    bit_format::<Store, Order>(),
                )
            }
        }
        #[doc(hidden)]
        pub struct DecodedBitsVisitor<S, O>(std::marker::PhantomData<(S, O)>);
        impl<Store, Order> scale_decode::Visitor for DecodedBitsVisitor<Store, Order> {
            type Value<'scale, 'info> = DecodedBits<Store, Order>;
            type Error = scale_decode::Error;
            fn unchecked_decode_as_type<'scale, 'info>(
                self,
                input: &mut &'scale [u8],
                type_id: scale_decode::visitor::TypeId,
                types: &'info scale_info::PortableRegistry,
            ) -> scale_decode::visitor::DecodeAsTypeResult<
                Self,
                Result<Self::Value<'scale, 'info>, Self::Error>,
            > {
                let res = scale_decode::visitor::decode_with_visitor(
                        input,
                        type_id.0,
                        types,
                        Bits::into_visitor(),
                    )
                    .map(|bits| DecodedBits {
                        bits,
                        _marker: PhantomData,
                    });
                scale_decode::visitor::DecodeAsTypeResult::Decoded(res)
            }
        }
        impl<Store, Order> scale_decode::IntoVisitor for DecodedBits<Store, Order> {
            type Visitor = DecodedBitsVisitor<Store, Order>;
            fn into_visitor() -> Self::Visitor {
                DecodedBitsVisitor(PhantomData)
            }
        }
        impl<Store, Order> scale_encode::EncodeAsType for DecodedBits<Store, Order> {
            fn encode_as_type_to(
                &self,
                type_id: u32,
                types: &scale_info::PortableRegistry,
                out: &mut Vec<u8>,
            ) -> Result<(), scale_encode::Error> {
                self.bits.encode_as_type_to(type_id, types, out)
            }
        }
    }
    mod era {
        use scale_decode::DecodeAsType;
        use scale_encode::EncodeAsType;
        /// An era to describe the longevity of a transaction.
        pub enum Era {
            /// The transaction is valid forever. The genesis hash must be present in the signed content.
            #[default]
            Immortal,
            /// The transaction will expire. Use [`Era::mortal`] to construct this with correct values.
            ///
            /// When used on `FRAME`-based runtimes, `period` cannot exceed `BlockHashCount` parameter
            /// of `system` module.
            Mortal {
                /// The number of blocks that the tx will be valid for after the checkpoint block
                /// hash found in the signer payload.
                period: u64,
                /// The phase in the period that this transaction's lifetime begins (and, importantly,
                /// implies which block hash is included in the signature material). If the `period` is
                /// greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that
                /// `period` is.
                phase: u64,
            },
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Era {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Era {
            #[inline]
            fn eq(&self, other: &Era) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            Era::Mortal { period: __self_0, phase: __self_1 },
                            Era::Mortal { period: __arg1_0, phase: __arg1_1 },
                        ) => *__self_0 == *__arg1_0 && *__self_1 == *__arg1_1,
                        _ => true,
                    }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for Era {
            #[inline]
            fn default() -> Era {
                Self::Immortal
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Era {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u64>;
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Era {
            #[inline]
            fn clone(&self) -> Era {
                let _: ::core::clone::AssertParamIsClone<u64>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Era {}
        #[automatically_derived]
        impl ::core::fmt::Debug for Era {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Era::Immortal => ::core::fmt::Formatter::write_str(f, "Immortal"),
                    Era::Mortal { period: __self_0, phase: __self_1 } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "Mortal",
                            "period",
                            __self_0,
                            "phase",
                            &__self_1,
                        )
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Era {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        Era::Immortal => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "Era",
                                0u32,
                                "Immortal",
                            )
                        }
                        Era::Mortal { ref period, ref phase } => {
                            let mut __serde_state = _serde::Serializer::serialize_struct_variant(
                                __serializer,
                                "Era",
                                1u32,
                                "Mortal",
                                0 + 1 + 1,
                            )?;
                            _serde::ser::SerializeStructVariant::serialize_field(
                                &mut __serde_state,
                                "period",
                                period,
                            )?;
                            _serde::ser::SerializeStructVariant::serialize_field(
                                &mut __serde_state,
                                "phase",
                                phase,
                            )?;
                            _serde::ser::SerializeStructVariant::end(__serde_state)
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Era {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Immortal" => _serde::__private::Ok(__Field::__field0),
                                "Mortal" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Immortal" => _serde::__private::Ok(__Field::__field0),
                                b"Mortal" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Era>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Era;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum Era",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Era::Immortal)
                                }
                                (__Field::__field1, __variant) => {
                                    #[allow(non_camel_case_types)]
                                    #[doc(hidden)]
                                    enum __Field {
                                        __field0,
                                        __field1,
                                        __ignore,
                                    }
                                    #[doc(hidden)]
                                    struct __FieldVisitor;
                                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                        type Value = __Field;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "field identifier",
                                            )
                                        }
                                        fn visit_u64<__E>(
                                            self,
                                            __value: u64,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                0u64 => _serde::__private::Ok(__Field::__field0),
                                                1u64 => _serde::__private::Ok(__Field::__field1),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_str<__E>(
                                            self,
                                            __value: &str,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                "period" => _serde::__private::Ok(__Field::__field0),
                                                "phase" => _serde::__private::Ok(__Field::__field1),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_bytes<__E>(
                                            self,
                                            __value: &[u8],
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                b"period" => _serde::__private::Ok(__Field::__field0),
                                                b"phase" => _serde::__private::Ok(__Field::__field1),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                    }
                                    impl<'de> _serde::Deserialize<'de> for __Field {
                                        #[inline]
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::Deserializer::deserialize_identifier(
                                                __deserializer,
                                                __FieldVisitor,
                                            )
                                        }
                                    }
                                    #[doc(hidden)]
                                    struct __Visitor<'de> {
                                        marker: _serde::__private::PhantomData<Era>,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                        type Value = Era;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "struct variant Era::Mortal",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            mut __seq: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                                u64,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            0usize,
                                                            &"struct variant Era::Mortal with 2 elements",
                                                        ),
                                                    );
                                                }
                                            };
                                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                                u64,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            1usize,
                                                            &"struct variant Era::Mortal with 2 elements",
                                                        ),
                                                    );
                                                }
                                            };
                                            _serde::__private::Ok(Era::Mortal {
                                                period: __field0,
                                                phase: __field1,
                                            })
                                        }
                                        #[inline]
                                        fn visit_map<__A>(
                                            self,
                                            mut __map: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::MapAccess<'de>,
                                        {
                                            let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                                            let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                                            while let _serde::__private::Some(__key)
                                                = _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {
                                                match __key {
                                                    __Field::__field0 => {
                                                        if _serde::__private::Option::is_some(&__field0) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field("period"),
                                                            );
                                                        }
                                                        __field0 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                                        );
                                                    }
                                                    __Field::__field1 => {
                                                        if _serde::__private::Option::is_some(&__field1) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field("phase"),
                                                            );
                                                        }
                                                        __field1 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                                        );
                                                    }
                                                    _ => {
                                                        let _ = _serde::de::MapAccess::next_value::<
                                                            _serde::de::IgnoredAny,
                                                        >(&mut __map)?;
                                                    }
                                                }
                                            }
                                            let __field0 = match __field0 {
                                                _serde::__private::Some(__field0) => __field0,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("period")?
                                                }
                                            };
                                            let __field1 = match __field1 {
                                                _serde::__private::Some(__field1) => __field1,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("phase")?
                                                }
                                            };
                                            _serde::__private::Ok(Era::Mortal {
                                                period: __field0,
                                                phase: __field1,
                                            })
                                        }
                                    }
                                    #[doc(hidden)]
                                    const FIELDS: &'static [&'static str] = &[
                                        "period",
                                        "phase",
                                    ];
                                    _serde::de::VariantAccess::struct_variant(
                                        __variant,
                                        FIELDS,
                                        __Visitor {
                                            marker: _serde::__private::PhantomData::<Era>,
                                            lifetime: _serde::__private::PhantomData,
                                        },
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["Immortal", "Mortal"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "Era",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Era>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        const _: () = {
            pub struct Visitor(::core::marker::PhantomData<()>);
            use ::scale_decode::vec;
            use ::scale_decode::ToString;
            impl ::scale_decode::IntoVisitor for Era {
                type Visitor = Visitor;
                fn into_visitor() -> Self::Visitor {
                    Visitor(::core::marker::PhantomData)
                }
            }
            impl ::scale_decode::Visitor for Visitor {
                type Error = ::scale_decode::Error;
                type Value<'scale, 'info> = Era;
                fn visit_variant<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Variant<'scale, 'info>,
                    type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.name() == "Immortal" {
                        return Ok(Era::Immortal);
                    }
                    if value.name() == "Mortal" {
                        let fields = value.fields();
                        return if fields.has_unnamed_fields() {
                            if fields.remaining() != 2usize {
                                return Err(
                                    ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                        actual_len: fields.remaining(),
                                        expected_len: 2usize,
                                    }),
                                );
                            }
                            let vals = fields;
                            Ok(Era::Mortal {
                                period: {
                                    let val = vals
                                        .next()
                                        .expect(
                                            "field count should have been checked already on tuple type; please file a bug report",
                                        )?;
                                    val.decode_as_type().map_err(|e| e.at_field("period"))?
                                },
                                phase: {
                                    let val = vals
                                        .next()
                                        .expect(
                                            "field count should have been checked already on tuple type; please file a bug report",
                                        )?;
                                    val.decode_as_type().map_err(|e| e.at_field("phase"))?
                                },
                            })
                        } else {
                            let vals: ::scale_decode::BTreeMap<Option<&str>, _> = fields
                                .map(|res| res.map(|item| (item.name(), item)))
                                .collect::<Result<_, _>>()?;
                            Ok(Era::Mortal {
                                period: {
                                    let val = *vals
                                        .get(&Some("period"))
                                        .ok_or_else(|| ::scale_decode::Error::new(::scale_decode::error::ErrorKind::CannotFindField {
                                            name: "period".to_string(),
                                        }))?;
                                    val.decode_as_type().map_err(|e| e.at_field("period"))?
                                },
                                phase: {
                                    let val = *vals
                                        .get(&Some("phase"))
                                        .ok_or_else(|| ::scale_decode::Error::new(::scale_decode::error::ErrorKind::CannotFindField {
                                            name: "phase".to_string(),
                                        }))?;
                                    val.decode_as_type().map_err(|e| e.at_field("phase"))?
                                },
                            })
                        };
                    }
                    Err(
                        ::scale_decode::Error::new(::scale_decode::error::ErrorKind::CannotFindVariant {
                            got: value.name().to_string(),
                            expected: <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new(["Immortal", "Mortal"]),
                            ),
                        }),
                    )
                }
                fn visit_composite<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Composite<'scale, 'info>,
                    _type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 1 {
                        return self
                            .visit_unexpected(
                                ::scale_decode::visitor::Unexpected::Composite,
                            );
                    }
                    value.decode_item(self).unwrap()
                }
                fn visit_tuple<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Tuple<'scale, 'info>,
                    _type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 1 {
                        return self
                            .visit_unexpected(
                                ::scale_decode::visitor::Unexpected::Tuple,
                            );
                    }
                    value.decode_item(self).unwrap()
                }
            }
        };
        impl ::scale_encode::EncodeAsType for Era {
            #[allow(unused_variables)]
            fn encode_as_type_to(
                &self,
                __encode_as_type_type_id: u32,
                __encode_as_type_types: &::scale_encode::PortableRegistry,
                __encode_as_type_out: &mut ::scale_encode::Vec<u8>,
            ) -> Result<(), ::scale_encode::Error> {
                match self {
                    Self::Immortal => {
                        ::scale_encode::Variant {
                            name: "Immortal",
                            fields: ::scale_encode::Composite(
                                ([]
                                    as [(
                                        Option<&'static str>,
                                        &dyn ::scale_encode::EncodeAsType,
                                    ); 0])
                                    .into_iter(),
                            ),
                        }
                            .encode_as_type_to(
                                __encode_as_type_type_id,
                                __encode_as_type_types,
                                __encode_as_type_out,
                            )
                    }
                    Self::Mortal { period, phase } => {
                        ::scale_encode::Variant {
                            name: "Mortal",
                            fields: ::scale_encode::Composite(
                                [
                                    (
                                        Some("period"),
                                        period as &dyn ::scale_encode::EncodeAsType,
                                    ),
                                    (Some("phase"), phase as &dyn ::scale_encode::EncodeAsType),
                                ]
                                    .into_iter(),
                            ),
                        }
                            .encode_as_type_to(
                                __encode_as_type_type_id,
                                __encode_as_type_types,
                                __encode_as_type_out,
                            )
                    }
                    _ => {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            impl ::scale_info::TypeInfo for Era {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder()
                        .path(
                            ::scale_info::Path::new_with_replace(
                                "Era",
                                "subxt::utils::era",
                                &[],
                            ),
                        )
                        .type_params(::alloc::vec::Vec::new())
                        .docs(&["An era to describe the longevity of a transaction."])
                        .variant(
                            ::scale_info::build::Variants::new()
                                .variant(
                                    "Immortal",
                                    |v| {
                                        v
                                            .index(0usize as ::core::primitive::u8)
                                            .docs(
                                                &[
                                                    "The transaction is valid forever. The genesis hash must be present in the signed content.",
                                                ],
                                            )
                                    },
                                )
                                .variant(
                                    "Mortal",
                                    |v| {
                                        v
                                            .index(1usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::named()
                                                    .field(|f| {
                                                        f
                                                            .ty::<u64>()
                                                            .name("period")
                                                            .type_name("u64")
                                                            .docs(
                                                                &[
                                                                    "The number of blocks that the tx will be valid for after the checkpoint block",
                                                                    "hash found in the signer payload.",
                                                                ],
                                                            )
                                                    })
                                                    .field(|f| {
                                                        f
                                                            .ty::<u64>()
                                                            .name("phase")
                                                            .type_name("u64")
                                                            .docs(
                                                                &[
                                                                    "The phase in the period that this transaction's lifetime begins (and, importantly,",
                                                                    "implies which block hash is included in the signature material). If the `period` is",
                                                                    "greater than 1 << 12, then it will be a factor of the times greater than 1<<12 that",
                                                                    "`period` is.",
                                                                ],
                                                            )
                                                    }),
                                            )
                                            .docs(
                                                &[
                                                    "The transaction will expire. Use [`Era::mortal`] to construct this with correct values.",
                                                    "",
                                                    "When used on `FRAME`-based runtimes, `period` cannot exceed `BlockHashCount` parameter",
                                                    "of `system` module.",
                                                ],
                                            )
                                    },
                                ),
                        )
                }
            }
        };
        impl Era {
            /// Create a new era based on a period (which should be a power of two between 4 and 65536
            /// inclusive) and a block number on which it should start (or, for long periods, be shortly
            /// after the start).
            ///
            /// If using `Era` in the context of `FRAME` runtime, make sure that `period`
            /// does not exceed `BlockHashCount` parameter passed to `system` module, since that
            /// prunes old blocks and renders transactions immediately invalid.
            pub fn mortal(period: u64, current: u64) -> Self {
                let period = period
                    .checked_next_power_of_two()
                    .unwrap_or(1 << 16)
                    .clamp(4, 1 << 16);
                let phase = current % period;
                let quantize_factor = (period >> 12).max(1);
                let quantized_phase = phase / quantize_factor * quantize_factor;
                Self::Mortal {
                    period,
                    phase: quantized_phase,
                }
            }
        }
        impl codec::Encode for Era {
            fn encode_to<T: codec::Output + ?Sized>(&self, output: &mut T) {
                match self {
                    Self::Immortal => output.push_byte(0),
                    Self::Mortal { period, phase } => {
                        let quantize_factor = (*period >> 12).max(1);
                        let encoded = (period.trailing_zeros() - 1).clamp(1, 15) as u16
                            | ((phase / quantize_factor) << 4) as u16;
                        encoded.encode_to(output);
                    }
                }
            }
        }
        impl codec::Decode for Era {
            fn decode<I: codec::Input>(input: &mut I) -> Result<Self, codec::Error> {
                let first = input.read_byte()?;
                if first == 0 {
                    Ok(Self::Immortal)
                } else {
                    let encoded = first as u64 + ((input.read_byte()? as u64) << 8);
                    let period = 2 << (encoded % (1 << 4));
                    let quantize_factor = (period >> 12).max(1);
                    let phase = (encoded >> 4) * quantize_factor;
                    if period >= 4 && phase < period {
                        Ok(Self::Mortal { period, phase })
                    } else {
                        Err("Invalid period and phase".into())
                    }
                }
            }
        }
    }
    mod multi_address {
        //! The "default" Substrate/Polkadot Address type. This is used in codegen, as well as signing related bits.
        //! This doesn't contain much functionality itself, but is easy to convert to/from an `sp_runtime::MultiAddress`
        //! for instance, to gain functionality without forcing a dependency on Substrate crates here.
        use codec::{Decode, Encode};
        /// A multi-format address wrapper for on-chain accounts. This is a simplified version of Substrate's
        /// `sp_runtime::MultiAddress`. To obtain more functionality, convert this into that type (this conversion
        /// functionality is provided via `From` impls if the `substrate-compat` feature is enabled).
        pub enum MultiAddress<AccountId, AccountIndex> {
            /// It's an account ID (pubkey).
            Id(AccountId),
            /// It's an account index.
            Index(#[codec(compact)] AccountIndex),
            /// It's some arbitrary raw bytes.
            Raw(Vec<u8>),
            /// It's a 32 byte representation.
            Address32([u8; 32]),
            /// Its a 20 byte representation.
            Address20([u8; 20]),
        }
        #[automatically_derived]
        impl<
            AccountId: ::core::clone::Clone,
            AccountIndex: ::core::clone::Clone,
        > ::core::clone::Clone for MultiAddress<AccountId, AccountIndex> {
            #[inline]
            fn clone(&self) -> MultiAddress<AccountId, AccountIndex> {
                match self {
                    MultiAddress::Id(__self_0) => {
                        MultiAddress::Id(::core::clone::Clone::clone(__self_0))
                    }
                    MultiAddress::Index(__self_0) => {
                        MultiAddress::Index(::core::clone::Clone::clone(__self_0))
                    }
                    MultiAddress::Raw(__self_0) => {
                        MultiAddress::Raw(::core::clone::Clone::clone(__self_0))
                    }
                    MultiAddress::Address32(__self_0) => {
                        MultiAddress::Address32(::core::clone::Clone::clone(__self_0))
                    }
                    MultiAddress::Address20(__self_0) => {
                        MultiAddress::Address20(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl<AccountId: ::core::cmp::Eq, AccountIndex: ::core::cmp::Eq> ::core::cmp::Eq
        for MultiAddress<AccountId, AccountIndex> {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<AccountIndex>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<[u8; 32]>;
                let _: ::core::cmp::AssertParamIsEq<[u8; 20]>;
            }
        }
        #[automatically_derived]
        impl<AccountId, AccountIndex> ::core::marker::StructuralPartialEq
        for MultiAddress<AccountId, AccountIndex> {}
        #[automatically_derived]
        impl<
            AccountId: ::core::cmp::PartialEq,
            AccountIndex: ::core::cmp::PartialEq,
        > ::core::cmp::PartialEq for MultiAddress<AccountId, AccountIndex> {
            #[inline]
            fn eq(&self, other: &MultiAddress<AccountId, AccountIndex>) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (MultiAddress::Id(__self_0), MultiAddress::Id(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            MultiAddress::Index(__self_0),
                            MultiAddress::Index(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (MultiAddress::Raw(__self_0), MultiAddress::Raw(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                        (
                            MultiAddress::Address32(__self_0),
                            MultiAddress::Address32(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            MultiAddress::Address20(__self_0),
                            MultiAddress::Address20(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl<
            AccountId: ::core::cmp::Ord,
            AccountIndex: ::core::cmp::Ord,
        > ::core::cmp::Ord for MultiAddress<AccountId, AccountIndex> {
            #[inline]
            fn cmp(
                &self,
                other: &MultiAddress<AccountId, AccountIndex>,
            ) -> ::core::cmp::Ordering {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                    ::core::cmp::Ordering::Equal => {
                        match (self, other) {
                            (MultiAddress::Id(__self_0), MultiAddress::Id(__arg1_0)) => {
                                ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                            }
                            (
                                MultiAddress::Index(__self_0),
                                MultiAddress::Index(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                MultiAddress::Raw(__self_0),
                                MultiAddress::Raw(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                MultiAddress::Address32(__self_0),
                                MultiAddress::Address32(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                MultiAddress::Address20(__self_0),
                                MultiAddress::Address20(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl<
            AccountId: ::core::cmp::PartialOrd,
            AccountIndex: ::core::cmp::PartialOrd,
        > ::core::cmp::PartialOrd for MultiAddress<AccountId, AccountIndex> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &MultiAddress<AccountId, AccountIndex>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                match (self, other) {
                    (MultiAddress::Id(__self_0), MultiAddress::Id(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (MultiAddress::Index(__self_0), MultiAddress::Index(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (MultiAddress::Raw(__self_0), MultiAddress::Raw(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (
                        MultiAddress::Address32(__self_0),
                        MultiAddress::Address32(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        MultiAddress::Address20(__self_0),
                        MultiAddress::Address20(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    _ => ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag),
                }
            }
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<AccountId, AccountIndex> ::codec::Encode
            for MultiAddress<AccountId, AccountIndex>
            where
                AccountId: ::codec::Encode,
                AccountId: ::codec::Encode,
                AccountIndex: ::codec::HasCompact,
            {
                fn size_hint(&self) -> usize {
                    1_usize
                        + match *self {
                            MultiAddress::Id(ref aa) => {
                                0_usize.saturating_add(::codec::Encode::size_hint(aa))
                            }
                            MultiAddress::Index(ref aa) => {
                                0_usize
                                    .saturating_add(
                                        ::codec::Encode::size_hint(
                                            &<<AccountIndex as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                                '_,
                                                AccountIndex,
                                            >>::RefType::from(aa),
                                        ),
                                    )
                            }
                            MultiAddress::Raw(ref aa) => {
                                0_usize.saturating_add(::codec::Encode::size_hint(aa))
                            }
                            MultiAddress::Address32(ref aa) => {
                                0_usize.saturating_add(::codec::Encode::size_hint(aa))
                            }
                            MultiAddress::Address20(ref aa) => {
                                0_usize.saturating_add(::codec::Encode::size_hint(aa))
                            }
                            _ => 0_usize,
                        }
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    match *self {
                        MultiAddress::Id(ref aa) => {
                            __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                        }
                        MultiAddress::Index(ref aa) => {
                            __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                            {
                                ::codec::Encode::encode_to(
                                    &<<AccountIndex as ::codec::HasCompact>::Type as ::codec::EncodeAsRef<
                                        '_,
                                        AccountIndex,
                                    >>::RefType::from(aa),
                                    __codec_dest_edqy,
                                );
                            }
                        }
                        MultiAddress::Raw(ref aa) => {
                            __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                        }
                        MultiAddress::Address32(ref aa) => {
                            __codec_dest_edqy.push_byte(3usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                        }
                        MultiAddress::Address20(ref aa) => {
                            __codec_dest_edqy.push_byte(4usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                        }
                        _ => {}
                    }
                }
            }
            #[automatically_derived]
            impl<AccountId, AccountIndex> ::codec::EncodeLike
            for MultiAddress<AccountId, AccountIndex>
            where
                AccountId: ::codec::Encode,
                AccountId: ::codec::Encode,
                AccountIndex: ::codec::HasCompact,
            {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<AccountId, AccountIndex> ::codec::Decode
            for MultiAddress<AccountId, AccountIndex>
            where
                AccountId: ::codec::Decode,
                AccountId: ::codec::Decode,
                AccountIndex: ::codec::HasCompact,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy
                        .read_byte()
                        .map_err(|e| {
                            e
                                .chain(
                                    "Could not decode `MultiAddress`, failed to read variant byte",
                                )
                        })?
                    {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 0usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    MultiAddress::<
                                        AccountId,
                                        AccountIndex,
                                    >::Id({
                                        let __codec_res_edqy = <AccountId as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `MultiAddress::Id.0`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    }),
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 1usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    MultiAddress::<
                                        AccountId,
                                        AccountIndex,
                                    >::Index({
                                        let __codec_res_edqy = <<AccountIndex as ::codec::HasCompact>::Type as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `MultiAddress::Index.0`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy.into()
                                            }
                                        }
                                    }),
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 2usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    MultiAddress::<
                                        AccountId,
                                        AccountIndex,
                                    >::Raw({
                                        let __codec_res_edqy = <Vec<
                                            u8,
                                        > as ::codec::Decode>::decode(__codec_input_edqy);
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `MultiAddress::Raw.0`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    }),
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 3usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    MultiAddress::<
                                        AccountId,
                                        AccountIndex,
                                    >::Address32({
                                        let __codec_res_edqy = <[u8; 32] as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `MultiAddress::Address32.0`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    }),
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 4usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    MultiAddress::<
                                        AccountId,
                                        AccountIndex,
                                    >::Address20({
                                        let __codec_res_edqy = <[u8; 20] as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `MultiAddress::Address20.0`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    }),
                                )
                            })();
                        }
                        _ => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Err(
                                    <_ as ::core::convert::Into<
                                        _,
                                    >>::into(
                                        "Could not decode `MultiAddress`, variant doesn't exist",
                                    ),
                                )
                            })();
                        }
                    }
                }
            }
        };
        #[automatically_derived]
        impl<
            AccountId: ::core::fmt::Debug,
            AccountIndex: ::core::fmt::Debug,
        > ::core::fmt::Debug for MultiAddress<AccountId, AccountIndex> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    MultiAddress::Id(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Id",
                            &__self_0,
                        )
                    }
                    MultiAddress::Index(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Index",
                            &__self_0,
                        )
                    }
                    MultiAddress::Raw(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Raw",
                            &__self_0,
                        )
                    }
                    MultiAddress::Address32(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Address32",
                            &__self_0,
                        )
                    }
                    MultiAddress::Address20(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Address20",
                            &__self_0,
                        )
                    }
                }
            }
        }
        impl<AccountId, AccountIndex> ::scale_encode::EncodeAsType
        for MultiAddress<AccountId, AccountIndex>
        where
            AccountId: ::scale_encode::EncodeAsType,
            AccountIndex: ::scale_encode::EncodeAsType,
        {
            #[allow(unused_variables)]
            fn encode_as_type_to(
                &self,
                __encode_as_type_type_id: u32,
                __encode_as_type_types: &::scale_encode::PortableRegistry,
                __encode_as_type_out: &mut ::scale_encode::Vec<u8>,
            ) -> Result<(), ::scale_encode::Error> {
                match self {
                    Self::Id(_0) => {
                        ::scale_encode::Variant {
                            name: "Id",
                            fields: ::scale_encode::Composite(
                                [
                                    (
                                        None as Option<&'static str>,
                                        _0 as &dyn ::scale_encode::EncodeAsType,
                                    ),
                                ]
                                    .into_iter(),
                            ),
                        }
                            .encode_as_type_to(
                                __encode_as_type_type_id,
                                __encode_as_type_types,
                                __encode_as_type_out,
                            )
                    }
                    Self::Index(_0) => {
                        ::scale_encode::Variant {
                            name: "Index",
                            fields: ::scale_encode::Composite(
                                [
                                    (
                                        None as Option<&'static str>,
                                        _0 as &dyn ::scale_encode::EncodeAsType,
                                    ),
                                ]
                                    .into_iter(),
                            ),
                        }
                            .encode_as_type_to(
                                __encode_as_type_type_id,
                                __encode_as_type_types,
                                __encode_as_type_out,
                            )
                    }
                    Self::Raw(_0) => {
                        ::scale_encode::Variant {
                            name: "Raw",
                            fields: ::scale_encode::Composite(
                                [
                                    (
                                        None as Option<&'static str>,
                                        _0 as &dyn ::scale_encode::EncodeAsType,
                                    ),
                                ]
                                    .into_iter(),
                            ),
                        }
                            .encode_as_type_to(
                                __encode_as_type_type_id,
                                __encode_as_type_types,
                                __encode_as_type_out,
                            )
                    }
                    Self::Address32(_0) => {
                        ::scale_encode::Variant {
                            name: "Address32",
                            fields: ::scale_encode::Composite(
                                [
                                    (
                                        None as Option<&'static str>,
                                        _0 as &dyn ::scale_encode::EncodeAsType,
                                    ),
                                ]
                                    .into_iter(),
                            ),
                        }
                            .encode_as_type_to(
                                __encode_as_type_type_id,
                                __encode_as_type_types,
                                __encode_as_type_out,
                            )
                    }
                    Self::Address20(_0) => {
                        ::scale_encode::Variant {
                            name: "Address20",
                            fields: ::scale_encode::Composite(
                                [
                                    (
                                        None as Option<&'static str>,
                                        _0 as &dyn ::scale_encode::EncodeAsType,
                                    ),
                                ]
                                    .into_iter(),
                            ),
                        }
                            .encode_as_type_to(
                                __encode_as_type_type_id,
                                __encode_as_type_types,
                                __encode_as_type_out,
                            )
                    }
                    _ => {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
            }
        }
        const _: () = {
            pub struct Visitor<AccountId, AccountIndex>(
                ::core::marker::PhantomData<(AccountId, AccountIndex)>,
            );
            use ::scale_decode::vec;
            use ::scale_decode::ToString;
            impl<AccountId, AccountIndex> ::scale_decode::IntoVisitor
            for MultiAddress<AccountId, AccountIndex>
            where
                AccountId: ::scale_decode::IntoVisitor,
                ::scale_decode::Error: From<
                    <<AccountId as ::scale_decode::IntoVisitor>::Visitor as ::scale_decode::Visitor>::Error,
                >,
                AccountIndex: ::scale_decode::IntoVisitor,
                ::scale_decode::Error: From<
                    <<AccountIndex as ::scale_decode::IntoVisitor>::Visitor as ::scale_decode::Visitor>::Error,
                >,
            {
                type Visitor = Visitor<AccountId, AccountIndex>;
                fn into_visitor() -> Self::Visitor {
                    Visitor(::core::marker::PhantomData)
                }
            }
            impl<AccountId, AccountIndex> ::scale_decode::Visitor
            for Visitor<AccountId, AccountIndex>
            where
                AccountId: ::scale_decode::IntoVisitor,
                ::scale_decode::Error: From<
                    <<AccountId as ::scale_decode::IntoVisitor>::Visitor as ::scale_decode::Visitor>::Error,
                >,
                AccountIndex: ::scale_decode::IntoVisitor,
                ::scale_decode::Error: From<
                    <<AccountIndex as ::scale_decode::IntoVisitor>::Visitor as ::scale_decode::Visitor>::Error,
                >,
            {
                type Error = ::scale_decode::Error;
                type Value<'scale, 'info> = MultiAddress<AccountId, AccountIndex>;
                fn visit_variant<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Variant<'scale, 'info>,
                    type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.name() == "Id" {
                        let fields = value.fields();
                        if fields.remaining() != 1usize {
                            return Err(
                                ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                    actual_len: fields.remaining(),
                                    expected_len: 1usize,
                                }),
                            );
                        }
                        let vals = fields;
                        return Ok(
                            MultiAddress::Id({
                                let val = vals
                                    .next()
                                    .expect(
                                        "field count should have been checked already on tuple type; please file a bug report",
                                    )?;
                                val.decode_as_type().map_err(|e| e.at_idx(0usize))?
                            }),
                        );
                    }
                    if value.name() == "Index" {
                        let fields = value.fields();
                        if fields.remaining() != 1usize {
                            return Err(
                                ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                    actual_len: fields.remaining(),
                                    expected_len: 1usize,
                                }),
                            );
                        }
                        let vals = fields;
                        return Ok(
                            MultiAddress::Index({
                                let val = vals
                                    .next()
                                    .expect(
                                        "field count should have been checked already on tuple type; please file a bug report",
                                    )?;
                                val.decode_as_type().map_err(|e| e.at_idx(0usize))?
                            }),
                        );
                    }
                    if value.name() == "Raw" {
                        let fields = value.fields();
                        if fields.remaining() != 1usize {
                            return Err(
                                ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                    actual_len: fields.remaining(),
                                    expected_len: 1usize,
                                }),
                            );
                        }
                        let vals = fields;
                        return Ok(
                            MultiAddress::Raw({
                                let val = vals
                                    .next()
                                    .expect(
                                        "field count should have been checked already on tuple type; please file a bug report",
                                    )?;
                                val.decode_as_type().map_err(|e| e.at_idx(0usize))?
                            }),
                        );
                    }
                    if value.name() == "Address32" {
                        let fields = value.fields();
                        if fields.remaining() != 1usize {
                            return Err(
                                ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                    actual_len: fields.remaining(),
                                    expected_len: 1usize,
                                }),
                            );
                        }
                        let vals = fields;
                        return Ok(
                            MultiAddress::Address32({
                                let val = vals
                                    .next()
                                    .expect(
                                        "field count should have been checked already on tuple type; please file a bug report",
                                    )?;
                                val.decode_as_type().map_err(|e| e.at_idx(0usize))?
                            }),
                        );
                    }
                    if value.name() == "Address20" {
                        let fields = value.fields();
                        if fields.remaining() != 1usize {
                            return Err(
                                ::scale_decode::Error::new(::scale_decode::error::ErrorKind::WrongLength {
                                    actual_len: fields.remaining(),
                                    expected_len: 1usize,
                                }),
                            );
                        }
                        let vals = fields;
                        return Ok(
                            MultiAddress::Address20({
                                let val = vals
                                    .next()
                                    .expect(
                                        "field count should have been checked already on tuple type; please file a bug report",
                                    )?;
                                val.decode_as_type().map_err(|e| e.at_idx(0usize))?
                            }),
                        );
                    }
                    Err(
                        ::scale_decode::Error::new(::scale_decode::error::ErrorKind::CannotFindVariant {
                            got: value.name().to_string(),
                            expected: <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    "Id",
                                    "Index",
                                    "Raw",
                                    "Address32",
                                    "Address20",
                                ]),
                            ),
                        }),
                    )
                }
                fn visit_composite<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Composite<'scale, 'info>,
                    _type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 1 {
                        return self
                            .visit_unexpected(
                                ::scale_decode::visitor::Unexpected::Composite,
                            );
                    }
                    value.decode_item(self).unwrap()
                }
                fn visit_tuple<'scale, 'info>(
                    self,
                    value: &mut ::scale_decode::visitor::types::Tuple<'scale, 'info>,
                    _type_id: ::scale_decode::visitor::TypeId,
                ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                    if value.remaining() != 1 {
                        return self
                            .visit_unexpected(
                                ::scale_decode::visitor::Unexpected::Tuple,
                            );
                    }
                    value.decode_item(self).unwrap()
                }
            }
        };
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            impl<AccountId, AccountIndex> ::scale_info::TypeInfo
            for MultiAddress<AccountId, AccountIndex>
            where
                AccountId: ::scale_info::TypeInfo + 'static,
                AccountIndex: ::scale_info::scale::HasCompact,
                AccountId: ::scale_info::TypeInfo + 'static,
                AccountIndex: ::scale_info::TypeInfo + 'static,
            {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder()
                        .path(
                            ::scale_info::Path::new_with_replace(
                                "MultiAddress",
                                "subxt::utils::multi_address",
                                &[],
                            ),
                        )
                        .type_params(
                            <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    ::scale_info::TypeParameter::new(
                                        "AccountId",
                                        ::core::option::Option::Some(
                                            ::scale_info::meta_type::<AccountId>(),
                                        ),
                                    ),
                                    ::scale_info::TypeParameter::new(
                                        "AccountIndex",
                                        ::core::option::Option::Some(
                                            ::scale_info::meta_type::<AccountIndex>(),
                                        ),
                                    ),
                                ]),
                            ),
                        )
                        .docs(
                            &[
                                "A multi-format address wrapper for on-chain accounts. This is a simplified version of Substrate's",
                                "`sp_runtime::MultiAddress`. To obtain more functionality, convert this into that type (this conversion",
                                "functionality is provided via `From` impls if the `substrate-compat` feature is enabled).",
                            ],
                        )
                        .variant(
                            ::scale_info::build::Variants::new()
                                .variant(
                                    "Id",
                                    |v| {
                                        v
                                            .index(0usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::unnamed()
                                                    .field(|f| f.ty::<AccountId>().type_name("AccountId")),
                                            )
                                            .docs(&["It's an account ID (pubkey)."])
                                    },
                                )
                                .variant(
                                    "Index",
                                    |v| {
                                        v
                                            .index(1usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::unnamed()
                                                    .field(|f| {
                                                        f.compact::<AccountIndex>().type_name("AccountIndex")
                                                    }),
                                            )
                                            .docs(&["It's an account index."])
                                    },
                                )
                                .variant(
                                    "Raw",
                                    |v| {
                                        v
                                            .index(2usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::unnamed()
                                                    .field(|f| f.ty::<Vec<u8>>().type_name("Vec<u8>")),
                                            )
                                            .docs(&["It's some arbitrary raw bytes."])
                                    },
                                )
                                .variant(
                                    "Address32",
                                    |v| {
                                        v
                                            .index(3usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::unnamed()
                                                    .field(|f| f.ty::<[u8; 32]>().type_name("[u8; 32]")),
                                            )
                                            .docs(&["It's a 32 byte representation."])
                                    },
                                )
                                .variant(
                                    "Address20",
                                    |v| {
                                        v
                                            .index(4usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::unnamed()
                                                    .field(|f| f.ty::<[u8; 20]>().type_name("[u8; 20]")),
                                            )
                                            .docs(&["Its a 20 byte representation."])
                                    },
                                ),
                        )
                }
            }
        };
        impl<AccountId, AccountIndex> From<AccountId>
        for MultiAddress<AccountId, AccountIndex> {
            fn from(a: AccountId) -> Self {
                Self::Id(a)
            }
        }
    }
    mod multi_signature {
        //! The "default" Substrate/Polkadot Signature type. This is used in codegen, as well as signing related bits.
        //! This doesn't contain much functionality itself, but is easy to convert to/from an `sp_runtime::MultiSignature`
        //! for instance, to gain functionality without forcing a dependency on Substrate crates here.
        use codec::{Decode, Encode};
        /// Signature container that can store known signature types. This is a simplified version of
        /// `sp_runtime::MultiSignature`. To obtain more functionality, convert this into that type.
        pub enum MultiSignature {
            /// An Ed25519 signature.
            Ed25519([u8; 64]),
            /// An Sr25519 signature.
            Sr25519([u8; 64]),
            /// An ECDSA/SECP256k1 signature (a 512-bit value, plus 8 bits for recovery ID).
            Ecdsa([u8; 65]),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MultiSignature {
            #[inline]
            fn clone(&self) -> MultiSignature {
                match self {
                    MultiSignature::Ed25519(__self_0) => {
                        MultiSignature::Ed25519(::core::clone::Clone::clone(__self_0))
                    }
                    MultiSignature::Sr25519(__self_0) => {
                        MultiSignature::Sr25519(::core::clone::Clone::clone(__self_0))
                    }
                    MultiSignature::Ecdsa(__self_0) => {
                        MultiSignature::Ecdsa(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for MultiSignature {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<[u8; 64]>;
                let _: ::core::cmp::AssertParamIsEq<[u8; 64]>;
                let _: ::core::cmp::AssertParamIsEq<[u8; 65]>;
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MultiSignature {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MultiSignature {
            #[inline]
            fn eq(&self, other: &MultiSignature) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
                    && match (self, other) {
                        (
                            MultiSignature::Ed25519(__self_0),
                            MultiSignature::Ed25519(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            MultiSignature::Sr25519(__self_0),
                            MultiSignature::Sr25519(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        (
                            MultiSignature::Ecdsa(__self_0),
                            MultiSignature::Ecdsa(__arg1_0),
                        ) => *__self_0 == *__arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for MultiSignature {
            #[inline]
            fn cmp(&self, other: &MultiSignature) -> ::core::cmp::Ordering {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
                    ::core::cmp::Ordering::Equal => {
                        match (self, other) {
                            (
                                MultiSignature::Ed25519(__self_0),
                                MultiSignature::Ed25519(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                MultiSignature::Sr25519(__self_0),
                                MultiSignature::Sr25519(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                MultiSignature::Ecdsa(__self_0),
                                MultiSignature::Ecdsa(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for MultiSignature {
            #[inline]
            fn partial_cmp(
                &self,
                other: &MultiSignature,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                match (self, other) {
                    (
                        MultiSignature::Ed25519(__self_0),
                        MultiSignature::Ed25519(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        MultiSignature::Sr25519(__self_0),
                        MultiSignature::Sr25519(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        MultiSignature::Ecdsa(__self_0),
                        MultiSignature::Ecdsa(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    _ => ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag),
                }
            }
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Encode for MultiSignature {
                fn size_hint(&self) -> usize {
                    1_usize
                        + match *self {
                            MultiSignature::Ed25519(ref aa) => {
                                0_usize.saturating_add(::codec::Encode::size_hint(aa))
                            }
                            MultiSignature::Sr25519(ref aa) => {
                                0_usize.saturating_add(::codec::Encode::size_hint(aa))
                            }
                            MultiSignature::Ecdsa(ref aa) => {
                                0_usize.saturating_add(::codec::Encode::size_hint(aa))
                            }
                            _ => 0_usize,
                        }
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    match *self {
                        MultiSignature::Ed25519(ref aa) => {
                            __codec_dest_edqy.push_byte(0usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                        }
                        MultiSignature::Sr25519(ref aa) => {
                            __codec_dest_edqy.push_byte(1usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                        }
                        MultiSignature::Ecdsa(ref aa) => {
                            __codec_dest_edqy.push_byte(2usize as ::core::primitive::u8);
                            ::codec::Encode::encode_to(aa, __codec_dest_edqy);
                        }
                        _ => {}
                    }
                }
            }
            #[automatically_derived]
            impl ::codec::EncodeLike for MultiSignature {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl ::codec::Decode for MultiSignature {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    match __codec_input_edqy
                        .read_byte()
                        .map_err(|e| {
                            e
                                .chain(
                                    "Could not decode `MultiSignature`, failed to read variant byte",
                                )
                        })?
                    {
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 0usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    MultiSignature::Ed25519({
                                        let __codec_res_edqy = <[u8; 64] as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `MultiSignature::Ed25519.0`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    }),
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 1usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    MultiSignature::Sr25519({
                                        let __codec_res_edqy = <[u8; 64] as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `MultiSignature::Sr25519.0`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    }),
                                )
                            })();
                        }
                        #[allow(clippy::unnecessary_cast)]
                        __codec_x_edqy if __codec_x_edqy
                            == 2usize as ::core::primitive::u8 => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Ok(
                                    MultiSignature::Ecdsa({
                                        let __codec_res_edqy = <[u8; 65] as ::codec::Decode>::decode(
                                            __codec_input_edqy,
                                        );
                                        match __codec_res_edqy {
                                            ::core::result::Result::Err(e) => {
                                                return ::core::result::Result::Err(
                                                    e.chain("Could not decode `MultiSignature::Ecdsa.0`"),
                                                );
                                            }
                                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                                __codec_res_edqy
                                            }
                                        }
                                    }),
                                )
                            })();
                        }
                        _ => {
                            #[allow(clippy::redundant_closure_call)]
                            return (move || {
                                ::core::result::Result::Err(
                                    <_ as ::core::convert::Into<
                                        _,
                                    >>::into(
                                        "Could not decode `MultiSignature`, variant doesn't exist",
                                    ),
                                )
                            })();
                        }
                    }
                }
            }
        };
        #[automatically_derived]
        impl ::core::fmt::Debug for MultiSignature {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    MultiSignature::Ed25519(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Ed25519",
                            &__self_0,
                        )
                    }
                    MultiSignature::Sr25519(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Sr25519",
                            &__self_0,
                        )
                    }
                    MultiSignature::Ecdsa(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Ecdsa",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            impl ::scale_info::TypeInfo for MultiSignature {
                type Identity = Self;
                fn type_info() -> ::scale_info::Type {
                    ::scale_info::Type::builder()
                        .path(
                            ::scale_info::Path::new_with_replace(
                                "MultiSignature",
                                "subxt::utils::multi_signature",
                                &[],
                            ),
                        )
                        .type_params(::alloc::vec::Vec::new())
                        .docs(
                            &[
                                "Signature container that can store known signature types. This is a simplified version of",
                                "`sp_runtime::MultiSignature`. To obtain more functionality, convert this into that type.",
                            ],
                        )
                        .variant(
                            ::scale_info::build::Variants::new()
                                .variant(
                                    "Ed25519",
                                    |v| {
                                        v
                                            .index(0usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::unnamed()
                                                    .field(|f| f.ty::<[u8; 64]>().type_name("[u8; 64]")),
                                            )
                                            .docs(&["An Ed25519 signature."])
                                    },
                                )
                                .variant(
                                    "Sr25519",
                                    |v| {
                                        v
                                            .index(1usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::unnamed()
                                                    .field(|f| f.ty::<[u8; 64]>().type_name("[u8; 64]")),
                                            )
                                            .docs(&["An Sr25519 signature."])
                                    },
                                )
                                .variant(
                                    "Ecdsa",
                                    |v| {
                                        v
                                            .index(2usize as ::core::primitive::u8)
                                            .fields(
                                                ::scale_info::build::Fields::unnamed()
                                                    .field(|f| f.ty::<[u8; 65]>().type_name("[u8; 65]")),
                                            )
                                            .docs(
                                                &[
                                                    "An ECDSA/SECP256k1 signature (a 512-bit value, plus 8 bits for recovery ID).",
                                                ],
                                            )
                                    },
                                ),
                        )
                }
            }
        };
    }
    mod static_type {
        use codec::{Decode, Encode};
        use scale_decode::{visitor::DecodeAsTypeResult, IntoVisitor, Visitor};
        use scale_encode::EncodeAsType;
        /// If the type inside this implements [`Encode`], this will implement [`scale_encode::EncodeAsType`].
        /// If the type inside this implements [`Decode`], this will implement [`scale_decode::DecodeAsType`].
        ///
        /// In either direction, we ignore any type information and just attempt to encode/decode statically
        /// via the [`Encode`] and [`Decode`] implementations. This can be useful as an adapter for types which
        /// do not implement [`scale_encode::EncodeAsType`] and [`scale_decode::DecodeAsType`] themselves, but
        /// it's best to avoid using it where possible as it will not take into account any type information,
        /// and is thus more likely to encode or decode incorrectly.
        pub struct Static<T>(pub T);
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Static<T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Static", &&self.0)
            }
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T> ::codec::Encode for Static<T>
            where
                T: ::codec::Encode,
                T: ::codec::Encode,
            {
                fn size_hint(&self) -> usize {
                    ::codec::Encode::size_hint(&&self.0)
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    ::codec::Encode::encode_to(&&self.0, __codec_dest_edqy)
                }
                fn encode(&self) -> ::codec::alloc::vec::Vec<::core::primitive::u8> {
                    ::codec::Encode::encode(&&self.0)
                }
                fn using_encoded<
                    __CodecOutputReturn,
                    __CodecUsingEncodedCallback: ::core::ops::FnOnce(
                            &[::core::primitive::u8],
                        ) -> __CodecOutputReturn,
                >(&self, f: __CodecUsingEncodedCallback) -> __CodecOutputReturn {
                    ::codec::Encode::using_encoded(&&self.0, f)
                }
            }
            #[automatically_derived]
            impl<T> ::codec::EncodeLike for Static<T>
            where
                T: ::codec::Encode,
                T: ::codec::Encode,
            {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T> ::codec::Decode for Static<T>
            where
                T: ::codec::Decode,
                T: ::codec::Decode,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(
                        Static::<
                            T,
                        >({
                            let __codec_res_edqy = <T as ::codec::Decode>::decode(
                                __codec_input_edqy,
                            );
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `Static.0`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        }),
                    )
                }
            }
        };
        #[automatically_derived]
        impl<T> ::core::marker::StructuralPartialEq for Static<T> {}
        #[automatically_derived]
        impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Static<T> {
            #[inline]
            fn eq(&self, other: &Static<T>) -> bool {
                self.0 == other.0
            }
        }
        #[automatically_derived]
        impl<T: ::core::cmp::Eq> ::core::cmp::Eq for Static<T> {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<T>;
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for Static<T> {
            #[inline]
            fn clone(&self) -> Static<T> {
                Static(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl<T: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for Static<T> {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Static<T>,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<T: ::core::cmp::Ord> ::core::cmp::Ord for Static<T> {
            #[inline]
            fn cmp(&self, other: &Static<T>) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.0, &other.0)
            }
        }
        #[automatically_derived]
        impl<T: ::core::hash::Hash> ::core::hash::Hash for Static<T> {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.0, state)
            }
        }
        impl<T: Encode> EncodeAsType for Static<T> {
            fn encode_as_type_to(
                &self,
                _type_id: u32,
                _types: &scale_decode::PortableRegistry,
                out: &mut Vec<u8>,
            ) -> Result<(), scale_encode::Error> {
                self.0.encode_to(out);
                Ok(())
            }
        }
        pub struct StaticDecodeAsTypeVisitor<T>(std::marker::PhantomData<T>);
        impl<T: Decode> Visitor for StaticDecodeAsTypeVisitor<T> {
            type Value<'scale, 'info> = Static<T>;
            type Error = scale_decode::Error;
            fn unchecked_decode_as_type<'scale, 'info>(
                self,
                input: &mut &'scale [u8],
                _type_id: scale_decode::visitor::TypeId,
                _types: &'info scale_info::PortableRegistry,
            ) -> DecodeAsTypeResult<
                Self,
                Result<Self::Value<'scale, 'info>, Self::Error>,
            > {
                use scale_decode::{visitor::DecodeError, Error};
                let decoded = T::decode(input)
                    .map(Static)
                    .map_err(|e| Error::new(DecodeError::CodecError(e).into()));
                DecodeAsTypeResult::Decoded(decoded)
            }
        }
        impl<T: Decode> IntoVisitor for Static<T> {
            type Visitor = StaticDecodeAsTypeVisitor<T>;
            fn into_visitor() -> Self::Visitor {
                StaticDecodeAsTypeVisitor(std::marker::PhantomData)
            }
        }
        impl<T> From<T> for Static<T> {
            fn from(value: T) -> Self {
                Static(value)
            }
        }
        impl<T> std::ops::Deref for Static<T> {
            type Target = T;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl<T> std::ops::DerefMut for Static<T> {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
    }
    mod unchecked_extrinsic {
        //! The "default" Substrate/Polkadot UncheckedExtrinsic.
        //! This is used in codegen for runtime API calls.
        //!
        //! The inner bytes represent the encoded extrinsic expected by the
        //! runtime APIs. Deriving `EncodeAsType` would lead to the inner
        //! bytes to be re-encoded (length prefixed).
        use std::marker::PhantomData;
        use codec::{Decode, Encode};
        use scale_decode::{
            visitor::DecodeAsTypeResult, DecodeAsType, IntoVisitor, Visitor,
        };
        use super::{Encoded, Static};
        /// The unchecked extrinsic from substrate.
        pub struct UncheckedExtrinsic<Address, Call, Signature, Extra>(
            Static<Encoded>,
            #[codec(skip)]
            PhantomData<(Address, Call, Signature, Extra)>,
        );
        #[automatically_derived]
        impl<
            Address: ::core::clone::Clone,
            Call: ::core::clone::Clone,
            Signature: ::core::clone::Clone,
            Extra: ::core::clone::Clone,
        > ::core::clone::Clone for UncheckedExtrinsic<Address, Call, Signature, Extra> {
            #[inline]
            fn clone(&self) -> UncheckedExtrinsic<Address, Call, Signature, Extra> {
                UncheckedExtrinsic(
                    ::core::clone::Clone::clone(&self.0),
                    ::core::clone::Clone::clone(&self.1),
                )
            }
        }
        #[automatically_derived]
        impl<
            Address: ::core::fmt::Debug,
            Call: ::core::fmt::Debug,
            Signature: ::core::fmt::Debug,
            Extra: ::core::fmt::Debug,
        > ::core::fmt::Debug for UncheckedExtrinsic<Address, Call, Signature, Extra> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field2_finish(
                    f,
                    "UncheckedExtrinsic",
                    &self.0,
                    &&self.1,
                )
            }
        }
        #[automatically_derived]
        impl<
            Address: ::core::cmp::Eq,
            Call: ::core::cmp::Eq,
            Signature: ::core::cmp::Eq,
            Extra: ::core::cmp::Eq,
        > ::core::cmp::Eq for UncheckedExtrinsic<Address, Call, Signature, Extra> {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<Static<Encoded>>;
                let _: ::core::cmp::AssertParamIsEq<
                    PhantomData<(Address, Call, Signature, Extra)>,
                >;
            }
        }
        #[automatically_derived]
        impl<Address, Call, Signature, Extra> ::core::marker::StructuralPartialEq
        for UncheckedExtrinsic<Address, Call, Signature, Extra> {}
        #[automatically_derived]
        impl<
            Address: ::core::cmp::PartialEq,
            Call: ::core::cmp::PartialEq,
            Signature: ::core::cmp::PartialEq,
            Extra: ::core::cmp::PartialEq,
        > ::core::cmp::PartialEq
        for UncheckedExtrinsic<Address, Call, Signature, Extra> {
            #[inline]
            fn eq(
                &self,
                other: &UncheckedExtrinsic<Address, Call, Signature, Extra>,
            ) -> bool {
                self.0 == other.0 && self.1 == other.1
            }
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<Address, Call, Signature, Extra> ::codec::Encode
            for UncheckedExtrinsic<Address, Call, Signature, Extra> {
                fn size_hint(&self) -> usize {
                    ::codec::Encode::size_hint(&&self.0)
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    ::codec::Encode::encode_to(&&self.0, __codec_dest_edqy)
                }
                fn encode(&self) -> ::codec::alloc::vec::Vec<::core::primitive::u8> {
                    ::codec::Encode::encode(&&self.0)
                }
                fn using_encoded<
                    __CodecOutputReturn,
                    __CodecUsingEncodedCallback: ::core::ops::FnOnce(
                            &[::core::primitive::u8],
                        ) -> __CodecOutputReturn,
                >(&self, f: __CodecUsingEncodedCallback) -> __CodecOutputReturn {
                    ::codec::Encode::using_encoded(&&self.0, f)
                }
            }
            #[automatically_derived]
            impl<Address, Call, Signature, Extra> ::codec::EncodeLike
            for UncheckedExtrinsic<Address, Call, Signature, Extra> {}
        };
        impl<
            Address,
            Call,
            Signature,
            Extra,
        > UncheckedExtrinsic<Address, Call, Signature, Extra> {
            /// Construct a new [`UncheckedExtrinsic`].
            pub fn new(bytes: Vec<u8>) -> Self {
                Self(Static(Encoded(bytes)), PhantomData)
            }
            /// Get the bytes of the encoded extrinsic.
            pub fn bytes(&self) -> &[u8] {
                self.0.0.0.as_slice()
            }
        }
        impl<Address, Call, Signature, Extra> Decode
        for UncheckedExtrinsic<Address, Call, Signature, Extra> {
            fn decode<I: codec::Input>(input: &mut I) -> Result<Self, codec::Error> {
                let xt_vec: Vec<u8> = Decode::decode(input)?;
                Ok(UncheckedExtrinsic::new(xt_vec))
            }
        }
        impl<Address, Call, Signature, Extra> scale_encode::EncodeAsType
        for UncheckedExtrinsic<Address, Call, Signature, Extra> {
            fn encode_as_type_to(
                &self,
                type_id: u32,
                types: &scale_info::PortableRegistry,
                out: &mut Vec<u8>,
            ) -> Result<(), scale_encode::Error> {
                self.0.encode_as_type_to(type_id, types, out)
            }
        }
        impl<Address, Call, Signature, Extra> From<Vec<u8>>
        for UncheckedExtrinsic<Address, Call, Signature, Extra> {
            fn from(bytes: Vec<u8>) -> Self {
                UncheckedExtrinsic::new(bytes)
            }
        }
        impl<
            Address,
            Call,
            Signature,
            Extra,
        > From<UncheckedExtrinsic<Address, Call, Signature, Extra>> for Vec<u8> {
            fn from(bytes: UncheckedExtrinsic<Address, Call, Signature, Extra>) -> Self {
                bytes.0.0.0
            }
        }
        pub struct UncheckedExtrinsicDecodeAsTypeVisitor<
            Address,
            Call,
            Signature,
            Extra,
        >(
            PhantomData<(Address, Call, Signature, Extra)>,
        );
        impl<Address, Call, Signature, Extra> Visitor
        for UncheckedExtrinsicDecodeAsTypeVisitor<Address, Call, Signature, Extra> {
            type Value<'scale, 'info> = UncheckedExtrinsic<
                Address,
                Call,
                Signature,
                Extra,
            >;
            type Error = scale_decode::Error;
            fn unchecked_decode_as_type<'scale, 'info>(
                self,
                input: &mut &'scale [u8],
                type_id: scale_decode::visitor::TypeId,
                types: &'info scale_info::PortableRegistry,
            ) -> DecodeAsTypeResult<
                Self,
                Result<Self::Value<'scale, 'info>, Self::Error>,
            > {
                DecodeAsTypeResult::Decoded(
                    Self::Value::decode_as_type(input, type_id.0, types),
                )
            }
        }
        impl<Address, Call, Signature, Extra> IntoVisitor
        for UncheckedExtrinsic<Address, Call, Signature, Extra> {
            type Visitor = UncheckedExtrinsicDecodeAsTypeVisitor<
                Address,
                Call,
                Signature,
                Extra,
            >;
            fn into_visitor() -> Self::Visitor {
                UncheckedExtrinsicDecodeAsTypeVisitor(PhantomData)
            }
        }
    }
    mod wrapper_opaque {
        use super::PhantomDataSendSync;
        use codec::{Compact, Decode, DecodeAll, Encode};
        use derivative::Derivative;
        use scale_decode::{IntoVisitor, Visitor};
        use scale_encode::EncodeAsType;
        /// A wrapper for any type `T` which implement encode/decode in a way compatible with `Vec<u8>`.
        /// [`WrapperKeepOpaque`] stores the type only in its opaque format, aka as a `Vec<u8>`. To
        /// access the real type `T` [`Self::try_decode`] needs to be used.
        #[derivative(
            Debug(bound = ""),
            Clone(bound = ""),
            PartialEq(bound = ""),
            Eq(bound = ""),
            Default(bound = ""),
            Hash(bound = "")
        )]
        pub struct WrapperKeepOpaque<T> {
            data: Vec<u8>,
            _phantom: PhantomDataSendSync<T>,
        }
        #[allow(unused_qualifications)]
        impl<T> ::std::clone::Clone for WrapperKeepOpaque<T> {
            fn clone(&self) -> Self {
                match *self {
                    WrapperKeepOpaque { data: ref __arg_0, _phantom: ref __arg_1 } => {
                        WrapperKeepOpaque {
                            data: (*__arg_0).clone(),
                            _phantom: (*__arg_1).clone(),
                        }
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<T> ::std::fmt::Debug for WrapperKeepOpaque<T> {
            fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    WrapperKeepOpaque { data: ref __arg_0, _phantom: ref __arg_1 } => {
                        let mut __debug_trait_builder = __f
                            .debug_struct("WrapperKeepOpaque");
                        let _ = __debug_trait_builder.field("data", &&(*__arg_0));
                        let _ = __debug_trait_builder.field("_phantom", &&(*__arg_1));
                        __debug_trait_builder.finish()
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        impl<T> ::std::default::Default for WrapperKeepOpaque<T> {
            fn default() -> Self {
                WrapperKeepOpaque {
                    data: ::std::default::Default::default(),
                    _phantom: ::std::default::Default::default(),
                }
            }
        }
        #[allow(unused_qualifications)]
        impl<T> ::std::cmp::Eq for WrapperKeepOpaque<T> {}
        #[allow(unused_qualifications)]
        impl<T> ::std::hash::Hash for WrapperKeepOpaque<T> {
            fn hash<__HT>(&self, __state: &mut __HT)
            where
                __HT: ::std::hash::Hasher,
            {
                match *self {
                    WrapperKeepOpaque { data: ref __arg_0, _phantom: ref __arg_1 } => {
                        ::std::hash::Hash::hash(&(*__arg_0), __state);
                        ::std::hash::Hash::hash(&(*__arg_1), __state);
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[allow(clippy::unneeded_field_pattern)]
        impl<T> ::std::cmp::PartialEq for WrapperKeepOpaque<T> {
            fn eq(&self, other: &Self) -> bool {
                true
                    && match *self {
                        WrapperKeepOpaque {
                            data: ref __self_0,
                            _phantom: ref __self_1,
                        } => {
                            match *other {
                                WrapperKeepOpaque {
                                    data: ref __other_0,
                                    _phantom: ref __other_1,
                                } => {
                                    true && &(*__self_0) == &(*__other_0)
                                        && &(*__self_1) == &(*__other_1)
                                }
                            }
                        }
                    }
            }
        }
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T> ::codec::Encode for WrapperKeepOpaque<T>
            where
                PhantomDataSendSync<T>: ::codec::Encode,
                PhantomDataSendSync<T>: ::codec::Encode,
            {
                fn size_hint(&self) -> usize {
                    0_usize
                        .saturating_add(::codec::Encode::size_hint(&self.data))
                        .saturating_add(::codec::Encode::size_hint(&self._phantom))
                }
                fn encode_to<
                    __CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized,
                >(&self, __codec_dest_edqy: &mut __CodecOutputEdqy) {
                    ::codec::Encode::encode_to(&self.data, __codec_dest_edqy);
                    ::codec::Encode::encode_to(&self._phantom, __codec_dest_edqy);
                }
            }
            #[automatically_derived]
            impl<T> ::codec::EncodeLike for WrapperKeepOpaque<T>
            where
                PhantomDataSendSync<T>: ::codec::Encode,
                PhantomDataSendSync<T>: ::codec::Encode,
            {}
        };
        #[allow(deprecated)]
        const _: () = {
            #[automatically_derived]
            impl<T> ::codec::Decode for WrapperKeepOpaque<T>
            where
                PhantomDataSendSync<T>: ::codec::Decode,
                PhantomDataSendSync<T>: ::codec::Decode,
            {
                fn decode<__CodecInputEdqy: ::codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> ::core::result::Result<Self, ::codec::Error> {
                    ::core::result::Result::Ok(WrapperKeepOpaque::<T> {
                        data: {
                            let __codec_res_edqy = <Vec<
                                u8,
                            > as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `WrapperKeepOpaque::data`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                        _phantom: {
                            let __codec_res_edqy = <PhantomDataSendSync<
                                T,
                            > as ::codec::Decode>::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                ::core::result::Result::Err(e) => {
                                    return ::core::result::Result::Err(
                                        e.chain("Could not decode `WrapperKeepOpaque::_phantom`"),
                                    );
                                }
                                ::core::result::Result::Ok(__codec_res_edqy) => {
                                    __codec_res_edqy
                                }
                            }
                        },
                    })
                }
            }
        };
        impl<T> WrapperKeepOpaque<T> {
            /// Try to decode the wrapped type from the inner `data`.
            ///
            /// Returns `None` if the decoding failed.
            pub fn try_decode(&self) -> Option<T>
            where
                T: Decode,
            {
                T::decode_all(&mut &self.data[..]).ok()
            }
            /// Returns the length of the encoded `T`.
            pub fn encoded_len(&self) -> usize {
                self.data.len()
            }
            /// Returns the encoded data.
            pub fn encoded(&self) -> &[u8] {
                &self.data
            }
            /// Create from the given encoded `data`.
            pub fn from_encoded(data: Vec<u8>) -> Self {
                Self {
                    data,
                    _phantom: PhantomDataSendSync::new(),
                }
            }
            /// Create from some raw value by encoding it.
            pub fn from_value(value: T) -> Self
            where
                T: Encode,
            {
                Self {
                    data: value.encode(),
                    _phantom: PhantomDataSendSync::new(),
                }
            }
        }
        impl<T> EncodeAsType for WrapperKeepOpaque<T> {
            fn encode_as_type_to(
                &self,
                type_id: u32,
                types: &scale_info::PortableRegistry,
                out: &mut Vec<u8>,
            ) -> Result<(), scale_encode::Error> {
                use scale_encode::error::{Error, ErrorKind, Kind};
                let Some(ty) = types.resolve(type_id) else {
                return Err(Error::new(ErrorKind::TypeNotFound(type_id)));
            };
                let scale_info::TypeDef::Composite(_) = &ty.type_def else {
                return Err(
                    Error::new(ErrorKind::WrongShape {
                        actual: Kind::Struct,
                        expected: type_id,
                    }),
                );
            };
                if ty.path.ident().as_deref() != Some("WrapperKeepOpaque") {
                    return Err(
                        Error::new(ErrorKind::WrongShape {
                            actual: Kind::Struct,
                            expected: type_id,
                        }),
                    );
                }
                self.data.encode_to(out);
                Ok(())
            }
        }
        pub struct WrapperKeepOpaqueVisitor<T>(std::marker::PhantomData<T>);
        impl<T> Visitor for WrapperKeepOpaqueVisitor<T> {
            type Value<'scale, 'info> = WrapperKeepOpaque<T>;
            type Error = scale_decode::Error;
            fn visit_composite<'scale, 'info>(
                self,
                value: &mut scale_decode::visitor::types::Composite<'scale, 'info>,
                _type_id: scale_decode::visitor::TypeId,
            ) -> Result<Self::Value<'scale, 'info>, Self::Error> {
                use scale_decode::error::{Error, ErrorKind};
                if value.path().ident().as_deref() != Some("WrapperKeepOpaque") {
                    return Err(
                        Error::custom_str(
                            "Type to decode is not 'WrapperTypeKeepOpaque'",
                        ),
                    );
                }
                if value.remaining() != 2 {
                    return Err(
                        Error::new(ErrorKind::WrongLength {
                            actual_len: value.remaining(),
                            expected_len: 2,
                        }),
                    );
                }
                let Compact(len) = value
                    .decode_item(Compact::<u32>::into_visitor())
                    .expect("length checked")?;
                let field = value.next().expect("length checked")?;
                if field.bytes().len() != len as usize {
                    return Err(
                        Error::custom_str(
                            "WrapperTypeKeepOpaque compact encoded length doesn't line up with encoded byte len",
                        ),
                    );
                }
                Ok(WrapperKeepOpaque {
                    data: field.bytes().to_vec(),
                    _phantom: PhantomDataSendSync::new(),
                })
            }
        }
        impl<T> IntoVisitor for WrapperKeepOpaque<T> {
            type Visitor = WrapperKeepOpaqueVisitor<T>;
            fn into_visitor() -> Self::Visitor {
                WrapperKeepOpaqueVisitor(std::marker::PhantomData)
            }
        }
    }
    use crate::error::RpcError;
    use crate::Error;
    use codec::{Compact, Decode, Encode};
    use derivative::Derivative;
    use url::Url;
    pub use account_id::AccountId32;
    pub use era::Era;
    pub use multi_address::MultiAddress;
    pub use multi_signature::MultiSignature;
    pub use static_type::Static;
    pub use unchecked_extrinsic::UncheckedExtrinsic;
    pub use wrapper_opaque::WrapperKeepOpaque;
    #[doc(hidden)]
    pub use primitive_types::{H160, H256, H512};
    /// Wraps an already encoded byte vector, prevents being encoded as a raw byte vector as part of
    /// the transaction payload
    pub struct Encoded(pub Vec<u8>);
    #[automatically_derived]
    impl ::core::clone::Clone for Encoded {
        #[inline]
        fn clone(&self) -> Encoded {
            Encoded(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Encoded {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Encoded", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Encoded {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Encoded {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Encoded {
        #[inline]
        fn eq(&self, other: &Encoded) -> bool {
            self.0 == other.0
        }
    }
    impl codec::Encode for Encoded {
        fn encode(&self) -> Vec<u8> {
            self.0.to_owned()
        }
    }
    /// Decodes a compact encoded value from the beginning of the provided bytes,
    /// returning the value and any remaining bytes.
    pub(crate) fn strip_compact_prefix(
        bytes: &[u8],
    ) -> Result<(u64, &[u8]), codec::Error> {
        let cursor = &mut &*bytes;
        let val = <Compact<u64>>::decode(cursor)?;
        Ok((val.0, *cursor))
    }
    /// A URL is considered secure if it uses a secure scheme ("https" or "wss") or is referring to localhost.
    ///
    /// Returns an error if the the string could not be parsed into a URL.
    pub fn url_is_secure(url: &str) -> Result<bool, Error> {
        let url = Url::parse(url)
            .map_err(|e| Error::Rpc(RpcError::ClientError(Box::new(e))))?;
        let secure_scheme = url.scheme() == "https" || url.scheme() == "wss";
        let is_localhost = url
            .host()
            .is_some_and(|e| match e {
                url::Host::Domain(e) => e == "localhost",
                url::Host::Ipv4(e) => e.is_loopback(),
                url::Host::Ipv6(e) => e.is_loopback(),
            });
        Ok(secure_scheme || is_localhost)
    }
    /// Validates, that the given Url is secure ("https" or "wss" scheme) or is referring to localhost.
    pub fn validate_url_is_secure(url: &str) -> Result<(), Error> {
        if !url_is_secure(url)? {
            Err(Error::Rpc(crate::error::RpcError::InsecureUrl(url.into())))
        } else {
            Ok(())
        }
    }
    /// A version of [`std::marker::PhantomData`] that is also Send and Sync (which is fine
    /// because regardless of the generic param, it is always possible to Send + Sync this
    /// 0 size type).
    #[derivative(
        Clone(bound = ""),
        PartialEq(bound = ""),
        Debug(bound = ""),
        Eq(bound = ""),
        Default(bound = ""),
        Hash(bound = "")
    )]
    #[scale_info(skip_type_params(T))]
    #[doc(hidden)]
    pub struct PhantomDataSendSync<T>(core::marker::PhantomData<T>);
    #[allow(unused_qualifications)]
    impl<T> ::std::clone::Clone for PhantomDataSendSync<T> {
        fn clone(&self) -> Self {
            match *self {
                PhantomDataSendSync(ref __arg_0) => {
                    PhantomDataSendSync((*__arg_0).clone())
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::unneeded_field_pattern)]
    impl<T> ::std::fmt::Debug for PhantomDataSendSync<T> {
        fn fmt(&self, __f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                PhantomDataSendSync(ref __arg_0) => {
                    let mut __debug_trait_builder = __f
                        .debug_tuple("PhantomDataSendSync");
                    let _ = __debug_trait_builder.field(&&(*__arg_0));
                    __debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    impl<T> ::std::default::Default for PhantomDataSendSync<T> {
        fn default() -> Self {
            PhantomDataSendSync(::std::default::Default::default())
        }
    }
    #[allow(unused_qualifications)]
    impl<T> ::std::cmp::Eq for PhantomDataSendSync<T> {}
    #[allow(unused_qualifications)]
    impl<T> ::std::hash::Hash for PhantomDataSendSync<T> {
        fn hash<__HT>(&self, __state: &mut __HT)
        where
            __HT: ::std::hash::Hasher,
        {
            match *self {
                PhantomDataSendSync(ref __arg_0) => {
                    ::std::hash::Hash::hash(&(*__arg_0), __state);
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    #[allow(clippy::unneeded_field_pattern)]
    impl<T> ::std::cmp::PartialEq for PhantomDataSendSync<T> {
        fn eq(&self, other: &Self) -> bool {
            true
                && match *self {
                    PhantomDataSendSync(ref __self_0) => {
                        match *other {
                            PhantomDataSendSync(ref __other_0) => {
                                true && &(*__self_0) == &(*__other_0)
                            }
                        }
                    }
                }
        }
    }
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T> ::codec::Encode for PhantomDataSendSync<T>
        where
            core::marker::PhantomData<T>: ::codec::Encode,
            core::marker::PhantomData<T>: ::codec::Encode,
        {
            fn size_hint(&self) -> usize {
                ::codec::Encode::size_hint(&&self.0)
            }
            fn encode_to<__CodecOutputEdqy: ::codec::Output + ?::core::marker::Sized>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                ::codec::Encode::encode_to(&&self.0, __codec_dest_edqy)
            }
            fn encode(&self) -> ::codec::alloc::vec::Vec<::core::primitive::u8> {
                ::codec::Encode::encode(&&self.0)
            }
            fn using_encoded<
                __CodecOutputReturn,
                __CodecUsingEncodedCallback: ::core::ops::FnOnce(
                        &[::core::primitive::u8],
                    ) -> __CodecOutputReturn,
            >(&self, f: __CodecUsingEncodedCallback) -> __CodecOutputReturn {
                ::codec::Encode::using_encoded(&&self.0, f)
            }
        }
        #[automatically_derived]
        impl<T> ::codec::EncodeLike for PhantomDataSendSync<T>
        where
            core::marker::PhantomData<T>: ::codec::Encode,
            core::marker::PhantomData<T>: ::codec::Encode,
        {}
    };
    #[allow(deprecated)]
    const _: () = {
        #[automatically_derived]
        impl<T> ::codec::Decode for PhantomDataSendSync<T>
        where
            core::marker::PhantomData<T>: ::codec::Decode,
            core::marker::PhantomData<T>: ::codec::Decode,
        {
            fn decode<__CodecInputEdqy: ::codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> ::core::result::Result<Self, ::codec::Error> {
                ::core::result::Result::Ok(
                    PhantomDataSendSync::<
                        T,
                    >({
                        let __codec_res_edqy = <core::marker::PhantomData<
                            T,
                        > as ::codec::Decode>::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            ::core::result::Result::Err(e) => {
                                return ::core::result::Result::Err(
                                    e.chain("Could not decode `PhantomDataSendSync.0`"),
                                );
                            }
                            ::core::result::Result::Ok(__codec_res_edqy) => {
                                __codec_res_edqy
                            }
                        }
                    }),
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        impl<T> ::scale_info::TypeInfo for PhantomDataSendSync<T>
        where
            core::marker::PhantomData<T>: ::scale_info::TypeInfo + 'static,
            T: 'static,
        {
            type Identity = Self;
            fn type_info() -> ::scale_info::Type {
                ::scale_info::Type::builder()
                    .path(
                        ::scale_info::Path::new_with_replace(
                            "PhantomDataSendSync",
                            "subxt::utils",
                            &[],
                        ),
                    )
                    .type_params(
                        <[_]>::into_vec(
                            #[rustc_box]
                            ::alloc::boxed::Box::new([
                                ::scale_info::TypeParameter::new(
                                    "T",
                                    ::core::option::Option::None,
                                ),
                            ]),
                        ),
                    )
                    .docs(
                        &[
                            "A version of [`std::marker::PhantomData`] that is also Send and Sync (which is fine",
                            "because regardless of the generic param, it is always possible to Send + Sync this",
                            "0 size type).",
                        ],
                    )
                    .composite(
                        ::scale_info::build::Fields::unnamed()
                            .field(|f| {
                                f
                                    .ty::<core::marker::PhantomData<T>>()
                                    .type_name("core::marker::PhantomData<T>")
                            }),
                    )
            }
        }
    };
    impl<T> PhantomDataSendSync<T> {
        pub(crate) fn new() -> Self {
            Self(core::marker::PhantomData)
        }
    }
    unsafe impl<T> Send for PhantomDataSendSync<T> {}
    unsafe impl<T> Sync for PhantomDataSendSync<T> {}
    /// This represents a key-value collection and is SCALE compatible
    /// with collections like BTreeMap. This has the same type params
    /// as `BTreeMap` which allows us to easily swap the two during codegen.
    pub type KeyedVec<K, V> = Vec<(K, V)>;
}
#[macro_use]
mod macros {
    pub(crate) use {
        cfg_feature, cfg_jsonrpsee, cfg_reconnecting_rpc_client, cfg_substrate_compat,
        cfg_unstable_light_client,
    };
    #[allow(unused)]
    pub(crate) use {cfg_jsonrpsee_native, cfg_jsonrpsee_web};
}
pub use crate::{
    client::{OfflineClient, OnlineClient},
    config::{Config, PolkadotConfig, SubstrateConfig},
    error::Error, metadata::Metadata,
};
/// Re-export external crates that are made use of in the subxt API.
pub mod ext {
    pub use codec;
    pub use frame_metadata;
    pub use futures;
    pub use scale_bits;
    pub use scale_decode;
    pub use scale_encode;
    pub use scale_value;
}
/// Generate a strongly typed API for interacting with a Substrate runtime from its metadata.
///
/// # Metadata
///
/// First, you'll need to get hold of some metadata for the node you'd like to interact with. One
/// way to do this is by using the `subxt` CLI tool:
///
/// ```bash
/// # Install the CLI tool:
/// cargo install subxt-cli
/// # Use it to download metadata (in this case, from a node running locally)
/// subxt metadata > polkadot_metadata.scale
/// ```
///
/// Run `subxt metadata --help` for more options.
///
/// # Basic usage
///
/// Annotate a Rust module with the `subxt` attribute referencing the aforementioned metadata file.
///
/// ```rust,no_run
/// #[subxt::subxt(
///     runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale",
/// )]
/// mod polkadot {}
/// ```
///
/// The `subxt` macro will populate the annotated module with all of the methods and types required
/// for interacting with the runtime that the metadata is in via Subxt.
///
/// # Configuration
///
/// This macro supports a number of attributes to configure what is generated:
///
/// ## `crate = "..."`
///
/// Use this attribute to specify a custom path to the `subxt` crate:
///
/// ```rust
/// # pub extern crate subxt;
/// # pub mod path { pub mod to { pub use subxt; } }
/// # fn main() {}
/// #[subxt::subxt(
///     runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale",
///     crate = "crate::path::to::subxt"
/// )]
/// mod polkadot {}
/// ```
///
/// This is useful if you write a library which uses this macro, but don't want to force users to depend on `subxt`
/// at the top level too. By default the path `::subxt` is used.
///
/// ## `substitute_type(path = "...", with = "...")`
///
/// This attribute replaces any reference to the generated type at the path given by `path` with a
/// reference to the path given by `with`.
///
/// ```rust
/// #[subxt::subxt(
///     runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale",
///     substitute_type(path = "sp_arithmetic::per_things::Perbill", with = "crate::Foo")
/// )]
/// mod polkadot {}
///
/// # #[derive(
/// #     scale_encode::EncodeAsType,
/// #     scale_decode::DecodeAsType,
/// #     codec::Encode,
/// #     codec::Decode,
/// #     Clone,
/// #     Debug,
/// # )]
/// // In reality this needs some traits implementing on
/// // it to allow it to be used in place of Perbill:
/// pub struct Foo(u32);
/// # impl codec::CompactAs for Foo {
/// #     type As = u32;
/// #     fn encode_as(&self) -> &Self::As {
/// #         &self.0
/// #     }
/// #     fn decode_from(x: Self::As) -> Result<Self, codec::Error> {
/// #         Ok(Foo(x))
/// #     }
/// # }
/// # impl From<codec::Compact<Foo>> for Foo {
/// #     fn from(v: codec::Compact<Foo>) -> Foo {
/// #         v.0
/// #     }
/// # }
/// # fn main() {}
/// ```
///
/// If the type you're substituting contains generic parameters, you can "pattern match" on those, and
/// make use of them in the substituted type, like so:
///
/// ```rust,no_run
/// #[subxt::subxt(
///     runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale",
///     substitute_type(
///         path = "sp_runtime::multiaddress::MultiAddress<A, B>",
///         with = "::subxt::utils::Static<::sp_runtime::MultiAddress<A, B>>"
///     )
/// )]
/// mod polkadot {}
/// ```
///
/// The above is also an example of using the [`crate::utils::Static`] type to wrap some type which doesn't
/// on it's own implement [`scale_encode::EncodeAsType`] or [`scale_decode::DecodeAsType`], which are required traits
/// for any substitute type to implement by default.
///
/// ## `derive_for_all_types = "..."`
///
/// By default, all generated types derive a small set of traits. This attribute allows you to derive additional
/// traits on all generated types:
///
/// ```rust,no_run
/// #[subxt::subxt(
///     runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale",
///     derive_for_all_types = "Eq, PartialEq"
/// )]
/// mod polkadot {}
/// ```
///
/// Any substituted types (including the default substitutes) must also implement these traits in order to avoid errors
/// here.
///
/// ## `derive_for_type(path = "...", derive = "...")`
///
/// Unlike the above, which derives some trait on every generated type, this attribute allows you to derive traits only
/// for specific types. Note that any types which are used inside the specified type may also need to derive the same traits.
///
/// ```rust,no_run
/// #[subxt::subxt(
///     runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale",
///     derive_for_all_types = "Eq, PartialEq",
///     derive_for_type(path = "frame_support::PalletId", derive = "Ord, PartialOrd"),
///     derive_for_type(path = "sp_runtime::ModuleError", derive = "Hash"),
/// )]
/// mod polkadot {}
/// ```
///
/// ## `runtime_metadata_insecure_url = "..."`
///
/// This attribute can be used instead of `runtime_metadata_path` and will tell the macro to download metadata from a node running
/// at the provided URL, rather than a node running locally. This can be useful in CI, but is **not recommended** in production code,
/// since it runs at compile time and will cause compilation to fail if the node at the given address is unavailable or unresponsive.
///
/// ```rust,ignore
/// #[subxt::subxt(
///     runtime_metadata_insecure_url = "wss://rpc.polkadot.io:443"
/// )]
/// mod polkadot {}
/// ```
///
/// ## `generate_docs`
///
/// By default, documentation is not generated via the macro, since IDEs do not typically make use of it. This attribute
/// forces documentation to be generated, too.
///
/// ```rust,no_run
/// #[subxt::subxt(
///     runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale",
///     generate_docs
/// )]
/// mod polkadot {}
/// ```
///
/// ## `runtime_types_only`
///
/// By default, the macro will generate various interfaces to make using Subxt simpler in addition with any types that need
/// generating to make this possible. This attribute makes the codegen only generate the types and not the Subxt interface.
///
/// ```rust,no_run
/// #[subxt::subxt(
///     runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale",
///     runtime_types_only
/// )]
/// mod polkadot {}
/// ```
///
/// ## `no_default_derives`
///
/// By default, the macro will add all derives necessary for the generated code to play nicely with Subxt. Adding this attribute
/// removes all default derives.
///
/// ```rust,no_run
/// #[subxt::subxt(
///     runtime_metadata_path = "../artifacts/polkadot_metadata_full.scale",
///     runtime_types_only,
///     no_default_derives,
///     derive_for_all_types="codec::Encode, codec::Decode"
/// )]
/// mod polkadot {}
/// ```
///
/// **Note**: At the moment, you must derive at least one of `codec::Encode` or `codec::Decode` or `scale_encode::EncodeAsType` or
/// `scale_decode::DecodeAsType` (because we add `#[codec(..)]` attributes on some fields/types during codegen), and you must use this
/// feature in conjunction with `runtime_types_only` (or manually specify a bunch of defaults to make codegen work properly when
/// generating the subxt interfaces).
///
/// ## `unstable_metadata`
///
/// This attribute works only in combination with `runtime_metadata_insecure_url`. By default, the macro will fetch the latest stable
/// version of the metadata from the target node. This attribute makes the codegen attempt to fetch the unstable version of
/// the metadata first. This is **not recommended** in production code, since the unstable metadata a node is providing is likely
/// to be incompatible with Subxt.
///
/// ```rust,ignore
/// #[subxt::subxt(
///     runtime_metadata_insecure_url = "wss://rpc.polkadot.io:443",
///     unstable_metadata
/// )]
/// mod polkadot {}
/// ```
pub use subxt_macro::subxt;
